================
CODE SNIPPETS
================
TITLE: Zig: Add io.Writer.writeStruct
DESCRIPTION: Adds a `writeStruct` method to the `io.Writer` interface. This allows for convenient writing of struct data to output streams.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
add io.Writer.writeStruct
```

--------------------------------

TITLE: Configure Zig IO Mode to Evented
DESCRIPTION: This code snippet demonstrates how to configure the IO mode for a Zig application to be evented. Setting `pub const io_mode = .evented;` in the root source file enables asynchronous I/O operations where functions like `std.os.read` will suspend on EAGAIN until the file descriptor is available for reading. This integration currently works on Linux.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
pub const io_mode = .evented;
```

--------------------------------

TITLE: Zig system interface selection
DESCRIPTION: This Zig code snippet defines the `system` constant, which selects the appropriate system interface based on the target operating system and whether libc is linked. If libc is linked, it uses `std.c`. Otherwise, it dispatches to OS-specific interfaces like `darwin`, `freebsd`, `linux`, `wasi`, `windows`, or `zen`. For unsupported OSes, it defaults to an empty struct.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: zig
CODE:
```
/// When linking libc, this is the C API. Otherwise, it is the OS-specific system interface. pub const system = if (builtin.link_libc) std.c else switch (builtin.os) {
    .macosx, .ios, .watchos, .tvos => darwin,
    .freebsd => freebsd,
    .linux => linux,
    .netbsd => netbsd,
    .dragonfly => dragonfly,
    .wasi => wasi,
    .windows => windows,
    .zen => zen,
    else => struct {},
};
```

--------------------------------

TITLE: Check if Zig IO Mode is Async
DESCRIPTION: This snippet shows how to check if the current IO mode in Zig is set to asynchronous. The `std.io.is_async` boolean is equivalent to checking if `std.io.mode` is equal to `.evented`. This flag influences how `std.io.InStream` handles read operations, potentially using async function pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.io.is_async
```

LANGUAGE: Zig
CODE:
```
std.io.mode == .evented
```

--------------------------------

TITLE: Zig: Linux fallocate() to io_uring
DESCRIPTION: Adds the `fallocate()` system call to the Linux `io_uring` interface. This allows for pre-allocation of disk space for files asynchronously.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
linux: add fallocate() to io_uring
```

--------------------------------

TITLE: BoundedArray Add Writer interface
DESCRIPTION: Adds `Writer` interface compatibility to `BoundedArray`. This allows `BoundedArray` instances to be used with functions and libraries that expect a `Writer`, facilitating easier data output.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
BoundedArray: Add Writer interface
```

--------------------------------

TITLE: Zig Allocator Interface Update
DESCRIPTION: Illustrates the breaking changes to the `mem.Allocator` interface in Zig 0.9. It shows how to update function parameter types and struct field types from `*Allocator` to `Allocator`, and how to access the allocator instance from a pointer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
*Allocator
```

LANGUAGE: zig
CODE:
```
Allocator
```

LANGUAGE: zig
CODE:
```
&gpa.allocator
```

LANGUAGE: zig
CODE:
```
gpa.allocator()
```

--------------------------------

TITLE: Zig Allocator Interface Resize
DESCRIPTION: Demonstrates how the Zig Allocator interface now allows implementations to refuse shrinking, improving efficiency for ArrayList by avoiding unnecessary data copying during resize operations. It shows a fallback mechanism for allocating new buffers and copying data when in-place resizing fails.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
const old_memory = self.allocatedSlice();
if (allocator.resize(old_memory, new_capacity)) {
    self.capacity = new_capacity;
} else {
    const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
    @memcpy(new_memory[0..self.items.len], self.items);
    allocator.free(old_memory);
    self.items.ptr = new_memory.ptr;
    self.capacity = new_memory.len;
}
```

--------------------------------

TITLE: Fix Reader.readUntilDelimiterOrEofAlloc() API
DESCRIPTION: This update fixes the API for Reader.readUntilDelimiterOrEofAlloc(), ensuring correct behavior when reading until a delimiter or the end of the file in Zig's io module.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html



--------------------------------

TITLE: Zig Standard Library: io_uring Enhancements for Linux
DESCRIPTION: Details improvements to the `io_uring` interface in Zig's standard library for Linux. This includes fixes for version checks in tests, optimizations for `IO_Uring.copy_cqe`, and the addition of `recvmsg` and `sendmsg` operations. It also covers automatic buffer selection, new flags and opcodes, and support for optional arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example usage of io_uring (conceptual)
const io_uring = std.io.uring;

pi@async fn example() !void {
    var ring = try io_uring.Ring.init(.{});
    defer ring.deinit();

    // Example: Using recvmsg
    var msg: msghdr = undefined;
    var cmsg: cmsghdr = undefined;
    msg.msg_control = &cmsg;
    // ... setup msg and associated buffers ...
    try ring.recvmsg(1, &msg, null);

    // Example: Using sendmsg
    try ring.sendmsg(2, &msg, null);

    // Example: Automatic buffer selection
    try ring.read(3, .{ .buf_group = .auto });
}

```

--------------------------------

TITLE: Adapt Stream to New API in Zig
DESCRIPTION: Demonstrates how to use `adaptToNewApi()` to create a new stream interface from an old one. This is useful when migrating from older stream implementations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.15.1/release-notes.html

LANGUAGE: zig
CODE:
```
fn foo(old_writer: anytype) !void {
    var adapter = old_writer.adaptToNewApi(&.{});
    const w: *std.Io.Writer = &adapter.new_interface;
    try w.print("{s}", .{"example");
    // ...
}
```

--------------------------------

TITLE: Zig: Target.Abi add gnuilp32
DESCRIPTION: Adds the `gnuilp32` ABI (Application Binary Interface) to the `Target.Abi` enumeration. This supports targeting systems that use this specific ABI.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Target.Abi: add gnuilp32
```

--------------------------------

TITLE: Improve Target Handling in Zig CLI
DESCRIPTION: Introduces breaking changes to how targets are handled in the Zig compiler. The command-line interface now uses `-target [name]` instead of `--target-*` arguments, aligning with clang's interface. It also renames `builtin.Environ` to `builtin.Abi` and `builtin.environ` to `builtin.abi`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: Zig
CODE:
```
-target [name]
```

LANGUAGE: Zig
CODE:
```
builtin.Environ
```

LANGUAGE: Zig
CODE:
```
builtin.Abi
```

LANGUAGE: Zig
CODE:
```
builtin.environ
```

LANGUAGE: Zig
CODE:
```
builtin.abi
```

--------------------------------

TITLE: Update Allocator Interface for Freed Memory
DESCRIPTION: The `std.mem.Allocator` interface has been updated to set memory to undefined when freed. This change, though planned to be reverted to allocator implementations, aims to improve memory safety by preventing accidental use of freed memory.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.mem.Allocator
```

--------------------------------

TITLE: Zig: `ArrayListUnmanaged` Writer Implementation
DESCRIPTION: Implements the `writer()` interface for `ArrayListUnmanaged`, enabling it to be used with I/O operations that expect a writer, similar to `ArrayList`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
`ArrayListUnmanaged`: implement writer().
```

--------------------------------

TITLE: Zig Hello World Program
DESCRIPTION: A basic 'Hello, world!' program in Zig. It imports the standard IO library and prints the message to standard output. The example also shows how to compile and run the Zig code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.1/index.html

LANGUAGE: zig
CODE:
```
const io = @import("std").io;

pub fn main() -> %void {
    %%io.stdout.printf("Hello, world!\n");
}
```

--------------------------------

TITLE: Zig Standard Library: std.io.readLine
DESCRIPTION: Announces the addition of `std.io.readLine` to the Zig standard library, providing a convenient way to read a line of input from an I/O stream.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const readLine = std.io.readLine;
```

--------------------------------

TITLE: Zig MachO Linker: Cross-Compilation to iOS
DESCRIPTION: Details the process and requirements for cross-compiling Zig code to iOS and iOS simulator targets using the MachO linker. It references an external repository for detailed instructions and examples.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
// To cross-compile for iOS, you need a sysroot provided by the user.
// Refer to https://github.com/kubkon/zig-ios-example for detailed setup and usage.

// Example command structure (conceptual):
// zig build-exe --target ios-aarch64 --sysroot /path/to/ios/sysroot main.zig

// The linker handles MachO generation for the target platform.
```

--------------------------------

TITLE: Configure Zig Async IO Stream Frame Size
DESCRIPTION: This code demonstrates how to configure the frame size for `std.io.InStream` when using asynchronous I/O in Zig. By declaring `pub const stack_size_std_io_InStream` in the root source file, developers can adjust the buffer size used for read calls, which is important for performance and avoiding runtime safety issues related to buffer allocation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
pub const stack_size_std_io_InStream = 1234;
```

--------------------------------

TITLE: Fix IP Parsing on macOS with libc
DESCRIPTION: Addresses an issue with parsing IP addresses on macOS by utilizing the libc `if_nametoindex` function. This ensures correct handling of network interface names when converting them to indices.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.1/release-notes.html

LANGUAGE: Zig
CODE:
```
use libc `if_nametoindex` for macOS when parsing IPs
```

--------------------------------

TITLE: Zig iOS and iPhone Simulator Support
DESCRIPTION: Zig 0.9.0 now targets iOS and iPhone Simulator platforms, leveraging improvements in the self-hosted linker and support for Objective-C compilation. A GitHub repository provides a complete example for using Zig with iOS.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Thanks to major improvements in the {#link|Self-Hosted Linker#} combined with support for compiling {#link|Objective-C|Objective-C and Objective-C++#}, along with miscellaneous improvements in the {#link|Self-Hosted Compiler#}, Zig now targets iOS and iPhone Simulator platforms. See [kubkon/zig-ios-example](https://github.com/kubkon/zig-ios-example) for a complete example.
```

--------------------------------

TITLE: Implement Zig Allocator Interface
DESCRIPTION: To implement a custom allocator in Zig, you need to define an `allocFn` and a `resizeFn` that adhere to the Allocator interface documented in `std/mem.zig`. Examples can be found in `std/heap.zig`, such as the `GeneralPurposeAllocator`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Define your allocator struct
const MyAllocator = struct {
    // Add any necessary fields for your allocator

    // Implement the allocFn
    pub fn allocFn(self: *MyAllocator, size: usize, align: usize) ![*]u8 {
        // Your allocation logic here
        // Example: return std.heap.page_allocator.allocFn(self, size, align);
        unimplemented;
    }

    // Implement the resizeFn
    pub fn resizeFn(self: *MyAllocator, ptr: [*]u8, old_size: usize, new_size: usize, align: usize) ![*]u8 {
        // Your resizing logic here
        // Example: return std.heap.page_allocator.resizeFn(self, ptr, old_size, new_size, align);
        unimplemented;
    }
};

// Example usage (assuming you have a way to instantiate MyAllocator)
// var my_allocator = MyAllocator{};
// var buffer = try my_allocator.alloc(1024, 8);

```

--------------------------------

TITLE: Zig std.io.readLine Enhancements
DESCRIPTION: The std.io.readLine function has been revamped with a new prototype and additional helper functions like std.io.readLineFrom, std.io.readLineSlice, and std.io.readLineSliceFrom. These improvements offer more flexibility in reading lines from input streams.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.io.readLine
```

LANGUAGE: zig
CODE:
```
std.io.readLineFrom
```

LANGUAGE: zig
CODE:
```
std.io.readLineSlice
```

LANGUAGE: zig
CODE:
```
std.io.readLineSliceFrom
```

--------------------------------

TITLE: Zig Hello World Program
DESCRIPTION: A basic 'Hello, world!' program in Zig. It imports the standard IO library and prints the message to standard output. The example also shows how to compile and run the Zig code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.0/index.html

LANGUAGE: zig
CODE:
```
const io = @import("std").io;

pub fn main() -> %void {
    %%io.stdout.printf("Hello, world!\n");
}
```

--------------------------------

TITLE: Zig WASI Example: Accessing Command Line Arguments
DESCRIPTION: Shows how to use the WebAssembly System Interface (WASI) in Zig to access and print command-line arguments. It utilizes Zig's standard library for process argument handling and memory allocation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
    
    pub fn main() !void {
        var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
        const gpa = &general_purpose_allocator.allocator;
        const args = try std.process.argsAlloc(gpa);
        defer std.process.argsFree(gpa, args);
    
        for (args) |arg, i| {
            std.debug.print("{}: \{\n", .{ i, arg });
        }
    }
```

--------------------------------

TITLE: Implement Zig Allocator Interface
DESCRIPTION: To implement a custom allocator in Zig, you need to define an `allocFn` and a `resizeFn` that adhere to the Allocator interface documented in `std/mem.zig`. Examples can be found in `std/heap.zig`, such as the `GeneralPurposeAllocator`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Define your allocator struct
const MyAllocator = struct {
    // Add any necessary fields for your allocator

    // Implement the allocFn
    pub fn allocFn(self: *MyAllocator, size: usize, align: usize) ![*]u8 {
        // Your allocation logic here
        // Example: return std.heap.page_allocator.allocFn(self, size, align);
        unimplemented;
    }

    // Implement the resizeFn
    pub fn resizeFn(self: *MyAllocator, ptr: [*]u8, old_size: usize, new_size: usize, align: usize) ![*]u8 {
        // Your resizing logic here
        // Example: return std.heap.page_allocator.resizeFn(self, ptr, old_size, new_size, align);
        unimplemented;
    }
};

// Example usage (assuming you have a way to instantiate MyAllocator)
// var my_allocator = MyAllocator{};
// var buffer = try my_allocator.alloc(1024, 8);

```

--------------------------------

TITLE: Zig WASI Example: Accessing Command Line Arguments
DESCRIPTION: Shows how to use the WebAssembly System Interface (WASI) in Zig to access and print command-line arguments. It utilizes Zig's standard library for process argument handling and memory allocation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
    
    pub fn main() !void {
        var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
        const gpa = &general_purpose_allocator.allocator;
        const args = try std.process.argsAlloc(gpa);
        defer std.process.argsFree(gpa, args);
    
        for (args) |arg, i| {
            std.debug.print("{}: \{\n", .{ i, arg });
        }
    }
```

--------------------------------

TITLE: Implement Zig Allocator Interface
DESCRIPTION: To implement a custom allocator in Zig, you need to define an `allocFn` and a `resizeFn` that adhere to the Allocator interface documented in `std/mem.zig`. Examples can be found in `std/heap.zig`, such as the `GeneralPurposeAllocator`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Define your allocator struct
const MyAllocator = struct {
    // Add any necessary fields for your allocator

    // Implement the allocFn
    pub fn allocFn(self: *MyAllocator, size: usize, align: usize) ![*]u8 {
        // Your allocation logic here
        // Example: return std.heap.page_allocator.allocFn(self, size, align);
        unimplemented;
    }

    // Implement the resizeFn
    pub fn resizeFn(self: *MyAllocator, ptr: [*]u8, old_size: usize, new_size: usize, align: usize) ![*]u8 {
        // Your resizing logic here
        // Example: return std.heap.page_allocator.resizeFn(self, ptr, old_size, new_size, align);
        unimplemented;
    }
};

// Example usage (assuming you have a way to instantiate MyAllocator)
// var my_allocator = MyAllocator{};
// var buffer = try my_allocator.alloc(1024, 8);

```

--------------------------------

TITLE: Remove deceptive std.io.readLine
DESCRIPTION: The `std.io.readLine` function has been removed. It was misleadingly named and intended for CLI text input, but lacked the necessary functionality. For reading line-delimited input, users should refer to the I/O Streams documentation. The `guess_number` example demonstrates using `std.fs.File.read` for CLI input.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.io.readLine
```

LANGUAGE: Zig
CODE:
```
std.fs.File.read
```

--------------------------------

TITLE: Implement Zig Allocator Interface
DESCRIPTION: To implement a custom allocator in Zig, you need to define an `allocFn` and a `resizeFn` that adhere to the Allocator interface documented in `std/mem.zig`. Examples can be found in `std/heap.zig`, such as the `GeneralPurposeAllocator`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Define your allocator struct
const MyAllocator = struct {
    // Add any necessary fields for your allocator

    // Implement the allocFn
    pub fn allocFn(self: *MyAllocator, size: usize, align: usize) ![*]u8 {
        // Your allocation logic here
        // Example: return std.heap.page_allocator.allocFn(self, size, align);
        unimplemented;
    }

    // Implement the resizeFn
    pub fn resizeFn(self: *MyAllocator, ptr: [*]u8, old_size: usize, new_size: usize, align: usize) ![*]u8 {
        // Your resizing logic here
        // Example: return std.heap.page_allocator.resizeFn(self, ptr, old_size, new_size, align);
        unimplemented;
    }
};

// Example usage (assuming you have a way to instantiate MyAllocator)
// var my_allocator = MyAllocator{};
// var buffer = try my_allocator.alloc(1024, 8);

```

--------------------------------

TITLE: Implement Zig Allocator Interface
DESCRIPTION: To implement a custom allocator in Zig, you need to define an `allocFn` and a `resizeFn` that adhere to the Allocator interface documented in `std/mem.zig`. Examples can be found in `std/heap.zig`, such as the `GeneralPurposeAllocator`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Define your allocator struct
const MyAllocator = struct {
    // Add any necessary fields for your allocator

    // Implement the allocFn
    pub fn allocFn(self: *MyAllocator, size: usize, align: usize) ![*]u8 {
        // Your allocation logic here
        // Example: return std.heap.page_allocator.allocFn(self, size, align);
        unimplemented;
    }

    // Implement the resizeFn
    pub fn resizeFn(self: *MyAllocator, ptr: [*]u8, old_size: usize, new_size: usize, align: usize) ![*]u8 {
        // Your resizing logic here
        // Example: return std.heap.page_allocator.resizeFn(self, ptr, old_size, new_size, align);
        unimplemented;
    }
};

// Example usage (assuming you have a way to instantiate MyAllocator)
// var my_allocator = MyAllocator{};
// var buffer = try my_allocator.alloc(1024, 8);

```

--------------------------------

TITLE: Zig: Linux io_uring sync with liburing
DESCRIPTION: Synchronizes the Zig `io_uring` library with the upstream `liburing` library. This ensures that Zig's asynchronous I/O capabilities are up-to-date with the latest features and fixes.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
linux: sync io_uring library with liburing
```

--------------------------------

TITLE: Allow Pointers to Anything in Extern/Exported Declarations (Zig)
DESCRIPTION: Enables the use of pointers to any type within `extern` and `exported` declarations. This provides greater flexibility when interfacing with C code or other external interfaces.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
// Example of allowing pointers to anything in extern declarations:
extern fn process_data(data: *const u8) void;

// Example of allowing pointers to anything in exported declarations:
export fn handle_input(input: [*]const i32) usize {
    // ... implementation ...
    return 0;
}

```

--------------------------------

TITLE: Zig io_uring Enhancements
DESCRIPTION: This snippet details improvements to Zig's io_uring integration, including new functions for event file registration, asynchronous operations, and poll updates. It also covers cancellation mechanisms and file registration updates.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
register_eventfd
register_eventfd_async
unregister_eventfd
read_fixed
write_fixed
statx
poll_update
cancel
io_uring_prep_cancel
register_files_update
link_timeout
```

--------------------------------

TITLE: Zig: Linux IO_Uring.timeout fix
DESCRIPTION: Corrects an issue with the `timeout` functionality in the Linux `IO_Uring` implementation. This ensures that timeouts for asynchronous I/O operations are handled correctly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
linux: fix IO_Uring.timeout
```

--------------------------------

TITLE: Zig C ABI Compatible Enum
DESCRIPTION: Explains and demonstrates the use of `extern enum` in Zig to create enums that are compatible with the C Application Binary Interface (ABI). This is crucial when interfacing Zig code with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
const Foo = extern enum { a, b, c };
export fn entry(foo: Foo) void { }

    $ zig build-obj test.zig
```

--------------------------------

TITLE: Zig Build System: Upgrade iovec Structure
DESCRIPTION: This shows an upgrade in the Zig build system, specifically how the `iovec` structure is used. It demonstrates the change from using `.iov_base` and `.iov_len` to `.base` and `.len` for specifying buffer information.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.13.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Old syntax (pre-upgrade):
// .{ .iov_base = message.ptr, .iov_len = message.len },

// New syntax (post-upgrade):
.{ .base = message.ptr, .len = message.len },

```

--------------------------------

TITLE: Introduce std.io.poll
DESCRIPTION: Adds the std.io.poll functionality, providing a mechanism for monitoring multiple file descriptors for I/O readiness.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
introduce std.io.poll
```

--------------------------------

TITLE: Zig std.io.InStream.readStruct Return Value
DESCRIPTION: The std.io.InStream(E).readStruct method now returns a value instead of taking a pointer. This change improves type safety and simplifies data deserialization.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.io.InStream(E).readStruct
```

--------------------------------

TITLE: Add readAllArrayListAligned to Reader
DESCRIPTION: Introduces `readAllArrayListAligned` to the `Reader` interface, allowing for arbitrary alignment. This fixes a compile error in `fs.File.readToEndAllocOptions` when specifying alignment.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: zig
CODE:
```
pub fn readAllArrayListAligned(self: Self, comptime T: type, allocator: Allocator, alignment: usize) !T {
    // ... implementation details ...
}
```

--------------------------------

TITLE: WASI: Fix os.isatty on type mismatch
DESCRIPTION: The `os.isatty` function for WASI has been fixed to correctly handle type mismatches. This ensures that checks for terminal interactivity are accurate and robust.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.os.isatty
```

--------------------------------

TITLE: Cross-compile C to WASI with Zig
DESCRIPTION: Zig now ships with WASI libc and supports cross-compiling C code to the WebAssembly System Interface (WASI).

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: c
CODE:
```
// Example C code to be compiled for WASI
int main() {
    return 0;
}
```

LANGUAGE: zig
CODE:
```
#zig build-exe src/main.c --target wasm32-wasi
```

--------------------------------

TITLE: Zig Operating System Abstractions
DESCRIPTION: Zig's OS abstractions have been reorganized. `std.os` provides a Zig-flavored POSIX interface with error translation and slice usage. Cross-platform abstractions are in category-specific namespaces like `std.fs.File.openRead`. Windows support includes `std.os.windows` with error translation for `GetLastError` and direct access to Windows APIs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.os
O_RDONLY
open
std.os.windows
GetLastError
std.os.windows.kernel32.ExitProcess
```

--------------------------------

TITLE: Zig Pointers: Sentinel-Terminated Pointers
DESCRIPTION: Shows how to work with sentinel-terminated pointers in Zig, commonly used when interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: zig
CODE:
```
const c_str = "example\0";
const ptr_to_str: [*]const u8 = c_str;

// Iterate until null terminator
var i: usize = 0;
while (ptr_to_str[i] != 0) {
    // process character
    i += 1;
}

```

--------------------------------

TITLE: Zig: Implement fmtDuration using Formatter
DESCRIPTION: Implements the `fmtDuration` function using the `Formatter` interface, referencing issue #8137. This change standardizes duration formatting and potentially improves performance.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Implement fmtDuration using Formatter ([#8137](https://github.com/ziglang/zig/issues/8137))
```

--------------------------------

TITLE: Improve std.io.Reader and std.io.Writer
DESCRIPTION: Adds streamUntilDelimiter to std.io.Reader and support for non-power-of-two integer sizes to std.io.Writer. Also includes fixes for Reader.readIntoBoundedBytes and support for non-comptime streams in multi-writer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.io.reader.Reader: add `streamUntilDelimiter`
std.io.Writer: add support for non-power-of-two int sizes
Fix type mismatch for Reader.readIntoBoundedBytes
std.io.multi-writer: support non-comptime streams
```

--------------------------------

TITLE: Zig Async I/O Mode
DESCRIPTION: Configuration snippet for enabling evented I/O mode in Zig, which is compatible with the new async I/O features.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: zig
CODE:
```
pub const io_mode = .evented;
```

--------------------------------

TITLE: Zig Volatile Pointer for Memory-Mapped I/O
DESCRIPTION: Demonstrates the use of `volatile` pointers in Zig for handling memory-mapped I/O (MMIO). It shows how to declare a volatile pointer and asserts its type, ensuring loads and stores have side effects and maintain order.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const assert = @import("std").debug.assert;
    
test "volatile" {
        const mmio_ptr = @intToPtr(*volatile u8, 0x12345678);
        assert(@typeOf(mmio_ptr) == *volatile u8);
    }
```

--------------------------------

TITLE: Zig WebAssembly Support
DESCRIPTION: This section details Zig's support for WebAssembly, including freestanding compilation and the WebAssembly System Interface (WASI).

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: Zig
CODE:
```
Freestanding
WASI
```

--------------------------------

TITLE: Zig std.io.SeekableStream and Debug Info
DESCRIPTION: Introduced std.io.SeekableStream, which is now used by Dwarf debug info instead of std.os.File directly. This change facilitates easier debug info parsing, especially for bare metal projects.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.io.SeekableStream
```

--------------------------------

TITLE: Zig @intToPtr Function
DESCRIPTION: Converts an integer value to a pointer of a specified destination type. This is a low-level operation useful for memory manipulation or interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.1/index.html

LANGUAGE: zig
CODE:
```
comptime DestType: type, int: usize
```

--------------------------------

TITLE: Zig Async I/O Mode Configuration
DESCRIPTION: This snippet shows how to configure the Zig build to use evented I/O, enabling the use of 'await' within the main function. This is a fundamental step for utilizing the experimental async I/O features.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
pub const io_mode = .evented;
```

--------------------------------

TITLE: Zig Integer Read/Write Function Rework
DESCRIPTION: Significant rework of integer read/write functions across io.InStream and mem modules. This includes renaming, parameter changes, introduction of new functions like readIntForeign and writeIntNative, and modifications to endianness handling.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
io.InStream().readIntNative
```

LANGUAGE: zig
CODE:
```
io.InStream().readIntLittle
```

LANGUAGE: zig
CODE:
```
io.InStream().readIntBig
```

LANGUAGE: zig
CODE:
```
io.InStream().readIntForeign
```

LANGUAGE: zig
CODE:
```
io.InStream().writeIntNative
```

LANGUAGE: zig
CODE:
```
io.InStream().writeIntForeign
```

LANGUAGE: zig
CODE:
```
io.InStream().writeIntLittle
```

LANGUAGE: zig
CODE:
```
io.InStream().writeIntBig
```

LANGUAGE: zig
CODE:
```
mem.readIntNative
```

LANGUAGE: zig
CODE:
```
mem.readIntForeign
```

LANGUAGE: zig
CODE:
```
mem.readIntBig
```

LANGUAGE: zig
CODE:
```
mem.readIntLittle
```

LANGUAGE: zig
CODE:
```
mem.readIntSliceNative
```

LANGUAGE: zig
CODE:
```
mem.readIntSliceForeign
```

LANGUAGE: zig
CODE:
```
mem.readIntSliceLittle
```

LANGUAGE: zig
CODE:
```
mem.readIntSliceBig
```

LANGUAGE: zig
CODE:
```
mem.readIntSlice
```

LANGUAGE: zig
CODE:
```
mem.writeIntNative
```

LANGUAGE: zig
CODE:
```
mem.writeIntForeign
```

LANGUAGE: zig
CODE:
```
mem.writeIntBig
```

LANGUAGE: zig
CODE:
```
mem.writeIntLittle
```

LANGUAGE: zig
CODE:
```
mem.writeIntSliceForeign
```

LANGUAGE: zig
CODE:
```
mem.writeIntSliceNative
```

LANGUAGE: zig
CODE:
```
mem.writeIntSliceBig
```

LANGUAGE: zig
CODE:
```
mem.writeIntSliceLittle
```

LANGUAGE: zig
CODE:
```
mem.writeIntSlice
```

LANGUAGE: zig
CODE:
```
mem.littleToNative
```

LANGUAGE: zig
CODE:
```
mem.bigToNative
```

LANGUAGE: zig
CODE:
```
mem.toNative
```

LANGUAGE: zig
CODE:
```
mem.nativeTo
```

LANGUAGE: zig
CODE:
```
mem.nativeToLittle
```

LANGUAGE: zig
CODE:
```
mem.nativeToBig
```

--------------------------------

TITLE: Zig: Packed Struct for Memory-Mapped I/O
DESCRIPTION: Defines a packed struct for memory-mapped I/O (MMIO) and demonstrates the correct way to write to a volatile pointer to this struct. It warns against direct field assignment to volatile pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
pub const GpioRegister = packed struct(u8) {
    GPIO0: bool,
    GPIO1: bool,
    GPIO2: bool,
    GPIO3: bool,
    reserved: u4 = 0,
};

const gpio: *volatile GpioRegister = @ptrFromInt(0x0123);

pub fn writeToGpio(new_states: GpioRegister) void {
    // Example of what not to do:
    // BAD! gpio.GPIO0 = true; BAD!

    // Instead, do this:
    gpio.* = new_states;
}
```

--------------------------------

TITLE: Zig 'extern struct' Declaration
DESCRIPTION: Demonstrates declaring C-compatible structs in Zig using the 'extern struct' keyword, useful for interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
extern struct CStruct {
    field1: c_int,
    field2: [*c]c_char,
}
```

--------------------------------

TITLE: Shell Commands for Zig CLI Allocation Example
DESCRIPTION: Provides the shell commands to compile and run the Zig code example for arena allocation in a command-line interface context.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: shell
CODE:
```
$ zig build-exe cli_allocation.zig
$ ./cli_allocation
ptr=i32@7fb79fc72010
```

--------------------------------

TITLE: Add io.counting_reader
DESCRIPTION: Adds io.counting_reader to the Zig standard library, providing a reader that counts the number of bytes read, useful for monitoring data streams.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html



--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: This Zig code snippet demonstrates how to read command-line arguments using the WASI interface. It allocates memory, retrieves arguments, and prints them with their index. The code requires the standard library and is compiled for the wasm32-wasi target.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args, 0..) |arg, i| {
        std.debug.print("{}: {s}
", .{ i, arg });
    }
}
```

LANGUAGE: shell
CODE:
```
$ zig build-exe wasi_args.zig -target wasm32-wasi
```

LANGUAGE: shell
CODE:
```
$ wasmtime wasi_args.wasm 123 hello
0: wasi_args.wasm
1: 123
2: hello
```

--------------------------------

TITLE: Zig: `ppoll` Function Argument Casting
DESCRIPTION: Ensures correct type casting for the number of file descriptors (`fds`) passed to the `ppoll` function, converting it to `nfds_t` for compatibility with system interfaces.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
ppoll: cast number of fds to nfds_t.
```

--------------------------------

TITLE: Zig @intToPtr Function
DESCRIPTION: Converts an integer value to a pointer of a specified destination type. This is a low-level operation useful for memory manipulation or interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.0/index.html

LANGUAGE: zig
CODE:
```
comptime DestType: type, int: usize
```

--------------------------------

TITLE: Zig: fifo.LinearFifo expose reader/writer
DESCRIPTION: Exposes the reader and writer types for `fifo.LinearFifo`. This allows users to directly interact with the read and write ends of the FIFO queue.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
fifo.LinearFifo - Expose reader and writer type.
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: This Zig code snippet demonstrates how to read command-line arguments using the WASI interface. It allocates memory, retrieves arguments, and prints them with their index. The code requires the standard library and is compiled for the wasm32-wasi target.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args, 0..) |arg, i| {
        std.debug.print("{}: {s}
", .{ i, arg });
    }
}
```

LANGUAGE: shell
CODE:
```
$ zig build-exe wasi_args.zig -target wasm32-wasi
```

LANGUAGE: shell
CODE:
```
$ wasmtime wasi_args.wasm 123 hello
0: wasi_args.wasm
1: 123
2: hello
```

--------------------------------

TITLE: Zig Mutex Lock/Unlock API Change
DESCRIPTION: This is a breaking change to Zig's `Thread.Mutex` API, simplifying the interface to `lock()` and `unlock()` methods for acquiring and releasing mutexes.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
`Thread.Mutex`: change API to `lock()` and `unlock()`.
```

--------------------------------

TITLE: Added Support for Darwin Framework Search Directories
DESCRIPTION: The ability to specify Darwin framework search directories has been added, allowing for more flexible linking of macOS and iOS frameworks.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Shell
CODE:
```
zig build -F /path/to/frameworks
```

--------------------------------

TITLE: Zig: Implement C va_arg with @cVaArg
DESCRIPTION: The @cVaArg function implements the C macro `va_arg` for handling variadic arguments in Zig when interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
@cVaArg(operand: *std.builtin.VaList, comptime T: type) T
```

--------------------------------

TITLE: Skip Zig Tests with Async Suspend Point
DESCRIPTION: Shows how tests with suspend points are skipped by default in blocking IO mode. The example uses an async function with a suspend point.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

test "async skip test" {
    var frame = async func();
    const result = await frame;
    try std.testing.expect(result == 1);
}

fn func() i32 {
    suspend {
        resume @frame();
    }
    return 1;
}
```

--------------------------------

TITLE: Zig: Write to File (Evented)
DESCRIPTION: A Zig program that writes to a file using evented I/O. This example utilizes the `io_mode = .evented` setting, demonstrating how Zig handles asynchronous file operations, often involving thread pools for blocking tasks on systems without native async file system support.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
pub const io_mode = .evented;
pub fn main() anyerror!void {
    const file = try std.fs.cwd().createFile("hello.txt", .{
    });
    defer file.close();
    try file.writeAll("hello\n");
}
```

--------------------------------

TITLE: Zig: Remove io.AutoIndentingStream
DESCRIPTION: Removes the `io.AutoIndentingStream` type. This suggests that its functionality may have been deprecated, merged, or replaced by other mechanisms.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
remove io.AutoIndentingStream
```

--------------------------------

TITLE: Zig Allocator Interface
DESCRIPTION: Demonstrates how to implement a custom allocator in Zig by providing `reallocFn` and `shrinkFn`. It references documentation comments in `std/mem.zig` and provides examples of existing allocators.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

const Allocator = std.mem.Allocator;

pub fn reallocFn(self: *const Allocator, old_memory: [*]u8, old_size: usize, new_size: usize, alignment: usize) ![*]u8 {
    // Implementation details for reallocation
    return undefined;
}

pub fn shrinkFn(self: *const Allocator, memory: [*]u8, size: usize, new_size: usize, alignment: usize) ![*]u8 {
    // Implementation details for shrinking memory
    return undefined;
}

// Example usage would involve creating a struct that holds these functions
// and passing it as an Allocator instance.
```

--------------------------------

TITLE: Zig: `io.FixedBufferStream` Seek Functionality
DESCRIPTION: Fixes a bug in the `seekTo` method of `io.FixedBufferStream`, ensuring that seeking operations within fixed-size buffers function correctly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
Fix bug in io.FixedBufferStream seekTo ([#9023](https://github.com/ziglang/zig/issues/9023)).
```

--------------------------------

TITLE: Zig Assembly Integration
DESCRIPTION: Zig allows for inline assembly, enabling direct interaction with the underlying hardware and C ABI. This is useful for performance-critical sections or when interfacing with existing assembly code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

fn add(a: i32, b: i32) i32 {
    var sum: i32;
    asm volatile (
        "add %0, %1, %2\n"
        : "=r"(sum) // Output operand: sum is stored in a general-purpose register
        : "r"(a), "r"(b) // Input operands: a and b are in general-purpose registers
    );
    return sum;
}

pi const result = add(5, 7);
std.debug.print("Assembly add result: {d}\\n", .{result});

```

--------------------------------

TITLE: Zig Assembly Integration
DESCRIPTION: Zig allows for inline assembly, enabling direct interaction with the underlying hardware and C ABI. This is useful for performance-critical sections or when interfacing with existing assembly code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

fn add(a: i32, b: i32) i32 {
    var sum: i32;
    asm volatile (
        "add %0, %1, %2\n"
        : "=r"(sum) // Output operand: sum is stored in a general-purpose register
        : "r"(a), "r"(b) // Input operands: a and b are in general-purpose registers
    );
    return sum;
}

pi const result = add(5, 7);
std.debug.print("Assembly add result: {d}\\n", .{result});

```

--------------------------------

TITLE: Zig Opaque Type Declaration
DESCRIPTION: Shows how to declare opaque types in Zig, which have an unknown but non-zero size and alignment. This is useful for type safety when interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Add Termios Types to c.linux and os
DESCRIPTION: Includes missing termios types in the `c.linux` and `os` modules. This provides necessary definitions for terminal I/O control, enabling better interaction with terminal devices.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Added missing termios types to `c.linux` and `os`.
```

--------------------------------

TITLE: Zig POSIX Termios: Type-Safe TTY Input Mode
DESCRIPTION: This example demonstrates how Zig's updated POSIX termios API provides type safety for manipulating terminal settings. It shows the transition from bitwise operations to direct boolean assignments for setting immediate input mode.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: zig
CODE:
```
const in = std.io.getStdIn(); // copy original settings and restore them once done const original_termios = try std.posix.tcgetattr(in.handle); defer std.posix.tcsetattr(in.handle, .FLUSH, original_termios) catch {}; // set immediate input mode var termios = original_termios; termios.lflag &= ~@as(std.posix.system.tcflag_t, std.posix.system.ICANON); // flush changes try std.posix.tcsetattr(in.handle, .FLUSH, termios);
```

LANGUAGE: zig
CODE:
```
// set immediate input mode var termios = original_termios; termios.lflag.ICANON = false;
```

--------------------------------

TITLE: Zig: Fix Implicit Casting to *c_void
DESCRIPTION: Corrects the implicit casting behavior when converting to a `*c_void` pointer, ensuring proper type compatibility with C interfaces.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
fix implicit casting to {#syntax#}\*c_void{#endsyntax#} ([#1588](https://github.com/ziglang/zig/issues/1588))
```

--------------------------------

TITLE: Add fnctl for File Control Operations
DESCRIPTION: The `std.os.fnctl` function has been added, providing a way to perform various file control operations. This function offers a POSIX-compliant interface for manipulating file descriptors.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.os.fnctl
```

--------------------------------

TITLE: Update wasi-libc to commit d03829489904d38c624f6de9983190f1e5e7c9c5
DESCRIPTION: This snippet indicates that the bundled wasi-libc copy has been updated to a specific commit hash. This is relevant for WebAssembly System Interface (WASI) targets.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: text
CODE:
```
This release bumps the bundled wasi-libc copy to commit `d03829489904d38c624f6de9983190f1e5e7c9c5`.
```

--------------------------------

TITLE: Zig Async I/O with Blocking Fallback
DESCRIPTION: Illustrates how Zig's asynchronous I/O code functions seamlessly within a blocking I/O environment. This example uses the same concurrent task structure as the evented I/O example, demonstrating the flexibility of Zig's async implementation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() anyerror!void {
    var a_frame = async doA();
    var b_frame = async doB();

    try await a_frame;
    try await b_frame;
}

fn doA() !void {
    const file = try std.fs.cwd().createFile("a.txt", .{}) ;
    defer file.close();
    try file.writeAll("A\n");
}

fn doB() !void {
    const file = try std.fs.cwd().createFile("b.txt", .{}) ;
    defer file.close();
    try file.writeAll("B\n");
}
```

--------------------------------

TITLE: Zig Sentinel-Terminated Pointer for C printf
DESCRIPTION: Demonstrates the use of sentinel-terminated pointers, specifically `[*:0]const u8`, for interfacing with C functions like `printf`. It highlights the requirement for a null terminator.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// This is also available as `std.c.printf`.
pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;

pub fn main() anyerror!void {
    _ = printf("Hello, world!\n"); // OK

    const msg = "Hello, world!\n";
    const non_null_terminated_msg: [msg.len]u8 = msg.*;
    _ = printf(&non_null_terminated_msg);
}
```

--------------------------------

TITLE: Improved CLI Error Message for Missing Sub-Architecture
DESCRIPTION: The command-line interface (CLI) now provides a clearer error message when a sub-architecture is missing, aiding users in diagnosing build issues.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Shell
CODE:
```
zig build --target=x86_64-windows-gnu
```

--------------------------------

TITLE: io_uring sqe prep methods in Zig
DESCRIPTION: Zig 0.9.0 includes new sqe prep methods for `epoll_ctl`, `poll_add`, and `poll_remove` within the io_uring functionality.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
*   Addd sqe prep methods for `epoll_ctl`, `poll_add`, and `poll_remove`.
```

--------------------------------

TITLE: Add Zig std.io.PeekStream and SliceStream
DESCRIPTION: Introduces `std.io.PeekStream` for look-ahead reading and `std.io.SliceStream` (renamed from SliceStream) as a read-only stream wrapper for byte slices.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.io.PeekStream std.io.Slicestream SliceStream read-only stream wrapper slice bytes adapt algorithms InStreams in-memory data PeekStream stream wrapper put back bytes look-ahead parsers easier write
```

--------------------------------

TITLE: Zig @OpaqueType
DESCRIPTION: Creates a new type with an unknown but non-zero size and alignment, typically used for type safety when interfacing with C code that does not expose struct details.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
type
Creates a new type with an unknown (but non-zero) size and alignment.
This is typically used for type safety when interacting with C code that does not expose struct details. Example:
test.zig

    const Derp = @OpaqueType();
    const Wat = @OpaqueType();
    
    extern fn bar(d: *Derp) void;
    fn foo(w: *Wat) callconv(.C) void {
        bar(w);
    }
    
    test "call foo" {
        foo(undefined);
    }

    $ zig test test.zig
    ./docgen_tmp/test.zig:6:9: error: expected type '*Derp', found '*Wat'
        bar(w);
            ^
    ./docgen_tmp/test.zig:6:9: note: pointer type child 'Wat' cannot cast into pointer type child 'Derp'
        bar(w);
            ^
```

--------------------------------

TITLE: Zig Compiler Protocol Communication
DESCRIPTION: Details the binary protocol used for communication between the Zig build system and the Zig compiler. This protocol, enabled by the `--listen` argument, uses TCP or stdio for more detailed information exchange, improving build system integration.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.zig.Server
std.Build.Step.evalZigProcess
```

--------------------------------

TITLE: CLI Alias `-l` for `--library` Parameter
DESCRIPTION: The command-line interface (CLI) now accepts `-l` as an alias for the `--library` parameter, simplifying library specification, e.g., `-lc` instead of `--library c`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Shell
CODE:
```
zig build --library c
```

--------------------------------

TITLE: Zig Keyword: callconv
DESCRIPTION: The `callconv` keyword in Zig allows specifying the calling convention for function types. This is crucial for interoperability, especially when interfacing with C code or different ABIs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
fn add(a: i32, b: i32) i32;

const my_add_ptr: fn(i32, i32) callconv(.C) i32 = add;

// Example of using a different calling convention (hypothetical)
// fn custom_call(f: fn() callconv(.Std) void) void;

```

--------------------------------

TITLE: Implement Basic Linux Termios
DESCRIPTION: A basic implementation of the termios API for Linux has been added. This provides foundational support for controlling terminal I/O characteristics.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Linux termios implementation
```

--------------------------------

TITLE: Zig Keyword: callconv
DESCRIPTION: The `callconv` keyword in Zig allows specifying the calling convention for function types. This is crucial for interoperability, especially when interfacing with C code or different ABIs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
fn add(a: i32, b: i32) i32;

const my_add_ptr: fn(i32, i32) callconv(.C) i32 = add;

// Example of using a different calling convention (hypothetical)
// fn custom_call(f: fn() callconv(.Std) void) void;

```

--------------------------------

TITLE: Zig Allocator Interface Definition
DESCRIPTION: Defines the Allocator struct with reallocFn and shrinkFn signatures. reallocFn handles resizing or moving allocations, potentially returning OutOfMemory. shrinkFn is for deallocating memory and must succeed.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
pub const Allocator = struct { pub const Error = error{OutOfMemory};
/// Realloc is used to modify the size or alignment of an existing allocation, /// as well as to provide the allocator with an opportunity to move an allocation /// to a better location.
/// When the size/alignment is greater than the previous allocation, this function /// returns `error.OutOfMemory` when the requested new allocation could not be granted.
/// When the size/alignment is less than or equal to the previous allocation, /// this function returns `error.OutOfMemory` when the allocator decides the client /// would be better off keeping the extra alignment/size. Clients will call /// `shrinkFn` when they require the allocator to track a new alignment/size, /// and so this function should only return success when the allocator considers /// the reallocation desirable from the allocator's perspective.
/// As an example, `std.ArrayList` tracks a "capacity", and therefore can handle /// reallocation failure, even when `new_n` <= `old_mem.len`. A `FixedBufferAllocator` /// would always return `error.OutOfMemory` for `reallocFn` when the size/alignment /// is less than or equal to the old allocation, because it cannot reclaim the memory, /// and thus the `std.ArrayList` would be better off retaining its capacity.
/// When `reallocFn` returns,
/// `return_value[0..min(old_mem.len, new_byte_count)]` must be the same
/// as `old_mem` was when `reallocFn` is called. The bytes of
/// `return_value[old_mem.len..]` have undefined values.
/// The returned slice must have its pointer aligned at least to `new_alignment` bytes.
reallocFn: fn ( self: *Allocator,
/// Guaranteed to be the same as what was returned from most recent call to
/// `reallocFn` or `shrinkFn`.
/// If `old_mem.len == 0` then this is a new allocation and `new_byte_count`
/// is guaranteed to be >= 1.
old_mem: []u8,
/// If `old_mem.len == 0` then this is `undefined`, otherwise:
/// Guaranteed to be the same as what was returned from most recent call to
/// `reallocFn` or `shrinkFn`.
/// Guaranteed to be >= 1.
/// Guaranteed to be a power of 2.
old_alignment: u29,
/// If `new_byte_count` is 0 then this is a free and it is guaranteed that
/// `old_mem.len != 0`.
new_byte_count: usize,
/// Guaranteed to be >= 1.
/// Guaranteed to be a power of 2.
/// Returned slice's pointer must have this alignment.
new_alignment: u29,
) Error![]u8,
/// This function deallocates memory. It must succeed.
shrinkFn: fn ( self: *Allocator,
/// Guaranteed to be the same as what was returned from most recent call to
/// `reallocFn` or `shrinkFn`.
old_mem: []u8,
/// Guaranteed to be the same as what was returned from most recent call to
/// `reallocFn` or `shrinkFn`.
old_alignment: u29,
/// Guaranteed to be less than or equal to `old_mem.len`.
new_byte_count: usize,
/// If `new_byte_count == 0` then this is `undefined`, otherwise:
/// Guaranteed to be less than or equal to `old_alignment`.
new_alignment: u29,
) []u8,
};
```

--------------------------------

TITLE: Zig Keyword: callconv
DESCRIPTION: The `callconv` keyword in Zig allows specifying the calling convention for function types. This is crucial for interoperability, especially when interfacing with C code or different ABIs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
fn add(a: i32, b: i32) i32;

const my_add_ptr: fn(i32, i32) callconv(.C) i32 = add;

// Example of using a different calling convention (hypothetical)
// fn custom_call(f: fn() callconv(.Std) void) void;

```

--------------------------------

TITLE: Zig Builtin: @offsetOf
DESCRIPTION: Demonstrates the `@offsetOf` builtin function in Zig, which returns the byte offset of a field within a struct. This is essential for memory layout calculations and interfacing with C structures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

const Point = struct {
    x: f32,
    y: f32,
};

pub fn main() void {
    const offset_y = @offsetOf(Point, "y");
    std.debug.print("Byte offset of field 'y': {d}", .{offset_y});
}

```

--------------------------------

TITLE: Zig Builtin: @cUndef
DESCRIPTION: Demonstrates the `@cUndef` builtin function in Zig, which represents an undefined value in a C context. This is used when interfacing with C code that might have uninitialized variables.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

extern fn process_value(val: [*c]const u8) void;

pub fn main() void {
    // In a real scenario, this would be passed to a C function
    // that expects an undefined value.
    // For demonstration, we'll just show the concept.
    const undefined_val = @cUndef(u8);
    std.debug.print("Representing an undefined u8 value.");
    // process_value(@ptrCast([*c]const u8, &undefined_val)); // Example usage
}

```

--------------------------------

TITLE: Zig extern Keyword
DESCRIPTION: The `extern` keyword is used to declare functions or variables that will be resolved at link time, either statically or dynamically. It allows Zig code to interface with external libraries.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
extern fn puts(s: [*c]const u8) c_int;
// ...
puts("Hello from Zig!");
```

--------------------------------

TITLE: Zig Compiler Command Line Option for Evented I/O Testing
DESCRIPTION: Enables evented I/O mode for running Zig tests. This is useful for testing asynchronous operations and I/O-bound scenarios within the Zig test runner.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
--test-evented-io
```

--------------------------------

TITLE: Zig Async Test Skip Example
DESCRIPTION: Illustrates skipping an asynchronous Zig test. The test runner skips the test when it encounters a suspend point in blocking IO mode, as shown in the output.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

test "async skip test" {
    var frame = async func();
    const result = await frame;
    try std.testing.expect(result == 1);
}

fn func() i32 {
    suspend {
        resume @frame();
    }
    return 1;
}
```

--------------------------------

TITLE: Added `-D` CLI Parameter for C Preprocessor Definitions
DESCRIPTION: The command-line interface (CLI) now includes the `-D` parameter for setting C preprocessor definitions, allowing users to define macros during compilation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Shell
CODE:
```
zig build -DENABLE_FEATURE=1
```

--------------------------------

TITLE: Zig CLI: Override Unwind Tables
DESCRIPTION: The Zig command-line interface (CLI) allows users to override default unwind table behavior by adding flags to control their generation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
zig build -Doptimize=release-fast -Dtarget=x86_64-windows-gnu -Dcpu=x86-64 -Denable-stack-probing=false -Dsingle_threaded=true -Ddebug_symbols=false -Dstrip_debug_symbols=true -Dstrip_symbols=true -Dstrip_unwind_tables=true
```

--------------------------------

TITLE: Zig WASI Example with Command Line Arguments
DESCRIPTION: An example of a Zig program compiled for WebAssembly System Interface (WASI). It demonstrates accessing command-line arguments using the standard library and printing them to standard error.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    // TODO a better default allocator that isn't as wasteful!
    const args = try std.process.argsAlloc(std.heap.page_allocator);
    defer std.process.argsFree(std.heap.page_allocator, args);

    for (args) |arg, i| {
        std.debug.warn("{}: {}\n", .{i, arg});
    }
}
```

--------------------------------

TITLE: Zig Tuples: Element Access and Length
DESCRIPTION: Demonstrates how tuples in Zig support element access using array-like indexing and provide a `.len` field for determining the number of elements. This example showcases modifying tuple elements and iterating over them.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "tuples support element access and .len field" {
    var x: i32 = 1234;
    var y: i32 = 4567;
    var tup = .{ x, y };

    tup[0] += 1; // works as long as the indexes are comptime-known
    tup[1] -= 1;

    expect(tup[0] == 1235);
    expect(tup[1] == 4566);

    // now we iterate over the fields
    var sum: i32 = 0;
    comptime var index = 0;
    inline while (index < tup.len) : (index += 1) {
        sum += tup[index];
    }
    expect(sum == 1235 + 4566);
}
```

--------------------------------

TITLE: Zig C-ABI Compatible Enum Export
DESCRIPTION: Illustrates how to declare an enum compatible with the C Application Binary Interface (ABI) using `extern enum`. This is necessary for exporting functions that use enums to C.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: zig
CODE:
```
const Foo = enum { A, B, C };
export fn entry(foo: Foo) void { }

    $ zig build-obj test.zig
    /home/andy/dev/zig/docgen_tmp/test.zig:2:22: error: parameter of type 'Foo' not allowed in function with calling convention 'ccc'
    export fn entry(foo: Foo) void { 
                         ^
    
    
```

LANGUAGE: zig
CODE:
```
const Foo = extern enum { A, B, C };
export fn entry(foo: Foo) void { }

    $ zig build-obj test.zig
```

--------------------------------

TITLE: Zig: Inline Switch Prongs for Comptime Analysis
DESCRIPTION: Demonstrates using inline switch prongs in Zig to analyze struct fields for optionality at compile time. It shows how `isFieldOptional` is unrolled for specific indices and tests its behavior with different field types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;

fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T)."struct".fields;
    return switch (field_index) {
        // This prong is analyzed twice with `idx` being a
        // comptime-known value each time.
        inline 0, 1 => |idx| @typeInfo(fields[idx].type) == .optional,
        else => return error.IndexOutOfBounds,
    };
}

const Struct1 = struct { a: u32, b: ?u32 };

test "using @typeInfo with runtime values" {
    var index: usize = 0;
    try expect(!try isFieldOptional(Struct1, index));
    index += 1;
    try expect(try isFieldOptional(Struct1, index));
    index += 1;
    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent
// of this function:
fn isFieldOptionalUnrolled(field_index: usize) !bool {
    return switch (field_index) {
        0 => false,
        1 => true,
        else => return error.IndexOutOfBounds,
    };
}
```

--------------------------------

TITLE: Zig: Inline Switch Prongs for Comptime Analysis
DESCRIPTION: Demonstrates using inline switch prongs in Zig to analyze struct fields for optionality at compile time. It shows how `isFieldOptional` is unrolled for specific indices and tests its behavior with different field types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;

fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T)."struct".fields;
    return switch (field_index) {
        // This prong is analyzed twice with `idx` being a
        // comptime-known value each time.
        inline 0, 1 => |idx| @typeInfo(fields[idx].type) == .optional,
        else => return error.IndexOutOfBounds,
    };
}

const Struct1 = struct { a: u32, b: ?u32 };

test "using @typeInfo with runtime values" {
    var index: usize = 0;
    try expect(!try isFieldOptional(Struct1, index));
    index += 1;
    try expect(try isFieldOptional(Struct1, index));
    index += 1;
    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent
// of this function:
fn isFieldOptionalUnrolled(field_index: usize) !bool {
    return switch (field_index) {
        0 => false,
        1 => true,
        else => return error.IndexOutOfBounds,
    };
}
```

--------------------------------

TITLE: Improve BufferedInputStream ReadByte Performance
DESCRIPTION: The `std.io.BufferedInStream.readByte` function has been optimized, resulting in a significant performance improvement of approximately 75%. This enhancement is part of ongoing efforts to boost the efficiency of core I/O operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.io.BufferedInStream.readByte
```

--------------------------------

TITLE: Zig Target: wasm64-wasi
DESCRIPTION: This entry indicates support for the wasm64 architecture with WASI (WebAssembly System Interface). The specific icons suggest it's a primary target with build and test support.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.15.1/release-notes.html

LANGUAGE: text
CODE:
```
wasm64-wasi
```

--------------------------------

TITLE: Zig @alignOf
DESCRIPTION: Returns the alignment requirement for a type according to the C ABI. This is useful for ensuring proper memory alignment, especially when interfacing with C code. The result is a compile-time constant.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
comptime T: type) comptime_int

This function returns the number of bytes that this type should be aligned to for the current target to match the C ABI. When the child type of a pointer has this alignment, the alignment can be omitted from the type.

    const expect = @import("std").debug.assert;
    comptime {
        assert(*u32 == *align(@alignOf(u32)) u32);
    }

The result is a target-specific compile time constant. It is guaranteed to be less than or equal to [@sizeOf(T)](#sizeOf).
```

--------------------------------

TITLE: Zig Build System: Global Lock for Inherited Stdio
DESCRIPTION: This explains a change in the Zig build system's `Step.Run` functionality. When `stdio` is set to "inherit", a global lock is now obtained to prevent concurrent execution of steps that share standard input/output, ensuring safer process management.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.13.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example of configuring a Run step to inherit stdio:
// var run_step = b.addRunArtifact(exe);
// run_step.stdio = .{
//     .inherit = true,
// };
// run_step.expectStdErr(); // Example of expecting output

// When stdio is set to inherit, the build system now:
// - Considers the step to have side-effects.
// - Always executes the step.
// - Obtains a global lock to prevent other steps from running concurrently.
// - Fails the step if the subprocess crashes or returns a non-zero exit code.

```

--------------------------------

TITLE: Zig Struct Declaration
DESCRIPTION: Defines two Zig structs: `Point` with default alignment and `Point2` as a `packed struct` for specific byte ordering, suitable for interfacing with external systems like OpenGL.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.1/index.html

LANGUAGE: Zig
CODE:
```
// Declare a struct.
// Zig gives no guarantees about the order of fields and whether or
// not there will be padding.
const Point = struct {
    x: f32,
    y: f32,
};

// Maybe we want to pass it to OpenGL so we want to be particular about
// how the bytes are arranged.
const Point2 = packed struct {
    x: f32,
    y: f32,
};


// Declare an instance of a struct.
const p = Point {

```

--------------------------------

TITLE: Zig @alignOf
DESCRIPTION: Returns the alignment requirement for a type according to the C ABI. This is useful for ensuring proper memory alignment, especially when interfacing with C code. The result is a compile-time constant.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: zig
CODE:
```
comptime T: type) comptime_int

This function returns the number of bytes that this type should be aligned to for the current target to match the C ABI. When the child type of a pointer has this alignment, the alignment can be omitted from the type.

    const expect = @import("std").debug.assert;
    comptime {
        assert(*u32 == *align(@alignOf(u32)) u32);
    }

The result is a target-specific compile time constant. It is guaranteed to be less than or equal to [@sizeOf(T)](#sizeOf).
```

--------------------------------

TITLE: Remove Verbose AST and Tokenize Flags in Zig CLI
DESCRIPTION: Removes the `--verbose-ast` and `--verbose-tokenize` flags from the Zig command-line interface. These flags were likely for debugging and are no longer supported.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
CLI: remove --verbose-ast and --verbose-tokenize ([#9034](https://github.com/ziglang/zig/issues/9034)).
```

--------------------------------

TITLE: Zig: Inline Switch Prongs for Comptime Field Analysis
DESCRIPTION: Demonstrates using Zig's `inline` keyword within a switch statement to analyze struct fields at compile time. The `isFieldOptional` function checks if a field is optional, with the prong being evaluated twice for comptime values. Includes a test case and an unrolled equivalent function.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;

fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T)."struct".fields;
    return switch (field_index) {
        // This prong is analyzed twice with `idx` being a
        // comptime-known value each time.
        inline 0, 1 => |idx| @typeInfo(fields[idx].type) == .optional,
        else => return error.IndexOutOfBounds,
    };
}

const Struct1 = struct { a: u32, b: ?u32 };

test "using @typeInfo with runtime values" {
    var index: usize = 0;
    try expect(!try isFieldOptional(Struct1, index));
    index += 1;
    try expect(try isFieldOptional(Struct1, index));
    index += 1;
    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent
// of this function:
fn isFieldOptionalUnrolled(field_index: usize) !bool {
    return switch (field_index) {
        0 => false,
        1 => true,
        else => return error.IndexOutOfBounds,
    };
}
```

--------------------------------

TITLE: UEFI Support Enhancements in Zig
DESCRIPTION: This snippet highlights improvements made to UEFI support in Zig, including checks for UEFI in io.StreamSource, implementation of std.time.sleep for UEFI, and fixes for alignment errors in the UEFI FileInfo protocol. It also mentions a fix for a shift in the pool allocator related to UEFI.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
io.StreamSource
std.time.sleep
std.os.uefi.FileInfo
```

--------------------------------

TITLE: Zig Self-Hosted CLI Revision
DESCRIPTION: Revises the command-line interface (CLI) of the self-hosted Zig compiler. This may include changes to command structure, options, or output formatting for improved usability.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Shell
CODE:
```
# Example self-hosted compiler command (conceptual)
zig build --output zig-out/program
```

--------------------------------

TITLE: Zig: io.FindByteOutStream removed, use io.FindByteWriter
DESCRIPTION: The `io.FindByteOutStream` type is removed. Use `io.FindByteWriter` for finding bytes within a stream.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
io.FindByteOutStream
```

LANGUAGE: Zig
CODE:
```
io.FindByteWriter
```

--------------------------------

TITLE: Zig Target: wasm32-wasi
DESCRIPTION: This entry indicates support for the wasm32 architecture with WASI (WebAssembly System Interface) on Linux. The specific icons suggest it's a primary target with build and test support.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.15.1/release-notes.html

LANGUAGE: text
CODE:
```
wasm32-wasi
```

--------------------------------

TITLE: Zig Concurrency Updates
DESCRIPTION: Zig 0.11 includes fixes for condition variable broadcast in FutexImpl and corrects the alignment type for `std.Thread.Futex.PosixImpl.Address.from`. Additionally, `std.Thread.Id` has been made smaller where possible.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
// Concurrency fixes are applied to the relevant std.Thread and Futex implementations.
// Example of a potential fix related to FutexImpl:
// const FutexImpl = std.Thread.Futex.Impl;
// FutexImpl.broadcast(cond_var, count);
```

--------------------------------

TITLE: Zig: Add sendmsg
DESCRIPTION: Adds the `sendmsg` system call to the operating system interface. This function allows for more advanced control over sending data over sockets, including sending multiple data buffers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
add sendmsg
```

--------------------------------

TITLE: Zig HashMap getOrPut Update (0.8.0)
DESCRIPTION: Demonstrates the modification to Zig's HashMap.getOrPut function's return type, where the entry value is now accessed via a pointer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
// old
const result = try map.getOrPut(key);
if (!result.found_existing) {
    result.entry.value = new_value;
}

// new
const result = try map.getOrPut(key);
if (!result.found_existing) {
    result.value_ptr.* = new_value;
}

```

--------------------------------

TITLE: Zig Opaque Type Declaration and C Interoperability
DESCRIPTION: Shows how to declare opaque types in Zig for interfacing with C code where struct details are unknown. Opaque types have non-zero size and alignment and can contain declarations similar to structs. The example highlights a type mismatch error when passing an incorrect opaque pointer to an external function.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig: io.findByteOutStream removed, use io.findByteWriter
DESCRIPTION: The `io.findByteOutStream` function is removed. Use `io.findByteWriter` for finding bytes within a stream.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
io.findByteOutStream
```

LANGUAGE: Zig
CODE:
```
io.findByteWriter
```

--------------------------------

TITLE: Zig: Integer-Pointer Conversion
DESCRIPTION: Demonstrates the use of `@intToPtr` to convert an integer address into a pointer and `@ptrToInt` to convert a pointer back to an integer (usize). This is useful for low-level memory manipulation or when interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "@ptrToInt and @intToPtr" {
    const ptr = @intToPtr(*i32, 0xdeadbee0);
    const addr = @ptrToInt(ptr);
    try expect(@TypeOf(addr) == usize);
    try expect(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Zig extern Keyword
DESCRIPTION: The `extern` keyword in Zig is used to declare functions or variables that will be resolved at link time, either statically or dynamically at runtime. It's essential for interfacing with external libraries.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: Zig
CODE:
```
extern fn printf(format: [*c]const u8, ...) callconv(.C) i32;

fn printMessage() void {
    printf("Hello from Zig!\n", .{
        @tagName(u8),
    });
}

```

--------------------------------

TITLE: Add Int Writing and SkipBytes to Zig Streams
DESCRIPTION: Adds integer writing functions to `std.io.OutStream` and a `skipBytes` function to `std.io.InStream` for more versatile stream operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
int writing functions OutStream skipBytes function InStream
```

--------------------------------

TITLE: Zig: Integer-Pointer Conversion
DESCRIPTION: Demonstrates the use of `@intToPtr` to convert an integer address into a pointer and `@ptrToInt` to convert a pointer back to an integer (usize). This is useful for low-level memory manipulation or when interfacing with C code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "@ptrToInt and @intToPtr" {
    const ptr = @intToPtr(*i32, 0xdeadbee0);
    const addr = @ptrToInt(ptr);
    try expect(@TypeOf(addr) == usize);
    try expect(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Use `zig cc` with stdin
DESCRIPTION: The `zig cc` command now supports reading input from stdin, enabling its use with tools like meson.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: bash
CODE:
```
# Pipe C code to zig cc for compilation
echo "int main() { return 0; }" | zig cc -o main.o -c -
```

--------------------------------

TITLE: Zig: External Declarations with extern
DESCRIPTION: The `extern` keyword in Zig declares functions or variables that will be resolved at link time, either statically or dynamically at runtime. This is used to interface with code written in other languages or libraries.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
extern fn puts(s: [*c]const u8) c_int;

pub fn greet() void {
    puts("Hello from Zig!\n");
}
```

--------------------------------

TITLE: Zig Struct Declaration
DESCRIPTION: Defines two Zig structs: `Point` with default alignment and `Point2` as a `packed struct` for specific byte ordering, suitable for interfacing with external systems like OpenGL.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.0/index.html

LANGUAGE: Zig
CODE:
```
// Declare a struct.
// Zig gives no guarantees about the order of fields and whether or
// not there will be padding.
const Point = struct {
    x: f32,
    y: f32,
};

// Maybe we want to pass it to OpenGL so we want to be particular about
// how the bytes are arranged.
const Point2 = packed struct {
    x: f32,
    y: f32,
};


// Declare an instance of a struct.
const p = Point {

```

--------------------------------

TITLE: Zig: elf expose parsing decoupled from fs.File
DESCRIPTION: Decouples the ELF file parsing logic from the `fs.File` type. This allows ELF files to be parsed from memory buffers or other sources, not just file handles.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
elf: expose parsing decoupled from fs.File
```

--------------------------------

TITLE: Zig: std.os.Stat structs gain time methods
DESCRIPTION: The `std.os.Stat` structs now include methods to abstract platform differences for accessing file metadata like modification time (`mtime`), change time (`ctime`), and access time (`atime`).

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.os.Stat
```

--------------------------------

TITLE: Zig: External Declarations with extern
DESCRIPTION: The `extern` keyword in Zig declares functions or variables that will be resolved at link time, either statically or dynamically at runtime. This is used to interface with code written in other languages or libraries.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
extern fn puts(s: [*c]const u8) c_int;

pub fn greet() void {
    puts("Hello from Zig!\n");
}
```

--------------------------------

TITLE: Opaque Types in Zig
DESCRIPTION: Explains the use of `opaque {}` to declare types with unknown size and alignment, primarily for type safety when interfacing with C code. It includes an example of declaring and using opaque types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig HTTP Server Initialization (Old vs New)
DESCRIPTION: Compares the old and new ways of initializing an HTTP server in Zig, highlighting the shift from depending on std.net to Io.Reader and Io.Writer, and the removal of arbitrary limitations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.15.1/release-notes.html

LANGUAGE: Zig
CODE:
```
var read_buffer: [8000]u8 = undefined;
var server = std.http.Server.init(connection, &read_buffer);
```

LANGUAGE: Zig
CODE:
```
var recv_buffer: [4000]u8 = undefined;
var send_buffer: [4000]u8 = undefined;
var conn_reader = connection.stream.reader(&recv_buffer);
var conn_writer = connection.stream.writer(&send_buffer);
var server = std.http.Server.init(conn_reader.interface(), &conn_writer.interface);
```

--------------------------------

TITLE: Zig CLI Help Output Improvement
DESCRIPTION: Enhances the help output of the Zig command-line interface (CLI). This makes it easier for users to understand and utilize the various compiler commands and options.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Shell
CODE:
```
zig --help
```

--------------------------------

TITLE: Opaque Types in Zig
DESCRIPTION: Explains the use of `opaque {}` to declare types with unknown size and alignment, primarily for type safety when interfacing with C code. It includes an example of declaring and using opaque types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Fix WASI os.isatty on type mismatch
DESCRIPTION: Corrects the behavior of os.isatty in the WASI implementation when a type mismatch occurs, referencing issue #13813.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.1/release-notes.html

LANGUAGE: Zig
CODE:
```
wasi: fixes os.isatty on type mismatch (#13813)
```

--------------------------------

TITLE: Zig BufferOutStream Import Fix
DESCRIPTION: Corrects an import error for `BufferOutStream`, clarifying that it is defined within `std.io.zig`. This ensures the type is correctly referenced and available for use.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const BufferOutStream = std.io.BufferOutStream;
```

--------------------------------

TITLE: Zig Standard Library: Miscellaneous Updates
DESCRIPTION: This section covers various other improvements in the Zig standard library. It includes adding missing termios types for c/linux.zig and os.zig, fixing readUntilDelimiter to only read if the buffer is not full, avoiding duplicate TLS startup symbols, and correcting rounding in parse_hex_float.zig. Progress reporting API has been made infallible, and fixes for suffix printing and data races in std.Progress.maybeRefresh() are included. Additionally, ELF and COFF machine types have been added to Target.CPU.Arch conversions, sigaction double panic is fixed, sem_open and sem_close are added, SIMD utility functions are available, and unicode.replacement_character is defined.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

// Example: Using sem_open
// const sem = try std.posix.sem_open("my_semaphore", std.posix.O.CREAT, 0o644, 1);
// defer std.posix.sem_close(sem);

// Example: Progress line handling
// var progress = std.Progress.init(std.io.getStdOut().writer());
// progress.maybeRefresh(); // Only prints if timer is ready or explicitly called

// Example: Unicode replacement character
const replacement = std.unicode.replacement_character;

```

--------------------------------

TITLE: Use 32-bit fchown on 32-bit Linux
DESCRIPTION: Ensures that the `fchown` syscall uses the 32-bit uid/gid variant when targeting 32-bit Linux platforms. This maintains compatibility with older or specific 32-bit system interfaces.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.1/release-notes.html

LANGUAGE: Zig
CODE:
```
fchown: use the 32-bit uid/gid variant of the syscall on 32-bit linux targets.
```

--------------------------------

TITLE: Zig: Using Primitives as Struct Field Names
DESCRIPTION: Shows how Zig allows primitive type names like `i32`, `true`, `false`, `undefined`, and `null` to be used as struct field names. The `@""` syntax is required for disambiguation when referencing these fields.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const Foo = struct {
    true: i32,
    false: i32,
    undefined: i32,
    null: i32,
};
```

--------------------------------

TITLE: Zig std.io.NullOutStream and CountingOutStream
DESCRIPTION: Added std.io.NullOutStream and std.io.CountingOutStream for efficient handling of output streams. NullOutStream discards all written data, while CountingOutStream counts the bytes written.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.io.NullOutStream
```

LANGUAGE: zig
CODE:
```
std.io.CountingOutStream
```

--------------------------------

TITLE: Zig: Address-of Operator with Result Location Semantics
DESCRIPTION: This Zig code illustrates the forwarding of result types through the address-of operator ('&'). It shows how anonymous initializations and casting builtins work correctly with the address-of operator in the presence of result types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const S = struct {
    x: u32,
};
const int: u64 = 123;
const val: *const S = &.{ .x = @intCast(int) };

comptime {
    _ = val;
}
```

--------------------------------

TITLE: Zig: External Declarations
DESCRIPTION: The `extern` keyword in Zig is used to declare functions or variables that will be resolved at link time, either statically or dynamically at runtime. This is crucial for interfacing with C libraries or other pre-compiled code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
extern fn puts(s: [*]const u8) c_int;

pub fn main() void {
    puts("Hello from Zig!");
}
```

--------------------------------

TITLE: Networking Enhancements in Zig
DESCRIPTION: Zig 0.10.0 introduces HTTP method and status definitions, improves error handling for network connections, and adds support for `tcdrain` on Linux. The `std.os` module now handles `error.UnreachableAddress` in `send()`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.http.Method
```

LANGUAGE: Zig
CODE:
```
std.http.Status
```

LANGUAGE: Zig
CODE:
```
std.net.getAddressList
```

LANGUAGE: Zig
CODE:
```
std.os.tcdrain
```

LANGUAGE: Zig
CODE:
```
std.os.send
```

--------------------------------

TITLE: Zig: Organize concurrency primitives and add RwLock
DESCRIPTION: Organizes the standard library's concurrency primitives and adds a `RwLock` (Read-Write Lock). This provides better structure and a new synchronization tool for concurrent programming.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Organize std lib concurrency primitives and add RwLock
```

--------------------------------

TITLE: Zig: External Declarations
DESCRIPTION: The `extern` keyword in Zig is used to declare functions or variables that will be resolved at link time, either statically or dynamically at runtime. This is crucial for interfacing with C libraries or other pre-compiled code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
extern fn puts(s: [*]const u8) c_int;

pub fn main() void {
    puts("Hello from Zig!");
}
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to use Zig's standard library to read and print command-line arguments when compiled for WASI. It utilizes `std.process.argsAlloc` for argument retrieval and `std.debug.print` for output.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Zig Deflate Compressor API Comparison
DESCRIPTION: Compares the old and new API for the deflate stream functionality in Zig. The new API offers improved performance and a more modern interface for compression and decompression tasks.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Old API:

{#syntax#}inflateStream(reader: anytype, window_slice: []u8){#endsyntax#}

New API:

{#syntax#}decompressor(allocator: mem.Allocator, reader: anytype, dictionary: ?[]const u8)
compressor(allocator: mem.Allocator, writer: anytype, options: CompressorOptions){#endsyntax#}
```

--------------------------------

TITLE: Zig Progress Protocol: Terminal Refresh Thread
DESCRIPTION: This describes the separate thread responsible for periodically refreshing the terminal display in the Zig Progress Protocol. It details the process of serializing data, handling child process communication via pipes, and updating the terminal.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.13.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Conceptual representation of the terminal refresh thread's logic:

// This thread periodically wakes up on a timer.
// It iterates over a preallocated parents array.
// It serializes data atomically.
// If a node is linked to a child process via a pipe:
//   - It reads data from the pipe.
//   - Merges this data into the serialized buffer.
// After serialization, it computes tree structures and writes to the terminal.
// Handles SIGWINCH for terminal resize events.

```

--------------------------------

TITLE: Zig Implicit Cast: *T and [*]T to ?*c_void
DESCRIPTION: Allows implicit casting from pointers to single elements (`*T`) or slices (`[*]T`) to an optional pointer to `c_void` (`?*c_void`). This is useful for interfacing with C APIs that expect generic void pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
var x: u32 = 10;
const void_ptr: ?*c_void = &x;

const arr: [5]u8 = .{ 1, 2, 3, 4, 5 };
const slice_void_ptr: ?*c_void = &arr;
```

--------------------------------

TITLE: Zig extern Keyword
DESCRIPTION: The `extern` keyword in Zig is used to declare functions or variables that will be resolved at link time, either statically or dynamically at runtime. It's essential for interfacing with external libraries.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: Zig
CODE:
```
extern fn printf(format: [*c]const u8, ...) callconv(.C) i32;

fn printMessage() void {
    printf("Hello from Zig!\n", .{
        @tagName(u8),
    });
}

```

--------------------------------

TITLE: Zig Formatting Structs via Reflection
DESCRIPTION: Updates `std.fmt.format` to handle non-pointer struct, union, and enum types, including support for printing structs using reflection.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.fmt.format
```

--------------------------------

TITLE: Zig Concurrent Async I/O Example
DESCRIPTION: Demonstrates concurrent execution of asynchronous tasks using Zig's evented I/O mode. It creates two files, 'a.txt' and 'b.txt', writing 'A\n' and 'B\n' respectively, showcasing parallel file operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub const io_mode = .evented;

pub fn main() anyerror!void {
    var a_frame = async doA();
    var b_frame = async doB();

    try await a_frame;
    try await b_frame;
}

fn doA() !void {
    const file = try std.fs.cwd().createFile("a.txt", .{}) ;
    defer file.close();
    try file.writeAll("A\n");
}

fn doB() !void {
    const file = try std.fs.cwd().createFile("b.txt", .{}) ;
    defer file.close();
    try file.writeAll("B\n");
}
```

--------------------------------

TITLE: Zig Implicit Cast: *T and [*]T to ?*c_void
DESCRIPTION: Enables implicit casting from pointers to single elements (`*T`) or slices (`[*]T`) to an optional pointer to `c_void` (`?*c_void`). This is useful for interfacing with C APIs that expect generic void pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
var x: u32 = 10;
const void_ptr: ?*c_void = &x;

const arr: [5]u8 = .{ 1, 2, 3, 4, 5 };
const slice_void_ptr: ?*c_void = &arr;
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to use Zig's standard library to read command line arguments within a WASI environment. It allocates memory for arguments and prints them with their index.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args, 0..) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Zig Built-in Function: @atomicStore
DESCRIPTION: The `@atomicStore` builtin function performs an atomic store operation to a memory location. It guarantees that the write operation is indivisible and visible across threads.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Int(u32) = undefined;

    @atomicStore(&atomic_var, 456, .SeqCst);

    const value = std.atomic.load(&atomic_var, .SeqCst);
    std.debug.print("Stored atomic value: {d}\\n", .{
        value,
    });
}
```

--------------------------------

TITLE: Zig Target Triple Command-Line Examples
DESCRIPTION: Illustrates various ways to specify target architectures, CPU features, and OS versions using Zig's command-line interface. This includes setting baseline features, adding/removing specific features, and targeting different architectures like RISC-V and ARM.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Shell
CODE:
```
# Native architecture, OS, and ABI, but baseline CPU features:
-target native -mcpu=baseline
```

LANGUAGE: Shell
CODE:
```
# RISC-V 64-bit architecture, OS linux, default ABI, native CPU plus the rdpid feature, minus the sse3 feature:
-target riscv64-linux -mcpu=native+rdpid-sse3
```

LANGUAGE: Shell
CODE:
```
# Target the RPi Zero:
-target arm-linux-musleabi -mcpu=arm1176jzf_s
```

LANGUAGE: Shell
CODE:
```
# Minimum Windows version: XP
# Maximum Windows version: 10
-target x86_64-windows.xp...win10-msvc
```

LANGUAGE: Shell
CODE:
```
# Minimum Windows version: 7
# Maximum Windows version: latest
-target x86_64-windows.win7-msvc
```

LANGUAGE: Shell
CODE:
```
# Linux example with OS version range:
-target aarch64-linux.3.16...5.3.1-musl
```

LANGUAGE: Shell
CODE:
```
# Specifying glibc version:
-target mipsel-linux.4.10-gnu.2.1
```

LANGUAGE: Shell
CODE:
```
# Simplified target without sub-architecture (e.g., v7a):
-target arm-linux-gnu
```

LANGUAGE: Shell
CODE:
```
# Targeting a different sub-architecture (e.g., v6kz) using -mcpu:
-target arm-linux-gnu -mcpu=generic+v6kz
```

--------------------------------

TITLE: Zig: Improve std.elf.Elf open functions
DESCRIPTION: The `std.elf.Elf` open functions have been improved to directly return the `Elf` struct instead of requiring a pointer to be filled. This change is noted in issue #2998.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.elf.Elf
```

--------------------------------

TITLE: Zig Opaque Types for C Interoperability
DESCRIPTION: Illustrates the use of `opaque {}` to declare types with unknown size and alignment, commonly used for type safety when interfacing with C code. The example shows how opaque types can be used in function signatures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to use Zig's standard library to read command line arguments within a WASI environment. It allocates memory for arguments and prints them with their index.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args, 0..) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Zig: Fix type error for u8 in writeIntSlice
DESCRIPTION: Corrects a type error that occurred when using `u8` with the `writeIntSlice` function. This ensures proper handling of unsigned 8-bit integers in slice writing operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
writeIntSlice
```

--------------------------------

TITLE: Zig Aligned Struct Fields
DESCRIPTION: Shows how to specify alignment for individual struct fields using the `align(N)` keyword. This provides fine-grained control over memory layout, which is essential for performance-critical code or interfacing with hardware.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expectEqual = std.testing.expectEqual;

test "aligned struct fields" {
    const S = struct {
        a: u32 align(2),
        b: u32 align(64),
    };
    var foo = S{ .a = 1, .b = 2 };

    try expectEqual(64, @alignOf(S));
    try expectEqual(*align(2) u32, @TypeOf(&foo.a));
    try expectEqual(*align(64) u32, @TypeOf(&foo.b));
}
```

--------------------------------

TITLE: Zig @OpaqueType Function
DESCRIPTION: Creates a new type with an unknown size and alignment. This is primarily used for type safety when interfacing with C code where struct details are not exposed, preventing accidental misuse of incompatible opaque types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.1/index.html

LANGUAGE: zig
CODE:
```
const Derp = @OpaqueType();
const Wat = @OpaqueType();

extern fn bar(d: &Derp);
export fn foo(w: &Wat) {
    bar(w);
}
```

--------------------------------

TITLE: Fix Windows x86_64 i128 ABI Issue (Zig)
DESCRIPTION: Resolves an Application Binary Interface (ABI) issue specific to the i128 integer type on the x86_64 Windows platform. This ensures correct function calling conventions and data passing.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
// No specific code snippet provided, but the fix addresses the Windows x86_64 i128 ABI issue.
```

--------------------------------

TITLE: Zig Peer Type Resolution: Array and Slice Compatibility
DESCRIPTION: Illustrates peer type resolution with arrays and slices, showing how they can be implicitly cast to a const slice. Includes tests for both runtime and compile-time evaluation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;
const mem = std.mem;

test "peer resolve arrays of different size to const slice" {
    assert(mem.eql(u8, boolToStr(true), "true"));
    assert(mem.eql(u8, boolToStr(false), "false"));
    comptime assert(mem.eql(u8, boolToStr(true), "true"));
    comptime assert(mem.eql(u8, boolToStr(false), "false"));
}
fn boolToStr(b: bool) []const u8 {
    return if (b) "true" else "false";
}
```

--------------------------------

TITLE: Zig std.os.read implementation
DESCRIPTION: This Zig code snippet demonstrates the implementation of the `std.os.read` function. It handles reading from file descriptors, with specific logic for Windows, WASI (when not linking libc), and a general system call fallback. It also includes error handling for various POSIX error codes and integrates with an event loop for non-blocking operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: zig
CODE:
```
/// Returns the number of bytes that were read, which can be less than /// buf.len. If 0 bytes were read, that means EOF. /// If the application has a global event loop enabled, EAGAIN is handled /// via the event loop. Otherwise EAGAIN results in error.WouldBlock. pub fn read(fd: fd_t, buf: []u8) ReadError!usize {
    if (builtin.os == .windows) {
        return windows.ReadFile(fd, buf);
    }
    if (builtin.os == .wasi and !builtin.link_libc) {
        const iovs = [_]iovec{iovec{ .iov_base = buf.ptr, .iov_len = buf.len, }};
        var nread: usize = undefined;
        switch (wasi.fd_read(fd, &iovs, iovs.len, &nread)) {
            0 => return nread,
            else => |err| return unexpectedErrno(err),
        }
    }
    while (true) {
        const rc = system.read(fd, buf.ptr, buf.len);
        switch (errno(rc)) {
            0 => return @intCast(usize, rc),
            EINTR => continue,
            EINVAL => unreachable,
            EFAULT => unreachable,
            EAGAIN => if (std.event.Loop.instance) |loop| {
                loop.waitUntilFdReadable(fd);
                continue;
            } else {
                return error.WouldBlock;
            },
            EBADF => unreachable, // Always a race condition.
            EIO => return error.InputOutput,
            EISDIR => return error.IsDir,
            ENOBUFS => return error.SystemResources,
            ENOMEM => return error.SystemResources,
            ECONNRESET => return error.ConnectionResetByPeer,
            else => |err| return unexpectedErrno(err),
        }
    }
    return index;
}
```

--------------------------------

TITLE: Zig: `Allocator.reallocBytes` Public Access
DESCRIPTION: Makes `Allocator.reallocBytes` public, which is beneficial for scenarios requiring custom alignment, such as interfacing with C code that uses custom allocation callbacks. This provides greater flexibility in memory management.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
Publicize Allocator.reallocBytes. This is useful when dealing with runtime-known alignments, eg. interfacing with C code that accepts custom allocation callbacks ([#9394](https://github.com/ziglang/zig/issues/9394)).
```

--------------------------------

TITLE: Zig ZON Serialization Functions
DESCRIPTION: Offers runtime capabilities for serializing Zig data into ZON format. Functions include serialize, serializeMaxDepth, serializeArbitraryDepth, and serializer. The serializer provides a fine-grained interface for piece-by-piece serialization.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.zon.stringify.serialize
std.zon.stringify.serializeMaxDepth
std.zon.stringify.serializeArbitraryDepth
std.zon.stringify.serializer
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to use Zig's standard library to read command line arguments within a WASI environment. It allocates memory for arguments and prints them with their index.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args, 0..) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Fix Compiler-RT ABI for x86_64 Windows (Zig)
DESCRIPTION: Ensures correct Application Binary Interface (ABI) compatibility for the compiler runtime on the x86_64 Windows platform. This is crucial for interoperability with system libraries and other compiled code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
// No specific code snippet provided, but the fix relates to the compiler-rt ABI for x86_64 Windows.
```

--------------------------------

TITLE: Zig: Opaque type interaction with C
DESCRIPTION: Provides an example of using Zig's opaque types for type safety when interacting with C code. It defines opaque types and demonstrates a function call that requires casting.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig Opaque Types for C Interoperability
DESCRIPTION: Illustrates the use of `opaque {}` in Zig to declare types with unknown size and alignment, commonly used for type safety when interfacing with C code. It shows how opaque types can be used in function signatures and how type mismatches are handled.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig: Volatile Memory Access
DESCRIPTION: Explains and demonstrates the use of the `volatile` keyword in Zig for memory-mapped input/output (MMIO). It shows how to declare a volatile pointer and asserts its type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;

test "volatile" {
    const mmio_ptr = @intToPtr(*volatile u8, 0x12345678);
    assert(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig @alignOf
DESCRIPTION: Returns the required byte alignment for a type according to the C ABI. This is useful for ensuring correct memory alignment, especially when interfacing with C code or when manually managing memory. The result is a compile-time constant.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
    @alignOf(comptime T: type) comptime_int
```

LANGUAGE: zig
CODE:
```
    const assert = @import("std").debug.assert;
    comptime {
        assert(*u32 == *align(@alignOf(u32)) u32);
    }
```

--------------------------------

TITLE: Zig Standard Library: Linux Syscall Signatures and Features
DESCRIPTION: This snippet covers various updates to the Zig standard library related to Linux system calls and functionalities. It includes corrections for `os.rusage` linking with the C library, the addition of `shm_open` and `shm_unlink` in `std.c`, and fixes for `preadv`/`pwritev` on 64-bit platforms. It also mentions the addition of POSIX file locking support and fixes for `ucontext_t` and `getdents64` error handling.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example: Using fchown with 32-bit uid/gid on 32-bit Linux
try std.os.fchown(fd, uid_32, gid_32);

// Example: Using shm_open and shm_unlink
const shm_fd = try std.c.shm_open(c"my_shm", std.os.O.RDWR | std.os.O.CREAT, 0644);
try std.c.shm_unlink(c"my_shm");

// Example: POSIX file locking with fcntl
var flock: std.os.flock_t = undefined;
// ... populate flock struct ...
try std.os.fcntl(fd, std.os.FcntlCmd.SETLK, &flock);

// Example: Handling EINVAL from getdents64
var dir_entries: [1024]u8 = undefined;
const bytes_read = try std.fs.cwd().read(&dir_entries);
// ... process dir_entries, handle potential EINVAL ...

```

--------------------------------

TITLE: Zig @OpaqueType Function
DESCRIPTION: Creates a new type with an unknown size and alignment. This is primarily used for type safety when interfacing with C code where struct details are not exposed, preventing accidental misuse of incompatible opaque types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.0/index.html

LANGUAGE: zig
CODE:
```
const Derp = @OpaqueType();
const Wat = @OpaqueType();

extern fn bar(d: &Derp);
export fn foo(w: &Wat) {
    bar(w);
}
```

--------------------------------

TITLE: Fix asyncCall with Non-ABI-Aligned Arguments
DESCRIPTION: Addresses issues with `asyncCall` when passing non-ABI-aligned arguments. The code for calculating variable slot indices in the frame now matches structure layout calculations, preventing LLVM errors.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: zig
CODE:
```
const result = await asyncCall(myAsyncFn, non_aligned_arg);
```

--------------------------------

TITLE: Zig Sentinel-Terminated Pointer for C printf
DESCRIPTION: Shows how to use a sentinel-terminated pointer in Zig to interface with C functions like `printf`. The example defines `printf` using a `[*:0]const u8` type for the format string, which expects a null terminator. It also demonstrates a compilation error when passing a non-null-terminated string.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
    
    // This is also available as `std.c.printf`.
    pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;
    
    pub fn main() anyerror!void {
    _ = printf("Hello, world!\n"); // OK

    const msg = "Hello, world!\n";
    const non_null_terminated_msg: [msg.len]u8 = msg.*;
    _ = printf(&non_null_terminated_msg);
}
```

--------------------------------

TITLE: Zig @setAlignStack for Stack Alignment
DESCRIPTION: The @setAlignStack builtin ensures that a function's stack frame has at least the specified byte alignment. This can be important for performance-critical code or when interfacing with external libraries that have specific stack alignment requirements.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
@setAlignStack(comptime alignment: u29)
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to use Zig's standard library to read and print command line arguments when compiling for WASI. It utilizes `std.process.argsAlloc` to get the arguments and `std.debug.print` for output. The code requires a WASI-compatible runtime like `wasmtime`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Zig WebAssembly Support
DESCRIPTION: This section explains how Zig can be used to compile code for WebAssembly, covering both freestanding WebAssembly targets and those utilizing the WebAssembly System Interface (WASI). This is key for cross-platform development and web-based applications.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
Freestanding
WASI
```

--------------------------------

TITLE: Zig Hello World to Stdout
DESCRIPTION: Demonstrates the basic 'Hello, world!' program in Zig, printing output to standard output using the `std.io.getStdOut().outStream().print` function. It shows how to import the standard library and handle potential errors during output.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    const stdout = std.io.getStdOut().outStream();
    try stdout.print("Hello, {}!\n", .{"world});
}
```

--------------------------------

TITLE: Zig Async Test Skip Example
DESCRIPTION: Illustrates skipping an asynchronous Zig test. The test runner skips tests that involve suspend points in blocking IO mode. The example includes an async function and a test that awaits its result.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

test "async skip test" {
    var frame = async func();
    const result = await frame;
    try std.testing.expect(result == 1);
}

fn func() i32 {
    suspend {
        resume @frame();
    }
    return 1;
}
```

--------------------------------

TITLE: Zig atomic load operation
DESCRIPTION: Demonstrates the `@atomicLoad` built-in function for performing atomic read operations in Zig.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
var atomic_var: atomic(i32) = undefined;
const value = @atomicLoad(&atomic_var, .SeqCst);
```

--------------------------------

TITLE: Zig @setAlignStack Builtin
DESCRIPTION: The @setAlignStack builtin ensures that a function's stack alignment meets a specified minimum byte requirement. This can be important for performance-critical code or when interfacing with external libraries that have specific stack alignment expectations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
comptime {
    @setAlignStack(comptime alignment: u29) void
}
```

--------------------------------

TITLE: Zig @alignOf: Get Type Alignment
DESCRIPTION: The @alignOf function returns the number of bytes required for a type's alignment according to the C ABI for the current target. This is useful for ensuring correct memory alignment, especially when interfacing with C code. The result is a compile-time constant.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: zig
CODE:
```
comptime_int @alignOf(comptime T: type) comptime_int
```

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;
comptime {
    assert(*u32 == *align(@alignOf(u32)) u32);
}
```

--------------------------------

TITLE: Zig @setAlignStack Builtin
DESCRIPTION: The @setAlignStack builtin ensures that a function's stack alignment meets a specified minimum byte requirement. This can be important for performance-critical code or when interfacing with external libraries that have specific stack alignment expectations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
comptime {
    @setAlignStack(comptime alignment: u29) void
}
```

--------------------------------

TITLE: Zig Case Study: print function
DESCRIPTION: Demonstrates the usage of the 'print' function in Zig, a common operation for outputting formatted strings to the console. This example serves as a practical introduction to I/O operations in Zig.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() {
    std.debug.print("Hello, {}!\n", .{"world"});
}
```

--------------------------------

TITLE: Zig Synchronizing External Operations with fetchAdd
DESCRIPTION: Illustrates simulating fences for external operations in Zig using `fetchAdd(0, .seq_cst)`. This is a workaround when direct control over the ordering of external function calls is not possible.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: zig
CODE:
```
fetchAdd(0, .seq_cst)
```

--------------------------------

TITLE: Zig @setAlignStack Builtin
DESCRIPTION: The @setAlignStack builtin ensures that a function's stack alignment meets a specified minimum byte requirement. This can be important for performance-critical code or when interfacing with external libraries that have specific stack alignment expectations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
comptime {
    @setAlignStack(comptime alignment: u29) void
}
```

--------------------------------

TITLE: Zig Case Study: print function
DESCRIPTION: Demonstrates the usage of the 'print' function in Zig, a common operation for outputting formatted strings to the console. This example serves as a practical introduction to I/O operations in Zig.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() {
    std.debug.print("Hello, {}!\n", .{"world"});
}
```

--------------------------------

TITLE: WASI: Enable experimental WASI-threads support
DESCRIPTION: Zig now offers experimental support for WASI-threads, allowing multi-threaded applications when targeting WASI. This feature is based on phase 1 of the WASI specification and requires specific compiler flags and CPU features.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
-fno-single-threaded --shared-memory
```

--------------------------------

TITLE: Zig Crypto Keccak Permutation API
DESCRIPTION: Exposes the Keccak permutation with a public interface in `crypto.core.keccak`. `KeccakF` supports permutation sizes from 200 to 1600 bits and a configurable number of rounds, while `State` offers APIs for sponge constructions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.crypto.core.keccak.KeccakF
```

LANGUAGE: zig
CODE:
```
std.crypto.core.keccak.State
```

--------------------------------

TITLE: Build WebAssembly Executable with WASI (Zig)
DESCRIPTION: This Zig command compiles a Zig file into a WebAssembly executable that uses the WebAssembly System Interface (WASI). This allows the WASM module to interact with the host system, such as accessing command-line arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = &general_purpose_allocator.allocator;
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Zig Fully Anonymous Struct Type Inference
DESCRIPTION: Demonstrates type inference for anonymous structs where the type is not explicitly provided. The `dump` function accepts a variadic argument and asserts the types and values of its fields, showcasing flexible struct handling.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;

test "fully anonymous struct" {
    dump(.{
        .int = @as(u32, 1234),
        .float = @as(f64, 12.34),
        .b = true,
        .s = "hi",
    });
}

fn dump(args: var) void {
    assert(args.int == 1234);
    assert(args.float == 12.34);
    assert(args.b);
    assert(args.s[0] == 'h');
    assert(args.s[1] == 'i');
}
```

--------------------------------

TITLE: Zig: Linking Sections with linksection
DESCRIPTION: The `linksection` keyword in Zig allows developers to place code or data into specific sections of the final executable or library. This is often used for custom memory management or interfacing with specific linker scripts.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
@linkSection("my_data", .{
    .type = .data,
    .size = 1024,
}) align(16) var buffer: [1024]u8;

fn processBuffer() void {
    // Use the buffer located in the 'my_data' section
    buffer[0] = 1;
}
```

--------------------------------

TITLE: Improve ChildProcess Error Communication on Linux
DESCRIPTION: The `std.ChildProcess` on Linux now utilizes eventfds for communicating errors from child to parent processes, replacing the previous pipe-based mechanism. This change is expected to improve the robustness and efficiency of inter-process communication.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.ChildProcess
```

--------------------------------

TITLE: Zig Sentinel-Terminated Pointers for C printf
DESCRIPTION: Illustrates the use of sentinel-terminated pointers, specifically '[*:0]const u8', for interfacing with C functions like printf. The example shows how to correctly pass a null-terminated string to printf and highlights a common error when a non-terminated string is passed, leading to a compile-time error.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

// This is also available as `std.c.printf`.
pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;

pub fn main() anyerror!void {
    _ = printf("Hello, world!\n"); // OK

    const msg = "Hello, world!\n";
    const non_null_terminated_msg: [msg.len]u8 = msg.*;
    _ = printf(&non_null_terminated_msg);
}
```

--------------------------------

TITLE: Zig stdlib Random Improvements
DESCRIPTION: Zig's standard library has seen improvements in random number generation, including the addition of `std.rand.RomuTrio` and changes to the random interface. The `random` module now includes a `weightedIndex` function for more flexible random selection.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
// Example of using std.rand.RomuTrio (conceptual)
const RomuTrio = std.rand.RomuTrio;
var rng = RomuTrio.init(seed_value);
const random_number = rng.next();

// Example of weightedIndex (conceptual)
const weights = [_]u32{ 10, 20, 70 };
const index = std.rand.weightedIndex(rng, weights);

```

--------------------------------

TITLE: WASI: Fix IterableDir.nextWasi for large directories
DESCRIPTION: A bug in `IterableDir.nextWasi` for handling large directories on WASI has been resolved. This ensures that directory iteration functions correctly even when dealing with a significant number of entries.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.fs.Dir.iterate
```

--------------------------------

TITLE: Zig: Linking Sections with linksection
DESCRIPTION: The `linksection` keyword in Zig allows developers to place code or data into specific sections of the final executable or library. This is often used for custom memory management or interfacing with specific linker scripts.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
@linkSection("my_data", .{
    .type = .data,
    .size = 1024,
}) align(16) var buffer: [1024]u8;

fn processBuffer() void {
    // Use the buffer located in the 'my_data' section
    buffer[0] = 1;
}
```

--------------------------------

TITLE: Zig Keyword: callconv
DESCRIPTION: The `callconv` keyword in Zig is used within a function type declaration to specify the calling convention. This is crucial for interoperability, especially when interfacing with code written in different languages or using different ABI standards.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
const MyFuncType = fn(a: i32) i32; // Default calling convention
const MyCConvFuncType = fn(a: i32) i32 callconv(.C) i32;

```

--------------------------------

TITLE: Zig: Create Opaque Type
DESCRIPTION: Creates a new type with an unknown but non-zero size and alignment. This is useful for type safety when interfacing with C code that does not expose struct details. The example demonstrates creating opaque types and a type mismatch error.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: zig
CODE:
```
    @OpaqueType() type
```

LANGUAGE: zig
CODE:
```
const Derp = @OpaqueType();
const Wat = @OpaqueType();

extern fn bar(d: *Derp) void;
export fn foo(w: *Wat) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig Standard Library: Process Management Enhancements
DESCRIPTION: Significant updates have been made to the process module. This includes changes to ArgIterator.next return types, buffer size fixes for process.argsAlloc, and added support for single quotes in ArgIteratorGeneral. Implementations now leverage posix_spawn as an alternative to fork-exec where possible, and ChildProcess.init no longer performs heap allocations. Error handling for empty PATH in ChildProcess and buffer overflows in std.os.execvpe have also been addressed.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

// Example: Using ArgIteratorGeneral with single quote support
var iter = std.process.argsAlloc.generalIterator(std.heap.page_allocator, "'quoted arg'");
while (iter.next()) |arg|
{
    std.debug.print("Argument: {s}\\n", .{arg});
}

// Example: Using posix_spawn (conceptual)
// const child = try std.ChildProcess.init(&.{ "./my_program" }, .{});
// try child.spawn(.{ .use_posix_spawn = true });

```

--------------------------------

TITLE: Zig Keyword: callconv
DESCRIPTION: The `callconv` keyword in Zig is used within a function type declaration to specify the calling convention. This is crucial for interoperability, especially when interfacing with code written in different languages or using different ABI standards.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
const MyFuncType = fn(a: i32) i32; // Default calling convention
const MyCConvFuncType = fn(a: i32) i32 callconv(.C) i32;

```

--------------------------------

TITLE: Zig ArrayList API Update
DESCRIPTION: The ArrayList API in Zig has been updated to make the 'items' field directly usable as the slice of valid objects. Capacity is now managed separately. This change simplifies usage but may break existing callsites. Deprecated functions like 'toSlice' and 'at' should be replaced with direct 'items' slice access.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const ArrayList = struct {
    items: []T,
    capacity: usize,
};

// Example of direct access:
var list: ArrayList(i32) = undefined;
const first_item = list.items[0];

// Deprecated usage (to be avoided):
// const first_item = list.toSlice()[0];
```

--------------------------------

TITLE: Zig Integer-Pointer Conversion
DESCRIPTION: Illustrates how to convert between integer memory addresses and Zig pointers using the built-in functions @ptrFromInt and @intFromPtr. This is useful for low-level memory manipulation or interfacing with C code. The example verifies the type and value of the converted address.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "@intFromPtr and @ptrFromInt" {
    const ptr: *i32 = @ptrFromInt(0xdeadbee0);
    const addr = @intFromPtr(ptr);
    try expect(@TypeOf(addr) == usize);
    try expect(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Zig Fully Anonymous Struct Type Inference
DESCRIPTION: Demonstrates how Zig can infer the type of a struct literal when it's passed to a function expecting `anytype`, allowing for flexible and anonymous data structures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
    const expect = std.testing.expect;
    
    test "fully anonymous struct" {
        dump(.{
            .int = @as(u32, 1234),
            .float = @as(f64, 12.34),
            .b = true,
            .s = "hi",
        });
    }
    
    fn dump(args: anytype) void {
        expect(args.int == 1234);
        expect(args.float == 12.34);
        expect(args.b);
        expect(args.s[0] == 'h');
        expect(args.s[1] == 'i');
    }

    $ zig test struct_anon.zig
    1/1 test "fully anonymous struct"... OK
    All 1 tests passed.
    
```

--------------------------------

TITLE: Zig Build System: Link System Library
DESCRIPTION: Demonstrates how to use the Zig Build System's `linkSystemLibrary` API, which hints Zig to search system default paths for libraries. This functionality can also be exposed to the command line interface.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: Zig
CODE:
```
zig build-exe --c-source hello.c --library c -target x86_64-linux-musl
```

--------------------------------

TITLE: Zig: Sentinel-Terminated Pointers Example
DESCRIPTION: Demonstrates passing strings to Zig and C functions using sentinel-terminated pointers. The `do_it_the_zig_way` function accepts a slice `[]const u8`, while `do_it_the_c_way` accepts a C-style null-terminated pointer `*const [N:0]u8`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    do_it_the_zig_way("world");
    do_it_the_c_way("world");
}

fn do_it_the_zig_way(arg: []const u8) void {
    std.debug.warn("hello {}\n", .{arg});
}

fn do_it_the_c_way(arg: *const [N:0]u8) void {
    _ = std.c.printf("hello %s\n", arg);
}
```

--------------------------------

TITLE: Zig: Add io.Reader.readUntilDelimiter
DESCRIPTION: Adds `io.Reader.readUntilDelimiter`, a method to read data from a reader until a specified delimiter is encountered.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
io.Reader.readUntilDelimiter
```

--------------------------------

TITLE: Add waitid Syscall on Linux
DESCRIPTION: Introduces the `waitid` syscall to the Linux OS bindings, providing a more flexible way to wait for process status changes.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Add waitid syscall on linux ([#9335](https://github.com/ziglang/zig/issues/9335)).
```

--------------------------------

TITLE: Zig Volatile Pointers
DESCRIPTION: Demonstrates the use of the `volatile` keyword in Zig for memory-mapped input/output (MMIO). This example shows how to declare a pointer to a volatile type and verifies its type. It highlights that `volatile` ensures loads and stores happen as specified in the source code, preventing compiler optimizations that might reorder or omit them.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Build Commands for Different Modes
DESCRIPTION: Demonstrates how to compile Zig executables using different build modes via the Zig command-line interface. Each command corresponds to a specific set of optimizations and safety checks, affecting compilation speed, runtime performance, and binary size.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: bash
CODE:
```
$ zig build-exe example.zig
```

LANGUAGE: bash
CODE:
```
$ zig build-exe example.zig -O ReleaseFast
```

LANGUAGE: bash
CODE:
```
$ zig build-exe example.zig -O ReleaseSafe
```

LANGUAGE: bash
CODE:
```
$ zig build-exe example.zig -O ReleaseSmall
```

--------------------------------

TITLE: Zig C-compatible `main` Export
DESCRIPTION: Illustrates how to export a C-compatible `main` function when the Zig compilation links libc. This function signature matches the C `main` function, accepting argument count (`argc`) and argument values (`argv`), and returning an integer status code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
pub export fn main(argc: c_int, argv: [*]const [*:0]const u8) c_int {
    const args = argv[0..@intCast(argc)];
    std.debug.print("Hello! argv[0] is '{s}'\n", .{args[0]});
    return 0;
}

const std = @import("std");
```

--------------------------------

TITLE: Zig Volatile Pointers
DESCRIPTION: Demonstrates the use of the `volatile` keyword in Zig for memory-mapped input/output (MMIO). This example shows how to declare a pointer to a volatile type and verifies its type. It highlights that `volatile` ensures loads and stores happen as specified in the source code, preventing compiler optimizations that might reorder or omit them.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Opaque Type Declaration and Usage
DESCRIPTION: Illustrates the use of `opaque {}` in Zig to declare types with unknown size and alignment, often used for type safety when interfacing with C code. It shows how opaque types can be declared and used in function signatures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig CC: Support for stdin input
DESCRIPTION: Describes the enhancement in `zig cc` that allows it to read source code directly from standard input, useful for piping code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: shell
CODE:
```
echo "int main() { return 0; }" | zig cc -o main -
```

--------------------------------

TITLE: Zig: Remove mem.spanZ in favor of mem.sliceTo
DESCRIPTION: The `mem.spanZ` function has been removed. Use `mem.sliceTo` instead for creating slices from null-terminated strings.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
mem.spanZ
```

LANGUAGE: Zig
CODE:
```
mem.sliceTo
```

--------------------------------

TITLE: C Header for Zig Exported Library
DESCRIPTION: A C header file (`mathtest.h`) that is automatically generated by Zig when exporting a library. This header declares the exported Zig functions, allowing C code to correctly interface with the compiled Zig library.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: C
CODE:
```
// This header is generated by zig from mathtest.zig
#include "mathtest.h"
#include <stdio.h>

int main(int argc, char **argv) {
    int32_t result = add(42, 1337);
    printf("%d\n", result);
    return 0;
}
```

--------------------------------

TITLE: Zig: Single-Threaded Build Option
DESCRIPTION: Enables the `-fsingle-threaded` compile option, which treats thread-local variables as container-level variables and optimizes async function overhead. It also affects runtime APIs like `std.Mutex`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example usage within a Zig file
// The effects are compiler-level, not directly shown in code snippets here.
```

--------------------------------

TITLE: Zig Async Test Skip Example
DESCRIPTION: Illustrates skipping an asynchronous Zig test that contains a suspend point. The test is skipped because the suspend point is encountered during execution in the default blocking IO mode. The output explicitly mentions 'async test' for the skip.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

test "async skip test" {
    var frame = async func();
    const result = await frame;
    try std.testing.expect(result == 1);
}

fn func() i32 {
    suspend {
        resume @frame();
    }
    return 1;
}
```

--------------------------------

TITLE: Zig Debug: Nosuspend for stderr.print
DESCRIPTION: Ensures that stderr.print calls are wrapped with nosuspend to fix compilation errors that occur in non-blocking I/O mode. This improves the robustness of debug output handling.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: Zig
CODE:
```
debug: Add nosuspend around stderr.print calls. Fixes compilation errors with non-blocking I/O mode.
```

--------------------------------

TITLE: Zig Opaque Type Declaration and Usage
DESCRIPTION: Illustrates the declaration and usage of opaque types in Zig, which have unknown size and alignment. Opaque types are useful for interfacing with C code where struct details are not exposed, ensuring type safety. The example shows an external function expecting an opaque pointer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.c) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to read command line arguments using Zig's standard library with WASI. It allocates memory for arguments and prints them with their index. Requires the `std` module.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args, 0..) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Fix os.uefi Packed Struct Bitfields
DESCRIPTION: Corrects the handling of packed struct bitfields within the `os.uefi` module, ensuring accurate representation of UEFI structures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
os.uefi: fix packed struct bitfields.
```

--------------------------------

TITLE: Zig StringPoolContext for Hash Maps
DESCRIPTION: Illustrates a `StringPoolContext` struct that holds a `StringPool` and provides `hash` and `eql` functions to operate on `StringPool.ID` types, enabling specialized key handling in hash maps.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
pub const StringPoolContext = struct {
    pool: StringPool,
    pub fn hash(self: @This(), s: StringPool.ID) u64 {
        return self.pool.getStringHash(s);
    }
    pub fn eql(self: @This(), a: StringPool.ID, b: StringPool.ID) bool {
        return a == b;
    }
};
```

--------------------------------

TITLE: Zig Syscall Example for Printing
DESCRIPTION: This Zig code snippet demonstrates how to use inline assembly to perform a 'write' syscall, printing 'Hello, world!\n' to standard output one million times. It also includes a 'exit' syscall. The code is optimized for performance, showing a significant reduction in wall clock time and memory usage.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
pub export fn _start() noreturn {
    print(); // repeated 1,000,000 times
    exit();
}

fn print() void {
    asm volatile ("syscall"
        : 
        : [number] "{rax}" (1),
          [arg1] "{rdi}" (1),
          [arg2] "{rsi}" (@ptrToInt("Hello, world!\n")),
          [arg3] "{rdx}" (14)
        : "rcx", "r11", "memory"
    );
    return;
}

fn exit() noreturn {
    asm volatile ("syscall"
        : 
        : [number] "{rax}" (231),
          [arg1] "{rdi}" (0)
        : "rcx", "r11", "memory"
    );
    unreachable;
}
```

--------------------------------

TITLE: Zig Standard Library: macOS Syscall and Debugging Improvements
DESCRIPTION: This section details enhancements to Zig's standard library for macOS, including updated libc headers and the use of `if_nametoindex` for IP parsing. It covers the implementation of a segfault handler for both x86_64 and aarch64 architectures, fixes in macOS debug symbol lookup, and the addition of `mach_*` syscalls for process management. It also notes updates to Mach routines for page info and fixes for incorrect return types on some libc functions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example: Using if_nametoindex for IP parsing on macOS
const ip_str = "192.168.1.1";
const if_index = try std.c.if_nametoindex(ip_str);

// Example: Mach syscalls for process management (conceptual)
const pid = std.os.getpid();
var proc_info: std.os.mach.task_basic_info_data_t = undefined;
var count = @sizeOf(proc_info) / @sizeOf(c_uint);
try std.os.mach.task_info(std.os.mach.mach_task_self(), std.os.mach.TASK_BASIC_INFO, @ptrCast(&proc_info), &count);

// Example: Handling segfaults (conceptual)
std.debug.global_atexit.register(segfault_handler);

fn segfault_handler() void {
    // Handle segfault
}

```

--------------------------------

TITLE: Zig Opaque Type Declaration and Usage
DESCRIPTION: Illustrates the declaration and usage of opaque types in Zig, which have unknown size and alignment. This is useful for type safety when interfacing with C code. The example shows an attempt to cast between different opaque types, resulting in a compile-time error.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Zig: os.uefi.protocols.FileProtocol fixes
DESCRIPTION: Applies fixes to the `os.uefi.protocols.FileProtocol` implementation, specifically for `get_position` and `set_position`, referencing issue #7762. This ensures correct file pointer manipulation in UEFI.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
os.uefi.protocols.FileProtocol: fix and expose get_position, set_position ([#7762](https://github.com/ziglang/zig/issues/7762))
```

--------------------------------

TITLE: Zig C-compatible Entry Point 'export fn main'
DESCRIPTION: Defines an entry point function 'main' with a C-compatible signature, allowing it to be exported. This is useful when Zig applications link against libc. The function receives argc and argv and prints the first argument.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
pub export fn main(argc: c_int, argv: [*]const [*:0]const u8) c_int {
    const args = argv[0..@intCast(argc)];
    std.debug.print("Hello! argv[0] is '{s}'\n", .{args[0]});
    return 0;
}

const std = @import("std");
```

--------------------------------

TITLE: Enhance std.os Functionality
DESCRIPTION: Adds 0-length buffer checks to os.read and os.write to prevent undefined pointer errors. Fixes alignment for Sigaction.handler_fn, optimizes os.isCygwinPty, adds mincore syscall, and includes missing mmap errors.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
Add 0-length buffer checks to os.read and os.write
std.os: fix alignment of Sigaction.handler_fn
os.isCygwinPty: Fix a bug, replace kernel32 call, and optimize
std.os: add mincore syscall
std.os: add missing mmap errors
```

--------------------------------

TITLE: Peer Type Resolution for Slices and Pointers in Zig
DESCRIPTION: Explains LemonBoy's implementation of peer type resolution between `?[]T` and `*[N]T` slices/pointers in Zig, referencing issue #4767.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: zig
CODE:
```
?[]T
```

LANGUAGE: zig
CODE:
```
*[N]T
```

--------------------------------

TITLE: Zig C-compatible Entry Point 'export fn main'
DESCRIPTION: Defines an entry point function 'main' with a C-compatible signature, allowing it to be exported. This is useful when Zig applications link against libc. The function receives argc and argv and prints the first argument.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: Zig
CODE:
```
pub export fn main(argc: c_int, argv: [*]const [*:0]const u8) c_int {
    const args = argv[0..@intCast(argc)];
    std.debug.print("Hello! argv[0] is '{s}'\n", .{args[0]});
    return 0;
}

const std = @import("std");
```

--------------------------------

TITLE: Zig: Function Reflection
DESCRIPTION: Shows how to use Zig's reflection capabilities to inspect function properties. This example uses `@TypeOf` to check the return type and `is_var_args` property of a function.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;

test "fn reflection" {
    assert(@TypeOf(assert).ReturnType == void);
    assert(@TypeOf(assert).is_var_args == false);
}
```

--------------------------------

TITLE: Zig Compiler C++ Memory Allocation Overhaul
DESCRIPTION: Details of a significant overhaul to C++ memory allocation within the Zig compiler. This includes introducing a new `mem::Allocator` interface, implementing `heap::CAllocator` and `heap::ArenaAllocator`, and updating container types to accept explicit allocators.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: C++
CODE:
```
new `mem::Allocator` interface
```

LANGUAGE: C++
CODE:
```
new `heap::CAllocator` impl with global `heap::c_allocator`
```

LANGUAGE: C++
CODE:
```
new `heap::ArenaAllocator` impl
```

LANGUAGE: C++
CODE:
```
new `mem::List` takes explicit `Allocator&` parameter
```

LANGUAGE: C++
CODE:
```
new `mem::HashMap` takes explicit `Allocator&` parameter
```

LANGUAGE: C++
CODE:
```
add `Codegen.pass1_arena` and use for all `ZigValue` allocs
```

LANGUAGE: C++
CODE:
```
deinit `Codegen.pass1_arena` early in `zig_llvm_emit_output()`
```

--------------------------------

TITLE: Zig Fully Anonymous Struct Type Inference
DESCRIPTION: Demonstrates how Zig can infer the type of a struct literal when it's passed to a function expecting `anytype`, allowing for flexible and anonymous data structures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
    const expect = std.testing.expect;
    
    test "fully anonymous struct" {
        dump(.{
            .int = @as(u32, 1234),
            .float = @as(f64, 12.34),
            .b = true,
            .s = "hi",
        });
    }
    
    fn dump(args: anytype) void {
        expect(args.int == 1234);
        expect(args.float == 12.34);
        expect(args.b);
        expect(args.s[0] == 'h');
        expect(args.s[1] == 'i');
    }

    $ zig test struct_anon.zig
    1/1 test "fully anonymous struct"... OK
    All 1 tests passed.
    
```

--------------------------------

TITLE: Zig Noreturn Type Compatibility
DESCRIPTION: Explains the `noreturn` type in Zig and its compatibility with other types in control flow structures like `if` and `switch`. It also shows an example of using `noreturn` with an external function like `ExitProcess`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.1/index.html

LANGUAGE: zig
CODE:
```
fn foo(condition: bool, b: u32) {
    const a = if (condition) b else return;
    bar(a);
}

extern fn bar(value: u32);
```

LANGUAGE: zig
CODE:
```
pub extern "kernel32" stdcallcc fn ExitProcess(exit_code: c_uint) -> noreturn;

fn foo() {
    const value = bar() %% ExitProcess(1);
    assert(value == 1234);
}

fn bar() -> %u32 {
    return 1234;
}

const assert = @import("std").debug.assert;
```

--------------------------------

TITLE: Improve BigInt Comparison with math.Order
DESCRIPTION: Big integer comparison code has been improved to use `math.Order` instead of `i8`. This change provides a more expressive and type-safe way to represent comparison results.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.big.rational.gcd
```

LANGUAGE: Zig
CODE:
```
std.big.int.gcd
```

LANGUAGE: Zig
CODE:
```
math.Order
```

--------------------------------

TITLE: Zig Inline Assembly Typed Clobbers
DESCRIPTION: Compares the old stringly-typed clobbers in Zig's inline assembly with the new typed clobbers, which improve type safety and readability. The example shows a `syscall1` function.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.15.1/release-notes.html

LANGUAGE: Zig
CODE:
```
pub fn syscall1(number: usize, arg1: usize) usize {
    return asm volatile ("syscall"
        : [ret] "={rax}" (-> usize),
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
        : "rcx", "r11"
    );
}
```

LANGUAGE: Zig
CODE:
```
pub fn syscall1(number: usize, arg1: usize) usize {
    return asm volatile ("syscall"
        : [ret] "={rax}" (-> usize),
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
        : .{ .rcx = true, .r11 = true });
}
```

--------------------------------

TITLE: Zig Linker: Handling Entry Point Stubs
DESCRIPTION: Addresses a specific edge case where the entry point might be a stub entry, ensuring correct linking.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
handle weird case of entry point being a stub entry (`__TEXT,__stubs` entry)
```

--------------------------------

TITLE: Export Zig Enum with C-ABI Compatibility
DESCRIPTION: Demonstrates how to define a Zig enum that is compatible with the C Application Binary Interface (ABI). By default, Zig enums are not C-ABI compatible. To achieve compatibility, an explicit tag type (e.g., `c_int`) must be provided to the enum definition. This allows the enum to be used in functions exported to C.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
const Foo = enum(c_int) {
    a, b, c
};

export fn entry(foo: Foo) void {
    _ = foo;
}
```

--------------------------------

TITLE: Zig: Inline Function Comptime Propagation
DESCRIPTION: Demonstrates how comptime-ness of arguments propagates to the return value of an inlined Zig function. It also shows that runtime side-effects of inlined functions still occur, as tracked by a call counter.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
var call_count: u32 = 0;

inline fn isGreaterThan(x: i32, y: i32) bool {
    call_count += 1;
    return x > y;
}

test "inline call comptime propagation" {
    // Runtime-known parameters to inline function, nothing new here.
    var a: i32 = 1234;
    var b: i32 = 5678;
    try std.testing.expect(!isGreaterThan(a, b));

    // Now it gets interesting...
    const c = 1234;
    const d = 5678;
    if (isGreaterThan(c, d)) {
        @compileError("that wasn't supposed to happen");
    }

    try std.testing.expect(call_count == 2);
}
```

--------------------------------

TITLE: Zig @prefetch Builtin with PrefetchOptions
DESCRIPTION: Zig 0.11.0 introduces the `@prefetch` builtin function, which allows developers to hint to the compiler to emit prefetch instructions for performance optimization. The `PrefetchOptions` struct configures whether the prefetch is for a read or write, its temporal locality, and the cache type (instruction or data).

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
@prefetch(ptr: anytype, comptime options: std.builtin.PrefetchOptions)
```

LANGUAGE: Zig
CODE:
```
/// This data structure is used by the Zig language code generation and
/// therefore must be kept in sync with the compiler implementation.
pub const PrefetchOptions = struct {
    /// Whether the prefetch should prepare for a read or a write.
    rw: Rw = .read,
    /// 0 means no temporal locality. That is, the data can be immediately
    /// dropped from the cache after it is accessed.
    ///
    /// 3 means high temporal locality. That is, the data should be kept in
    /// the cache as it is likely to be accessed again soon.
    locality: u2 = 3,
    /// The cache that the prefetch should be preformed on.
    cache: Cache = .data,

    pub const Rw = enum {
        read,
        write,
    };

    pub const Cache = enum {
        instruction,
        data,
    };
};
```

--------------------------------

TITLE: Zig Volatile Memory Access
DESCRIPTION: Explains and demonstrates the use of `volatile` in Zig for memory-mapped input/output (MMIO). It ensures that loads and stores to volatile pointers are preserved and executed in the specified order.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr = @intToPtr(*volatile u8, 0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Progress Protocol: Node API Thread Safety
DESCRIPTION: This section explains the thread-safe and lock-free design of the `Node.start` and `Node.end` APIs within the Zig Progress Protocol. It emphasizes the use of statically allocated buffers and a custom allocator for performance.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.13.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Assume Node and its associated allocator are defined elsewhere
// and are part of the Zig Progress Protocol implementation.

// Example of how Node.start might be called (conceptual):
// var node: Node = ...;
// try node.start(); // This API is designed to be thread-safe and lock-free.

// Example of how Node.end might be called (conceptual):
// try node.end(); // This API is also designed to be thread-safe and lock-free.

```

--------------------------------

TITLE: Rework ResetEvent with pthreads
DESCRIPTION: This update reworks ResetEvent to improve Darwin integration and uses sem_t when linking against pthreads, enhancing synchronization primitives in Zig.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html



--------------------------------

TITLE: Fix io.Reader.readUntilDelimiter Byte Loss
DESCRIPTION: Corrects a bug in `io.Reader.readUntilDelimiter` where the last byte could be lost if it appeared after the maximum size. This ensures that the delimiter reading function captures all relevant data.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.1/release-notes.html

LANGUAGE: Zig
CODE:
```
`io.Reader.readUntilDelimiter`: fixed functions losing last byte if it is past the max size
```

--------------------------------

TITLE: Generic Call Workaround with Explicit Type Return
DESCRIPTION: Provides a workaround for the generic function type equality issue by introducing a helper function `Make` that explicitly returns the desired struct type. This ensures type consistency across different generic instantiations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "generic call demo" {
    const a = foo(i32, 1234);
    const b = foo(i32, 5678);
    try expect(@TypeOf(a) == @TypeOf(b));
}

fn foo(comptime T: type, init: T) Make(T) {
    return .{ .x = init };
}

fn Make(comptime T: type) type {
    return struct {
        x: T
    };
}
```

--------------------------------

TITLE: Zig Blocking Fetch and File Read
DESCRIPTION: This Zig code snippet demonstrates blocking operations for fetching URL content and reading from a file. It uses `async` and `await` but omits `suspend` points, causing the execution order to be determined by the `async` call sites. Error handling and resource cleanup are managed with `errdefer`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: zig
CODE:
```
    const std = @import("std");
    const Allocator = std.mem.Allocator;
    
    pub fn main() void {
        _ = async amainWrap();
    }
    
    fn amainWrap() void {
        amain() catch |e| {
            std.debug.warn("{}\n", e);
            if (@errorReturnTrace()) |trace| {
                std.debug.dumpStackTrace(trace.*);
            }
            std.process.exit(1);
        };
    }
    
    fn amain() !void {
        const allocator = std.heap.direct_allocator;
        var download_frame = async fetchUrl(allocator, "https://example.com/");
        var awaited_download_frame = false;
        errdefer if (!awaited_download_frame) {
            if (await download_frame) |r| allocator.free(r) else |_| {}
        };
    
        var file_frame = async readFile(allocator, "something.txt");
        var awaited_file_frame = false;
        errdefer if (!awaited_file_frame) {
            if (await file_frame) |r| allocator.free(r) else |_| {}
        };
    
        awaited_file_frame = true;
        const file_text = try await file_frame;
        defer allocator.free(file_text);
    
        awaited_download_frame = true;
        const download_text = try await download_frame;
        defer allocator.free(download_text);
    
        std.debug.warn("download_text: {}\n", download_text);
        std.debug.warn("file_text: {}\n", file_text);
    }
    
    fn fetchUrl(allocator: *Allocator, url: []const u8) ![]u8 {
        const result = try std.mem.dupe(allocator, u8, "this is the downloaded url contents");
        errdefer allocator.free(result);
        std.debug.warn("fetchUrl returning\n");
        return result;
    }
    
    fn readFile(allocator: *Allocator, filename: []const u8) ![]u8 {
        const result = try std.mem.dupe(allocator, u8, "this is the file contents");
        errdefer allocator.free(result);
        std.debug.warn("readFile returning\n");
        return result;
    }

    $ zig build-exe blocking.zig
    $ ./blocking
    fetchUrl returning
    readFile returning
    download_text: this is the downloaded url contents
    file_text: this is the file contents
```

--------------------------------

TITLE: Zig Bitwise XOR Operator
DESCRIPTION: Details the bitwise XOR operator (^) for integers in Zig, noting that it invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
a ^ b
a ^= b

-- Relevant Types:
* Integers

-- Description:
Bitwise XOR.
* Invokes Peer Type Resolution for the operands.

-- Example:
0b011 ^ 0b101 == 0b110
```

--------------------------------

TITLE: Zig cc: Handle /dev/null for Output
DESCRIPTION: Special handling for `/dev/null` as an output target is introduced. `-o /dev/null` is now equivalent to `-fno-emit-bin`, preventing unnecessary file system operations and improving efficiency.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
zig cc -o /dev/null
```

--------------------------------

TITLE: Zig and C cross-language optimization with LTO
DESCRIPTION: This example demonstrates how Zig's LTO can optimize code across Zig and C files. The `main.zig` file calls an external C function `foo1` and exports a Zig function `foo4` which prints to stdout. The `a.c` file defines `foo1` and `foo4`, along with other logic. When compiled with LTO enabled, the Zig `main` function can be optimized to not include calls to `foo1` or exports of `foo4` if they are not used, as shown in the objdump output.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

export fn foo4() void {
    _ = std.c.printf("Hi\n");
}

extern fn foo1() c_int;

pub fn main() u8 {
    return @intCast(u8, foo1());
}
```

LANGUAGE: c
CODE:
```
int foo1(void);
void foo2(void);
void foo4(void);

static signed int i = 0;

void foo2(void) {
  i = -1;
}

static int foo3() {
  foo4();
  return 10;
}

int foo1(void) {
  int data = 0;

  if (i < 0)
    data = foo3();

  data = data + 42;
  return data;
}
```

--------------------------------

TITLE: Testing Opaque Type Interaction
DESCRIPTION: Illustrates the shell output when testing Zig code involving opaque types, highlighting a type mismatch error that occurs due to incompatible opaque type pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: shell
CODE:
```
$ zig test test_opaque.zig
docgen_tmp/test_opaque.zig:6:9: error: expected type '\*test_opaque.Derp', found '\*test_opaque.Wat'
    bar(w);
        ^
docgen_tmp/test_opaque.zig:6:9: note: pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'
docgen_tmp/test_opaque.zig:2:13: note: opaque declared here
const Wat = opaque {};
            ^~~~~~~~~~
docgen_tmp/test_opaque.zig:1:14: note: opaque declared here
const Derp = opaque {};
             ^~~~~~~~~~
docgen_tmp/test_opaque.zig:4:18: note: parameter type declared here
extern fn bar(d: *Derp) void;
                 ^~~~~
referenced by:
    test.call foo: docgen_tmp/test_opaque.zig:10:5
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

--------------------------------

TITLE: Zig: Scope ID Resolution via IPv6
DESCRIPTION: Changes the method for resolving scope IDs to use IPv6 sockets, potentially improving network address handling and compatibility.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
Change to resolving scope IDs using IPv6 sockets.
```

--------------------------------

TITLE: Zig Fully Anonymous List Literal with Type Inference
DESCRIPTION: Explains how anonymous list literals can be used when the type is not specified in the result location, leading to a struct with numbered field names. The 'dump' function accesses these fields using quoted numbers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
test "fully anonymous list literal" {
    dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: anytype) void {
    expect(args.@"0" == 1234);
    expect(args.@"1" == 12.34);
    expect(args.@"2");
    expect(args.@"3"[0] == 'h');
    expect(args.@"3"[1] == 'i');
}
```

--------------------------------

TITLE: Zig Packed Struct Atomics
DESCRIPTION: Shows how packed structs can be used directly in atomic operations in Zig, without requiring a `@bitCast` to their underlying integer type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: zig
CODE:
```
#code|packed_struct_atomics.zig#
```

--------------------------------

TITLE: Make ArenaAllocator.deinit Mutable Reference Optional
DESCRIPTION: The `std.heap.ArenaAllocator.deinit` function no longer requires a mutable reference. This change simplifies its usage and allows for more flexible memory management scenarios.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.heap.ArenaAllocator.deinit
```

--------------------------------

TITLE: Zig Blocking Fetch and Read Example
DESCRIPTION: This Zig code demonstrates a blocking approach to fetching URL content and reading a file. It uses `async` and `await` but without `suspend`, showing how the execution order is determined by the call sites. Error handling is included via `amainWrap`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
pub fn main() void {
        _ = async amainWrap();
    }
    
    fn amainWrap() void {
        amain() catch |e| {
            std.debug.warn("{}\n", .{e});
            if (@errorReturnTrace()) |trace| {
                std.debug.dumpStackTrace(trace.*);
            }
            std.process.exit(1);
        };
    }
    
    fn amain() !void {
        const allocator = std.heap.page_allocator;
        var download_frame = async fetchUrl(allocator, "https://example.com/");
        var awaited_download_frame = false;
        errdefer if (!awaited_download_frame) {
            if (await download_frame) |r| allocator.free(r) else |_| {}
        };
    
        var file_frame = async readFile(allocator, "something.txt");
        var awaited_file_frame = false;
        errdefer if (!awaited_file_frame) {
            if (await file_frame) |r| allocator.free(r) else |_| {}
        };
    
        awaited_file_frame = true;
        const file_text = try await file_frame;
        defer allocator.free(file_text);
    
        awaited_download_frame = true;
        const download_text = try await download_frame;
        defer allocator.free(download_text);
    
        std.debug.warn("download_text: {}\n", .{download_text});
        std.debug.warn("file_text: {}\n", .{file_text});
    }
    
    fn fetchUrl(allocator: *Allocator, url: []const u8) ![]u8 {
        const result = try std.mem.dupe(allocator, u8, "this is the downloaded url contents");
        errdefer allocator.free(result);
        std.debug.warn("fetchUrl returning\n", .{});
        return result;
    }
    
    fn readFile(allocator: *Allocator, filename: []const u8) ![]u8 {
        const result = try std.mem.dupe(allocator, u8, "this is the file contents");
        errdefer allocator.free(result);
        std.debug.warn("readFile returning\n", .{});
        return result;
    }
```

--------------------------------

TITLE: Zig: Move Mach-O Load Command Utils to Standard Library
DESCRIPTION: Load command wrappers and parsing utilities for Mach-O files have been moved to the Zig Standard Library. This promotes code reuse and modularity within the Zig ecosystem.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
macho: moved load command wrappers and parsing utils to the {#link|Standard Library#} ([#10310](https://github.com/ziglang/zig/issues/10310)).
```

--------------------------------

TITLE: Zig Packed Struct Equality
DESCRIPTION: Demonstrates direct equality comparison for packed structs in Zig, eliminating the need for `@bitCast` to the underlying integer type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: zig
CODE:
```
#code|packed_struct_equality.zig#
```

--------------------------------

TITLE: Zig Atomic Queue and ArrayList Operations
DESCRIPTION: Improvements to Zig's atomic Queue, including a fix for the `unget` implementation and added documentation. New functions `getLast` and `getLastOrNull` are added to ArrayListAligned/ArrayListAlignedUnmanaged, and `insertAssumeCapacity` is added to ArrayList.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.atomic.Queue: fix unget implementation and add docs
Add fromOwnedSliceSentinel to ArrayList ArrayList and ArrayListUnmanaged, add fromOwnedSlice to ArrayListUnmanaged
Add the two functions 'getLast' and 'getLastOrNull' to ArrayListAligned/ArrayListAlignedUnmanaged.
std: Expose Int parameter in std.PackedInt[Array,Slice]
std: Add ArrayList.insertAssumeCapacity()
ArrayList: Allow const for getLast ([#14522](https://github.com/ziglang/zig/issues/14522))
```

--------------------------------

TITLE: Zig Fully Anonymous List Literal with Type Inference
DESCRIPTION: Explains how anonymous list literals can be used when the type is not specified in the result location, leading to a struct with numbered field names. The 'dump' function accesses these fields using quoted numbers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
test "fully anonymous list literal" {
    dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: anytype) void {
    expect(args.@"0" == 1234);
    expect(args.@"1" == 12.34);
    expect(args.@"2");
    expect(args.@"3"[0] == 'h');
    expect(args.@"3"[1] == 'i');
}
```

--------------------------------

TITLE: Testing Opaque Type Interaction
DESCRIPTION: Illustrates the shell output when testing Zig code involving opaque types, highlighting a type mismatch error that occurs due to incompatible opaque type pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: shell
CODE:
```
$ zig test test_opaque.zig
docgen_tmp/test_opaque.zig:6:9: error: expected type '\*test_opaque.Derp', found '\*test_opaque.Wat'
    bar(w);
        ^
docgen_tmp/test_opaque.zig:6:9: note: pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'
docgen_tmp/test_opaque.zig:2:13: note: opaque declared here
const Wat = opaque {};
            ^~~~~~~~~~
docgen_tmp/test_opaque.zig:1:14: note: opaque declared here
const Derp = opaque {};
             ^~~~~~~~~~
docgen_tmp/test_opaque.zig:4:18: note: parameter type declared here
extern fn bar(d: *Derp) void;
                 ^~~~~
referenced by:
    test.call foo: docgen_tmp/test_opaque.zig:10:5
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

--------------------------------

TITLE: Multiline Library Name Parsing and PATH Variable Handling
DESCRIPTION: Fixes for crashes when parsing multiline library names and for std.child_process.ChildProcess.spawnWindows when searching the PATH environment variable.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const child = try std.child_process.ChildProcess.spawnWindows({
    .allocator = allocator,
    .argv = &[_][]const u8{"my_app"},
    .env_map = std.Process.envMap(allocator, .{.inherit = true}),
});
```

--------------------------------

TITLE: Zig Tuple Operations and Testing
DESCRIPTION: Demonstrates the creation and manipulation of anonymous structs (tuples) in Zig. It shows how to access elements, use concatenation and repetition operators, and iterate over tuples. The example includes a test case to verify tuple functionality.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "tuple" {
    const values = .{
        @as(u32, 1234),
        @as(f64, 12.34),
        true,
        "hi",
    } ++ .{"false"} ** 2;
    try expect(values[0] == 1234);
    try expect(values[4] == false);
    inline for (values, 0..) |v, i| {
        if (i != 2) continue;
        try expect(v);
    }
    try expect(values.len == 6);
    try expect(values.@"3"[0] == 'h');
}
```

--------------------------------

TITLE: Zig Spawn Threads and Atomic Operations
DESCRIPTION: Illustrates Zig's concurrency features by spawning multiple threads that increment a shared counter using atomic operations. This example showcases `std.os.spawnThread` and atomic memory access primitives.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;
const builtin = @import("builtin");
const AtomicRmwOp = builtin.AtomicRmwOp;
const AtomicOrder = builtin.AtomicOrder;

test "spawn threads" {
    var shared_ctx: i32 = 1;

    const thread1 = try std.os.spawnThread({}, start1);
    const thread2 = try std.os.spawnThread(&shared_ctx, start2);
    const thread3 = try std.os.spawnThread(&shared_ctx, start2);
    const thread4 = try std.os.spawnThread(&shared_ctx, start2);

    thread1.wait();
    thread2.wait();
    thread3.wait();
    thread4.wait();

    assert(shared_ctx == 4);
}

fn start1(ctx: void) u8 {
    return 0;
}

fn start2(ctx: *i32) u8 {
    _ = @atomicRmw(i32, ctx, AtomicRmwOp.Add, 1, AtomicOrder.SeqCst);
    return 0;
}
```

--------------------------------

TITLE: Zig: Direct Struct Parameter Passing
DESCRIPTION: Shows how Zig allows structs to be passed directly to functions, rather than requiring pointers. This example defines a struct 'Foo', a function 'callee' that accepts 'Foo' by value, and a test case to demonstrate the functionality.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const assert = @import("std").debug.assert;

const Foo = struct {
    x: i32,
    y: i32,
};

fn callee(foo: Foo) void {
    assert(foo.y == 2);
}

test "pass directly" {
    callee(Foo{ .x = 1, .y = 2 });
}
```

--------------------------------

TITLE: Zig Build System: Add ELF Parse/Dump to CheckObject
DESCRIPTION: Integrates ELF parsing and dumping functionality into std.Build.Step.CheckObject, enhancing its capabilities for analyzing object files.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
std: add ELF parse'n'dump functionality to std.Build.Step.CheckObject
```

--------------------------------

TITLE: C Compatibility and Prototypes
DESCRIPTION: This snippet focuses on C compatibility within the Zig standard library, specifically addressing fixes for C prototypes and the harmonization of `off_t` usage between libc and Zig implementations. It also includes preferring 64-bit libc functions where available.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: c
CODE:
```
c: Fix prototypes for bcmp and memcmp
Prefer 64bit libc functions where possible
Harmonize use of off_t between libc and Zig impls
```

--------------------------------

TITLE: Zig Threading API Updates
DESCRIPTION: This update revises Zig's threading API to be more consistent with built-in call syntax. It introduces customizable thread stack sizes, renames `wait()` to `join()` and `handle()` to `getHandle()`, and adds functionality to `detach()` threads. It also standardizes thread ID retrieval and adds methods for setting and getting thread names.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
#Thread spawning API is now similar to the @call(.{}, function, args_tuple) builtin.
#Spawn options (first arg) with customizable thread stack size.
#Renamed `wait()` to `join()`.
#Renamed `handle()` to `getHandle()` for consistency.
#Added ability to `detach()` thread, allowing it to clean up resources when it exits instead of calling `join()`.
#Moved `getCurrentThreadId()` into `getCurrentId()`.
#Added `Thread.setName` and `Thread.getName` including for DragonFlyBSD
```

--------------------------------

TITLE: Allow ArrayList(u0) Creation
DESCRIPTION: Enables the creation of `ArrayList(u0)` (an ArrayList of void), providing flexibility for empty element types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
ArrayList: Allow `ArrayList(u0)` to be created.
```

--------------------------------

TITLE: Fix Log2Int Type Construction (Zig)
DESCRIPTION: Corrects an issue in the construction of types for the `Log2Int` function, ensuring proper handling of integer types and their bitwise properties.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
// No specific code snippet provided, but the fix relates to Log2Int type construction.
```

--------------------------------

TITLE: Print "Hello, world!" to stdout in Zig
DESCRIPTION: This example demonstrates how to print "Hello, world!" to standard output using the `std.io.getStdOut().writer()` function in Zig. It requires importing the `std` module and handling potential errors during the printing process.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    try stdout.print("Hello, {s}!\n", .{ "world" });
}
```

LANGUAGE: Shell
CODE:
```
$ zig build-exe hello.zig
$ ./hello
Hello, world!
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: This Zig code snippet demonstrates how to read and print command-line arguments when compiled for the wasm32-wasi target. It uses `std.process.argsAlloc` to get the arguments and `std.debug.print` for output. The example requires a WASI-compatible runtime like wasmtime to execute.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args, 0..) |arg, i| {
        std.debug.print("{}: {s}
", .{ i, arg });
    }
}
```

LANGUAGE: shell
CODE:
```
$ zig build-exe wasi_args.zig -target wasm32-wasi
```

LANGUAGE: shell
CODE:
```
$ wasmtime wasi_args.wasm 123 hello
0: wasi_args.wasm
1: 123
2: hello
```

--------------------------------

TITLE: Add 0-length buffer checks to os.read and os.write
DESCRIPTION: Implements checks for zero-length buffers in os.read and os.write to prevent potential issues.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Add 0-length buffer checks to os.read and os.write
```

--------------------------------

TITLE: Zig: Function Parameter Type Inference
DESCRIPTION: Illustrates using `anytype` for function parameters in Zig, allowing types to be inferred at compile time. It shows how to use `@TypeOf` to determine the inferred type and includes tests for integer and i64 inputs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

fn addFortyTwo(x: anytype) @TypeOf(x) {
    return x + 42;
}

test "fn type inference" {
    try expect(addFortyTwo(1) == 43);
    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
    var y: i64 = 2;
    try expect(addFortyTwo(y) == 44);
    try expect(@TypeOf(addFortyTwo(y)) == i64);
}
```

--------------------------------

TITLE: Add atomic.Bool and atomic operations
DESCRIPTION: Adds atomic.Bool and exposes all atomic operations from atomic.Int, providing more comprehensive atomic types and operations for concurrent programming in Zig.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html



--------------------------------

TITLE: Zig Atomics: Store
DESCRIPTION: Demonstrates how to perform an atomic store operation in Zig using the `@atomicStore` builtin function, ensuring thread-safe writing to memory.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Atomic(u32) = .{ .value = 0 };
    @atomicStore(u32, &atomic_var, 20, .SeqCst);
    const value = @atomicLoad(u32, &atomic_var, .SeqCst);
    std.debug.print("New atomic value: {d}", .{value});
}
```

--------------------------------

TITLE: Zig: Inline Switch for Type Info
DESCRIPTION: Demonstrates using inline switch prongs with `@typeInfo` to check if a struct field is optional. The `isFieldOptional` function is unrolled by the compiler for each field.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;

fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T).Struct.fields;
    return switch (field_index) {
        // This prong is analyzed `fields.len - 1` times with `idx` being an
        // unique comptime known value each time.
        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].field_type) == .Optional,
        else => return error.IndexOutOfBounds,
    };
}

const Struct1 = struct { a: u32, b: ?u32 };

test "using @typeInfo with runtime values" {
    var index: usize = 0;
    try expect(!try isFieldOptional(Struct1, index));
    index += 1;
    try expect(try isFieldOptional(Struct1, index));
    index += 1;
    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent
// of this function: 
fn isFieldOptionalUnrolled(field_index: usize) !bool {
    return switch (field_index) {
        0 => false,
        1 => true,
        else => return error.IndexOutOfBounds,
    };
}
```

--------------------------------

TITLE: Zig Atomics: Store
DESCRIPTION: Demonstrates how to perform an atomic store operation in Zig using the `@atomicStore` builtin function, ensuring thread-safe writing to memory.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Atomic(u32) = .{ .value = 0 };
    @atomicStore(u32, &atomic_var, 20, .SeqCst);
    const value = @atomicLoad(u32, &atomic_var, .SeqCst);
    std.debug.print("New atomic value: {d}", .{value});
}
```

--------------------------------

TITLE: Zig: Inline Switch for Type Information
DESCRIPTION: Demonstrates using an inline switch prong to check if a struct field is optional by analyzing type information. It's used with `@typeInfo` to determine field properties at compile time.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;

fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T).Struct.fields;
    return switch (field_index) {
        // This prong is analyzed `fields.len - 1` times with `idx` being an
        // unique comptime known value each time.
        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].field_type) == .Optional,
        else => return error.IndexOutOfBounds,
    };
}

const Struct1 = struct { a: u32, b: ?u32 };

test "using @typeInfo with runtime values" {
    var index: usize = 0;
    try expect(!try isFieldOptional(Struct1, index));
    index += 1;
    try expect(try isFieldOptional(Struct1, index));
    index += 1;
    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent
// of this function: 
fn isFieldOptionalUnrolled(field_index: usize) !bool {
    return switch (field_index) {
        0 => false,
        1 => true,
        else => return error.IndexOutOfBounds,
    };
}
```

--------------------------------

TITLE: Zig C Interop: External Function Declaration
DESCRIPTION: Provides an example of declaring an external C function, `puts`, within Zig code. This is a fundamental step for interacting with C libraries.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: zig
CODE:
```
extern fn puts([*]const u8) void;
```

--------------------------------

TITLE: Zig: Peer Type Resolution for Empty Array and Slice
DESCRIPTION: Examines peer type resolution involving an empty array literal `[_]u8{}` and a slice. It checks the `.len` property of the resulting slice under different conditions, including compile-time.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
test "peer type resolution: [0]u8 and []const u8" {
    assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
    assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    comptime {
        assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
        assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    }
}
fn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {
    if (a) {
        return [_]u8{};
    }

    return slice[0..1];
}
```

--------------------------------

TITLE: Zig: Peer Resolve Array and Const Slice Comparison
DESCRIPTION: Tests the peer type resolution for arrays and slices, specifically when comparing them using mem.eql. It includes both runtime and compile-time assertions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
test "peer resolve arrays of different size to const slice" {
    assert(mem.eql(u8, boolToStr(true), "true"));
    assert(mem.eql(u8, boolToStr(false), "false"));
    comptime assert(mem.eql(u8, boolToStr(true), "true"));
    comptime assert(mem.eql(u8, boolToStr(false), "false"));
}
```

--------------------------------

TITLE: Zig Function Reflection with @typeInfo
DESCRIPTION: Demonstrates using `@typeInfo` for function reflection. This example checks the argument types and whether a function is variadic by inspecting the type information of the `expect` function.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "fn reflection" {
    try expect(@typeInfo(@TypeOf(expect)).Fn.args[0].arg_type.? == bool);
    try expect(@typeInfo(@TypeOf(expect)).Fn.is_var_args == false);
}
```

--------------------------------

TITLE: Zig Function Type Inference
DESCRIPTION: Illustrates using `anytype` for function parameters in Zig, allowing types to be inferred at compile time. Shows how to use `@TypeOf` and `@typeInfo` to inspect the inferred types. Includes tests for integer and i64 inputs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

fn addFortyTwo(x: anytype) @TypeOf(x) {
    return x + 42;
}

test "fn type inference" {
    try expect(addFortyTwo(1) == 43);
    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
    var y: i64 = 2;
    try expect(addFortyTwo(y) == 44);
    try expect(@TypeOf(addFortyTwo(y)) == i64);
}
```

--------------------------------

TITLE: Zig Noreturn Type Compatibility
DESCRIPTION: Explains the `noreturn` type in Zig and its compatibility with other types in control flow structures like `if` and `switch`. It also shows an example of using `noreturn` with an external function like `ExitProcess`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.0/index.html

LANGUAGE: zig
CODE:
```
fn foo(condition: bool, b: u32) {
    const a = if (condition) b else return;
    bar(a);
}

extern fn bar(value: u32);
```

LANGUAGE: zig
CODE:
```
pub extern "kernel32" stdcallcc fn ExitProcess(exit_code: c_uint) -> noreturn;

fn foo() {
    const value = bar() %% ExitProcess(1);
    assert(value == 1234);
}

fn bar() -> %u32 {
    return 1234;
}

const assert = @import("std").debug.assert;
```

--------------------------------

TITLE: Zig: Using Slices for Strings
DESCRIPTION: Demonstrates how Zig handles string literals as slices of constant unsigned 8-bit integers and performs string concatenation. It shows coercing pointer types to slices and using fmt.bufPrint for buffer printing.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const mem = std.mem;
const fmt = std.fmt;

test "using slices for strings" {
    // Zig has no concept of strings. String literals are const pointers
    // to null-terminated arrays of u8, and by convention parameters
    // that are "strings" are expected to be UTF-8 encoded slices of u8.
    // Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8
    const hello: []const u8 = "hello";
    const world: []const u8 = "";

    var all_together: [100]u8 = undefined;
    // You can use slice syntax with at least one runtime-known index on an
    // array to convert an array into a slice.
    var start: usize = 0;
    _ = &start;
    const all_together_slice = all_together[start..];
    // String concatenation example.
    const hello_world = try fmt.bufPrint(all_together_slice, "{s} {s}", .{ hello, world });

    // Generally, you can use UTF-8 and not worry about whether something is a
    // string. If you don't need to deal with individual characters, no need
    // to decode.
    try expect(mem.eql(u8, hello_world, "hello "));
}
```

--------------------------------

TITLE: Zig Type Reflection
DESCRIPTION: Details the @typeInfo function in Zig, used for type reflection. It provides information about a given type T. For structs, unions, enums, and error sets, field order is guaranteed.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
    @typeInfo(comptime T: type) @import("std").builtin.TypeInfo
```

--------------------------------

TITLE: Zig: Decl Literals for Struct Field Initialization
DESCRIPTION: Shows the practical application of 'decl literals' in initializing struct fields, avoiding redundant type specifications by directly referencing default values.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const S = struct {
    const default = S{};
    value: i32 = 0,
};

fn main() void {
    const instance = S{
        .value = .S.default.value + 1,
    };
    _ = instance;
}
```

--------------------------------

TITLE: Linking: LLD invocation as child process
DESCRIPTION: Addresses issues with the LLD library by invoking it as a child process instead of using its library code directly. This circumvents problems with LLD's `exit()` calls and global state, improving Zig's integration with LLD.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: Zig
CODE:
```
// Conceptual Zig code demonstrating process invocation for LLD
const std = @import("std");

const lld_path = "zig_lld_wrapper"; // Path to a wrapper script or executable
const args = &[_][]const u8{
    "lld",
    "--flavor", "gnu",
    // ... other LLD arguments ...
};

try std.ChildProcess.exec(.{ .argv = args });
```

--------------------------------

TITLE: Zig Tuple Literal and Operations
DESCRIPTION: Shows how to create and manipulate tuples in Zig, which are anonymous structs with numeric field names. Demonstrates concatenation, repetition, indexing, and iteration.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "tuple" {
    const values = .{ 
        @as(u32, 1234),
        @as(f64, 12.34),
        true,
        "hi",
    } ++ .{false} ** 2;
    try expect(values[0] == 1234);
    try expect(values[4] == false);
    inline for (values) |v, i| {
        if (i != 2) continue;
        try expect(v);
    }
    try expect(values.len == 6);
    try expect(values.@"3"[0] == 'h');
}
```

--------------------------------

TITLE: Zig Tuple Literal and Operations
DESCRIPTION: Shows how to create and manipulate tuples in Zig, which are anonymous structs with numeric field names. Demonstrates concatenation, repetition, indexing, and iteration.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "tuple" {
    const values = .{ 
        @as(u32, 1234),
        @as(f64, 12.34),
        true,
        "hi",
    } ++ .{false} ** 2;
    try expect(values[0] == 1234);
    try expect(values[4] == false);
    inline for (values) |v, i| {
        if (i != 2) continue;
        try expect(v);
    }
    try expect(values.len == 6);
    try expect(values.@"3"[0] == 'h');
}
```

--------------------------------

TITLE: Zig Function Type Inference
DESCRIPTION: Illustrates using `anytype` for function parameters in Zig, allowing types to be inferred at compile time. Shows how to use `@TypeOf` and `@typeInfo` to inspect the inferred types. Includes tests for integer and i64 inputs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

fn addFortyTwo(x: anytype) @TypeOf(x) {
    return x + 42;
}

test "fn type inference" {
    try expect(addFortyTwo(1) == 43);
    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
    var y: i64 = 2;
    try expect(addFortyTwo(y) == 44);
    try expect(@TypeOf(addFortyTwo(y)) == i64);
}
```

--------------------------------

TITLE: Fix setsockopt Syscall on Linux in Zig
DESCRIPTION: Resolves an issue with the `setsockopt` syscall on Linux. This ensures that socket options can be set correctly, improving network programming.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: Zig
CODE:
```
/*
* Duncan fixed the setsockopt syscall on linux.
*/
```

--------------------------------

TITLE: Zig Libc Detection on NixOS
DESCRIPTION: Demonstrates the output of the `zig libc` command on a NixOS system, showing include and library directories for glibc.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: bash
CODE:
```
$ zig libc
# The directory that contains `stdlib.h`.
# On POSIX-like systems, include directories be found with: `cc -E -Wp,-v -xc /dev/null`
include_dir=/nix/store/q2q1sg5sljia8sihhwcpbxir70yw33bw-glibc-2.27-dev/include
# The system-specific include directory. May be the same as `include_dir`.
# On Windows it's the directory that includes `vcruntime.h`.
# On POSIX it's the directory that includes `sys/errno.h`.
sys_include_dir=/nix/store/q2q1sg5sljia8sihhwcpbxir70yw33bw-glibc-2.27-dev/include

# The directory that contains `crt1.o`.
# On POSIX, can be found with `cc -print-file-name=crt1.o`.
# Not needed when targeting MacOS.
crt_dir=/nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib

# The directory that contains `vcruntime.lib`.
# Only needed when targeting MSVC on Windows.
msvc_lib_dir=

# The directory that contains `kernel32.lib`.
# Only needed when targeting MSVC on Windows.
kernel32_lib_dir=
```

--------------------------------

TITLE: Zig Built-in Function: @atomicLoad
DESCRIPTION: The `@atomicLoad` builtin function performs an atomic load operation on a memory location. It ensures that the read operation is indivisible and visible across threads.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Int(u32) = undefined;
    std.atomic.store(&atomic_var, 123, .SeqCst);

    const value = @atomicLoad(&atomic_var, .SeqCst);

    std.debug.print("Atomic value: {d}\\n", .{
        value,
    });
}
```

--------------------------------

TITLE: Zig Target Support - Tier 1
DESCRIPTION: Targets with Tier 1 support are fully integrated and automatically tested. The standard library is expected to work without issues, though some specific APIs might still return an 'Unsupported OS' error. Linking with external libraries like libc might be necessary to fill any gaps.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
x86_64




x86






aarch64






arm






mips64


N/A
N/A


N/A
N/A
mips

N/A
N/A


N/A
N/A
riscv64

N/A


N/A

sparcv9

N/A


N/A
N/A
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Performs a bitwise AND operation. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
a & b
a &=
b
```

--------------------------------

TITLE: Zig Builtin: @atomicLoad
DESCRIPTION: The `@atomicLoad` builtin function performs an atomic load operation on a memory location, ensuring that the read is indivisible and consistent across threads.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
var counter: atomic(u32) = 0;
const value = @atomicLoad(&counter, .SeqCst);
// value holds the current atomic value of counter
```

--------------------------------

TITLE: Self-Hosted Linker and MachO Improvements in Zig
DESCRIPTION: Progress has been made on the self-hosted linker for ELF and COFF formats, though they are not yet generally usable. The MachO linker has been significantly rewritten for incremental linking, improving efficiency by optimizing section layout and file space allocation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
// Self-hosted linker progress on ELF and COFF.
// Incremental MachO linker rewrite: Zig lays out incrementally linked binary with one section per segment.
// Allows Zig to use quick file space allocation algorithm.
// Disassociates file offsets from allocated virtual memory addresses.
// Enables reordering and moving sections without affecting virtual memory space ordering.
// Handles section growth efficiently without extensive virtual address recalculations.
```

--------------------------------

TITLE: Zig std.os.posixOpen Error Handling
DESCRIPTION: Added error.DeviceBusy as a possible result of std.os.posixOpen. This error can occur when attempting to open a TTY file descriptor for writing that is already in use.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.os.posixOpen
```

--------------------------------

TITLE: Fix Zig Test Case for std.io.InStream
DESCRIPTION: Corrects an erroneous test case related to `std.io.InStream`. This ensures the accuracy of the test suite and the reliability of the `InStream` functionality.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
/* LemonBoy fixed erroneous test case regarding {#syntax#}std.io.InStream{#endsyntax#}. */
```

--------------------------------

TITLE: Write to Standard Output in Zig
DESCRIPTION: Demonstrates how to write a string to standard output using Zig's file I/O. It includes error handling for potential pipe failures during printing. The example shows compilation and execution commands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    // If this program encounters pipe failure when printing to stdout, exit
    // with an error.
    try std.io.getStdOut().writer().writeAll("Hello, world!\n");
}
```

--------------------------------

TITLE: Zig Progress Protocol: Child Process Communication
DESCRIPTION: This snippet demonstrates how the Zig Progress Protocol facilitates communication between parent and child processes. It highlights the use of environment variables and the `std.process.Child` API for progress reporting.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.13.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// ... inside a function or method ...

const child = try std.process.Child.spawn(.{
    .argv = &[_][]const u8{"child_program"},
    // ... other options ...
});

// Attach the child's progress node to the parent's progress tree
// This assumes 'child.progress_node' is a field that can be set.
// The exact mechanism depends on the context where this is used.
// child.progress_node = parent_progress_node;

try child.wait();

```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Details the bitwise AND operator '&' for integers in Zig. It explains that the operation invokes Peer Type Resolution for the operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
a & b
a &= b
```

--------------------------------

TITLE: Zig Build System: Foreign Target Execution Options
DESCRIPTION: The Zig build system provides several command-line switches to enable cross-target testing and execution. These include integrations with Darling, QEMU, Wine, Rosetta, and Wasmtime, allowing macOS programs on Linux, foreign-architecture programs on Linux, Windows programs on Linux, x86_64 on ARM64 macOS, and WASI binaries respectively.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
// Enable Darling for macOS programs on Linux hosts
// build.installDependency(..., .{-fling});

// Enable QEMU for foreign-architecture programs on Linux hosts
// build.installDependency(..., .{-fqemu});

// Provide glibc runtimes for QEMU integration
// build.installDependency(..., .{"--glibc-runtimes", "/path/to/glibc"});

// Rely on Rosetta for x86_64 programs on ARM64 macOS hosts
// build.installDependency(..., .{-frosetta});

// Enable Wasmtime for WASI binaries
// build.installDependency(..., .{-fwasmtime});

// Enable Wine for Windows programs on Linux hosts
// build.installDependency(..., .{-fwine});

// Prevent cross-target failure from failing the build
// build.skip_foreign_checks = true;

```

--------------------------------

TITLE: Zig @alignOf Example
DESCRIPTION: Explains how to use @alignOf to get the required byte alignment for a type according to the C ABI for the current target. This is useful for ensuring correct memory layout.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.1/index.html

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;

comptime {
    assert(@alignOf(u32) <= @sizeOf(u32));
    assert(&u32 == &align(@alignOf(u32)) u32);
}
```

--------------------------------

TITLE: Zig Builtin: @atomicStore
DESCRIPTION: Demonstrates the `@atomicStore` builtin function in Zig for atomically storing a value to memory. This ensures that writes are visible to other threads correctly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Atomic(u32) = std.atomic.Atomic(u32){ .value = 0 };
    @atomicStore(u32, &atomic_var, 20, .SeqCst);
    const value = std.atomic.load(u32, &atomic_var, .SeqCst);
    std.debug.print("Stored value: {d}\n", .{value});
}
```

--------------------------------

TITLE: Zig @exp Base-e Exponential Function
DESCRIPTION: Computes the base-e exponential (e^x) for floating-point numbers. Supports scalar and vector types, utilizing hardware instructions when available. Some float operations might not be fully implemented across all types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: Zig
CODE:
```
    @exp(value: var) @TypeOf(value)
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Covers the bitwise AND operator (&) for integers in Zig, noting that it invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
a & b
a &= b

-- Relevant Types:
* Integers

-- Description:
Bitwise AND.
* Invokes Peer Type Resolution for the operands.

-- Example:
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Generic Call Demo with Type Equality
DESCRIPTION: Demonstrates a generic function call that previously passed with Zig 0.10.x but fails in 0.11.0 due to changes in type equality behavior. It highlights the potential unreliability of relying on type equality for generic instances.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "generic call demo" {
    const a = foo(i32, 1234);
    const b = foo(i32, 5678);
    try expect(@TypeOf(a) == @TypeOf(b));
}

fn foo(comptime T: type, init: T) struct {
    x: T
} {
    return .{ .x = init };
}
```

--------------------------------

TITLE: Zig: Base-e Exponential with @exp
DESCRIPTION: Explains the `@exp` function for calculating the base-e exponential of floating-point numbers and vectors. It notes hardware acceleration and potential limitations for specific float types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html



--------------------------------

TITLE: Zig Struct with Methods and Delegation
DESCRIPTION: Demonstrates a Zig struct 'Foo' with member variables, methods, and nested functions. It showcases method delegation and the use of comptime for creating functions with parameters.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

const Foo = struct {
    a: u64 = 10,

    fn one(self: Foo) u64 {
        return self.a + 1;
    }

    const two = __two;
    fn __two(self: Foo) u64 {
        return self.a + 2;
    }

    const three = __three;
    fn __three(self: Foo) u64 {
        return self.a + 3;
    }

    const four = custom(Foo, 4);
};

fn custom(comptime T: type, comptime num: u64) fn (T) u64 {
    return struct {
        fn function(self: T) u64 {
            return self.a + num;
        }
    }.function;
}

test "fn delegation" {
    const foo = Foo{};
    expect(foo.one() == 11);
    expect(foo.two() == 12);
    expect(foo.three() == 13);
    expect(foo.four() == 14);
}
```

--------------------------------

TITLE: Zig Builtin: @atomicStore
DESCRIPTION: Demonstrates the `@atomicStore` builtin function in Zig for atomically storing a value to memory. This ensures that writes are visible to other threads correctly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Atomic(u32) = std.atomic.Atomic(u32){ .value = 0 };
    @atomicStore(u32, &atomic_var, 20, .SeqCst);
    const value = std.atomic.load(u32, &atomic_var, .SeqCst);
    std.debug.print("Stored value: {d}\n", .{value});
}
```

--------------------------------

TITLE: Windows OVERLAPPED and OVERLAPPED_ENTRY Fixes
DESCRIPTION: Updates the Windows target by fixing the `OVERLAPPED` structure and adding the `OVERLAPPED_ENTRY` structure, improving asynchronous I/O handling.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Windows: fix `OVERLAPPED`, add `OVERLAPPED_ENTRY`.
```

--------------------------------

TITLE: Custom OS Support Improvements
DESCRIPTION: Details enhancements for using Zig to build custom operating systems. This includes making Linux syscalls accessible when targeting non-Linux, overriding `MAX_PATH_BYTES`, and refactoring standard library components like iovec and log levels.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
MAX_PATH_BYTES
root.os.panic
```

--------------------------------

TITLE: Zig Inline Switch with @typeInfo
DESCRIPTION: Demonstrates using Zig's inline switch with @typeInfo to check if struct fields are optional. The prong is analyzed multiple times with unique comptime-known values.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;

fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T).Struct.fields;
    return switch (field_index) {
        // This prong is analyzed `fields.len - 1` times with `idx` being a
        // unique comptime-known value each time.
        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].type) == .Optional,
        else => return error.IndexOutOfBounds,
    };
}

const Struct1 = struct { a: u32, b: ?u32 };

test "using @typeInfo with runtime values" {
    var index: usize = 0;
    try expect(!try isFieldOptional(Struct1, index));
    index += 1;
    try expect(try isFieldOptional(Struct1, index));
    index += 1;
    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent
// of this function:
fn isFieldOptionalUnrolled(field_index: usize) !bool {
    return switch (field_index) {
        0 => false,
        1 => true,
        else => return error.IndexOutOfBounds,
    };
}
```

--------------------------------

TITLE: Zig: Integer to Integer Cast Example
DESCRIPTION: Demonstrates how to use @intCast to convert an i32 to a usize. This example highlights how Zig enforces type safety, requiring explicit conversion when the type of the variable changes, such as from an integer to a pointer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
fn foo(x: i32) void {
    var i = @intCast(usize, x);
}
```

--------------------------------

TITLE: Zig: Link System LibSystem for Mach-O Native Builds
DESCRIPTION: This update addresses Mach-O file linking by ensuring the system libSystem is linked when building natively. This is important for correct execution of native applications on macOS and other Darwin-based systems.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
#[9242](https://github.com/ziglang/zig/issues/9242)
```

--------------------------------

TITLE: Zig: Base-e Exponential with @exp
DESCRIPTION: Explains the `@exp` function for calculating the base-e exponential of floating-point numbers and vectors. It notes hardware acceleration and potential limitations for specific float types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html



--------------------------------

TITLE: Zig: Resolve Peer Types with Pointers and Slices
DESCRIPTION: Demonstrates Zig's peer type resolution for pointers and slices, including handling errors and empty arrays. This snippet showcases how Zig manages type compatibility in complex scenarios involving pointers and slices.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
fn peerTypeEmptyArrayAndSliceAndError(a: bool, slice: []u8) anyerror![]u8 {
        if (a) {
            return &[_]u8{};
        }
    
        return slice[0..1];
    }
    
    test "peer type resolution: *const T and ?*T" {
        const a = @intToPtr(*const usize, 0x123456780);
        const b = @intToPtr(?*usize, 0x123456780);
        expect(a == b);
        expect(b == a);
    }
```

--------------------------------

TITLE: Zig Translate-C: Handle NAN and INFINITY Macros
DESCRIPTION: Support for `NAN` and `INFINITY` macros has been added to `zig translate-c`, ensuring these common floating-point constants are translated correctly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: C
CODE:
```
* Handle NAN and INFINITY macros ([#9468](https://github.com/ziglang/zig/issues/9468)).
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Performs a bitwise AND operation for integers. Invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
a & b
a &= b
```

--------------------------------

TITLE: Fix C ABI Parameter Handling for Structs in Zig
DESCRIPTION: Corrects the handling of C ABI parameters that are split across multiple registers when flattening structures. This ensures accurate parameter passing for complex types according to the C ABI.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Fix handling of C ABI parameters split in multiple regs by taking into account the increased number of parameters when flattening a structure into one or more SSE registers ([#9061](https://github.com/ziglang/zig/issues/9061)).
```

--------------------------------

TITLE: Migrate RemoveDir Step to Accept LazyPath
DESCRIPTION: The `RemoveDir` step in Zig's build system now expects a `LazyPath` instead of a `[]const u8`. This change requires updating how temporary paths are passed to the `addRemoveDirTree` function.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: zig
CODE:
```
-        const cleanup = b.addRemoveDirTree(tmp_path);
+        const cleanup = b.addRemoveDirTree(.{ .cwd_relative = tmp_path });
```

--------------------------------

TITLE: Zig: Support read-write output constraints in assembly (LLVM backend)
DESCRIPTION: This feature adds support for read-write output constraints in inline assembly within the Zig LLVM backend. This allows for more complex and efficient inline assembly usage by enabling output operands that can be both read and written.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Support read-write output constraints in assembly
```

--------------------------------

TITLE: Zig Noreturn Type Compatibility
DESCRIPTION: Explains that the `noreturn` type in Zig is compatible with all other types when resolving types in conditional constructs like `if` or `switch`. The example shows a function `foo` where the `else` branch returns, making it `noreturn`. This allows the `if` statement to be assigned to a variable `a` without type conflicts.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: Zig
CODE:
```
fn foo(condition: bool, b: u32) void {
    const a = if (condition) b else return;
    @panic("do something with a");
}
test "noreturn" {
    foo(false, 1);
}
```

LANGUAGE: Shell
CODE:
```
$ zig test test.zig
Test [1/1] test "noreturn"... 

All 1 tests passed.
```

--------------------------------

TITLE: Zig Build: Restore Default Stdin Behavior for RunStep
DESCRIPTION: Explains how to revert the `RunStep.stdin_behavior` to its previous default of `.Ignore`. The current default is `.Inherit`, and this code snippet shows how to explicitly set it back.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.build.RunStep.stdin_behavior = .Ignore;
```

--------------------------------

TITLE: Zig Generic List Data Structure Implementation
DESCRIPTION: Demonstrates how Zig's `comptime` feature enables the creation of generic data structures without special syntax. This example defines a `List` type factory that returns a struct with `items` and `len` fields, which can be instantiated with any type `T`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
    fn List(comptime T: type) type {
        return struct {
            items: []T,
            len: usize,
        };
    }
    
    // The generic List data structure can be instantiated by passing in a type:
    var buffer: [10]i32 = undefined;
    var list = List(i32){
        .items = &buffer,
        .len = 0,
    };
```

--------------------------------

TITLE: Zig @TypeOf with multiple parameters
DESCRIPTION: Illustrates the use of `@TypeOf` with multiple parameters, enabling Peer Type Resolution. This allows the `max` function to correctly infer the return type based on the types of its two arguments, `x` and `y`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
// std.math.max
pub fn max(x: var, y: var) @TypeOf(x, y) {
    return if (x > y) x else y;
}
```

--------------------------------

TITLE: Importing Built-in Zig Features
DESCRIPTION: Shows an example of importing and using various built-in features from the 'std.builtin' module, including endianness, output mode, link mode, and architecture details.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
usingnamespace @import("std").builtin;

pub const endian = Endian.Little;
pub const output_mode = OutputMode.Obj;
pub const link_mode = LinkMode.Static;
pub const is_test = false;
pub const single_threaded = false;
/// Deprecated: use `std.Target.cpu.arch`
pub const arch = Arch.x86_64;
pub const abi = Abi.musl;
pub const cpu: Cpu = Cpu{
    .arch = .x86_64,
    .model = &Target.x86.cpu.haswell,
    .features = Target.x86.featureSet(&[_]Target.x86.Feature{
        ."64bit",
        ."aes",
        ."avx",
        ."avx2",
        ."bmi",
        ."bmi2",
        ."cmov",
        ."cx16",
        ."cx8",
        ."ermsb",
        ."f16c",
        ."false_deps_lzcnt_tzcnt",
        ."false_deps_popcnt",
        ."fast_scalar_fsqrt",
        ."fast_shld_rotate",
        ."fast_variable_shuffle",
        ."fma",
        ."fsgsbase",
        ."fxsr",
        ."idivq_to_divl",
        ."invpcid",
        ."lzcnt",
        ."macrofusion",
        ."merge_to_threeway_branch",
        ."mmx",
        ."movbe",
        ."nopl",
        ."pclmul",
        ."popcnt",
        ."rdrnd",
    }),
};
```

--------------------------------

TITLE: Zig: Write LC_FUNCTION_START Data in Mach-O
DESCRIPTION: This update ensures that the `LC_FUNCTION_START` load command data is correctly written into Mach-O files. This information is used by debuggers and other tools to identify function entry points.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
macho: write out `LC_FUNCTION_START` data.
```

--------------------------------

TITLE: Zig: Using Namespace with Standard Library
DESCRIPTION: Demonstrates how to use the `usingnamespace` declaration to import all public declarations from the Zig standard library into a struct. This allows direct access to standard library functions, such as `testing.expect`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
test "using std namespace" {
    const S = struct {
        usingnamespace @import("std");
    };
    try S.testing.expect(true);
}
```

--------------------------------

TITLE: Zig @exp Function
DESCRIPTION: Calculates the base-e exponential of a floating-point number using hardware instructions when available. Supports f32 and f64 types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: zig
CODE:
```
@exp(comptime T: type, value: T) T
```

--------------------------------

TITLE: Zig Function Reflection Test
DESCRIPTION: Provides a Zig test case demonstrating function reflection. It uses '@typeInfo' to inspect function parameters and return types, and checks for generic properties of functions like 'math.Log2Int'.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const math = std.math;
const testing = std.testing;

test "fn reflection" {
    try testing.expect(@typeInfo(@TypeOf(testing.expect))."fn".params[0].type.? == bool);
    try testing.expect(@typeInfo(@TypeOf(testing.tmpDir))."fn".return_type.? == testing.TmpDir);

    try testing.expect(@typeInfo(@TypeOf(math.Log2Int))."fn".is_generic);
}
```

LANGUAGE: shell
CODE:
```
$ zig test test_fn_reflection.zig
1/1 test_fn_reflection.test.fn reflection...OK
All 1 tests passed.
```

--------------------------------

TITLE: Zig Bitwise XOR Operator
DESCRIPTION: Performs a bitwise XOR operation for integers. Invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
a ^ b
a ^= b
```

--------------------------------

TITLE: Zig Bitwise XOR Operator
DESCRIPTION: Covers the bitwise XOR operator '^' for integers in Zig. It mentions that the operation invokes Peer Type Resolution for the operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
a ^ b
a ^= b
```

--------------------------------

TITLE: Zig UEFI Protocol Definitions
DESCRIPTION: Provides access to UEFI protocol definitions within Zig's standard library. This allows for cleaner integration with UEFI services and functionalities.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.os.uefi.protocols
```

--------------------------------

TITLE: Zig: Generate Foos with Potential Leak
DESCRIPTION: This Zig function `genFoos` attempts to allocate and initialize an array of `Foo` structs. It uses `errdefer` for cleanup, but a leak occurs if the loop terminates early due to an error after allocating `foo.data` but before the `errdefer` for `foo.data` is properly handled in all cases. The test case `genFoos` specifically triggers this leak by requesting more foos than allowed.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const Allocator = std.mem.Allocator;

const Foo = struct {
    data: *u32
};

fn getData() !u32 {
    return 666;
}

fn genFoos(allocator: Allocator, num: usize) ![]Foo {
    var foos = try allocator.alloc(Foo, num);
    errdefer allocator.free(foos);

    for (foos) |*foo| {
        foo.data = try allocator.create(u32);
        // This errdefer does not last between iterations
        errdefer allocator.destroy(foo.data);

        // The data for the first 3 foos will be leaked
        if(i >= 3) return error.TooManyFoos;

        foo.data.* = try getData();
    }

    return foos;
}

test "genFoos" {
    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));
}
```

--------------------------------

TITLE: Zig @bytesToSlice: Convert Bytes to Slice
DESCRIPTION: Converts a slice or array of bytes into a slice of a specified element type. The function ensures that the number of bytes is evenly divisible by the size of the element type to avoid undefined behavior. It preserves pointer properties from the input byte slice.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: zig
CODE:
```
comptime Element: type, bytes: []u8) []Element
```

--------------------------------

TITLE: Zig: Initialize Struct Fields with Decl Literals
DESCRIPTION: Shows how to use decl literals in Zig for initializing struct fields, including calling functions that return error unions using 'try'. This provides a cleaner way to initialize complex types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.14.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

const ArrayListUnmanaged = std.ArrayListUnmanaged;

var list = ArrayListUnmanaged([]u8).init(std.heap.page_allocator);

const MyStruct = struct {
    data: []u8,
};

var my_struct = MyStruct{
    .data = ArrayListUnmanaged([]u8).init(std.heap.page_allocator).items,
};

```

--------------------------------

TITLE: Zig Inline Assembly for System Calls (x86_64 Linux)
DESCRIPTION: Provides an example of using Zig's inline assembly feature to directly interact with the operating system via system calls. This implementation demonstrates writing 'hello world' to stdout and exiting the process on x86_64 Linux.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
pub fn main() noreturn {
    const msg = "hello world\\n";
    _ = syscall3(SYS_write, STDOUT_FILENO, @intFromPtr(msg), msg.len);
    _ = syscall1(SYS_exit, 0);
    unreachable;
}

pub const SYS_write = 1;
pub const SYS_exit = 60;

pub const STDOUT_FILENO = 1;

pub fn syscall1(number: usize, arg1: usize) usize {
    return asm volatile ("syscall"
        : [ret] "=={rax}" (-> usize),
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
        : "rcx", "r11"
    );
}

pub fn syscall3(number: usize, arg1: usize, arg2: usize, arg3: usize) usize {
    return asm volatile ("syscall"
        : [ret] "=={rax}" (-> usize),
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
          [arg2] "{rsi}" (arg2),
          [arg3] "{rdx}" (arg3),
        : "rcx", "r11"
    );
}
```

--------------------------------

TITLE: Zig std.atomic.Int.set Method
DESCRIPTION: Added the .set method to std.atomic.Int for atomic integer operations. This allows for safe concurrent modification of integer values.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.atomic.Int.set
```

--------------------------------

TITLE: Add setitimer and getitimer syscalls to std.os.linux
DESCRIPTION: Integrates the setitimer and getitimer syscalls into the std.os.linux module for timer management.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.1/release-notes.html

LANGUAGE: Zig
CODE:
```
std.os.linux: Add setitimer and getitimer syscalls
```

--------------------------------

TITLE: Zig Inline Assembly for syscall3 (write)
DESCRIPTION: Illustrates the use of inline assembly in Zig to perform a `syscall3` operation, specifically for writing to standard output on x86_64 Linux, including necessary constants and function signatures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: Zig
CODE:
```
pub fn main() noreturn {
    const msg = "hello world\n";
    _ = syscall3(SYS_write, STDOUT_FILENO, @ptrToInt(msg), msg.len);
    _ = syscall1(SYS_exit, 0);
    unreachable;
}

pub const SYS_write = 1;
pub const SYS_exit = 60;

pub const STDOUT_FILENO = 1;

pub fn syscall1(number: usize, arg1: usize) usize {
    return asm volatile ("syscall"
        : [ret] "=R" (-> usize) // Use =R for output register
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1)
        : "rcx", "r11"
    );
}

pub fn syscall3(number: usize, arg1: usize, arg2: usize, arg3: usize) usize {
    // Assuming a similar structure for syscall3, though the example is cut off
    return asm volatile ("syscall"
        : [ret] "=R" (-> usize)
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
          [arg2] "{rsi}" (arg2),
          [arg3] "{rdx}" (arg3)
        : "rcx", "r11"
    );
}
```

--------------------------------

TITLE: Zig CLI Allocation with ArenaAllocator
DESCRIPTION: Demonstrates using ArenaAllocator for command-line applications where all memory can be freed at once. It initializes an ArenaAllocator, allocates an i32, and prints it. The arena is deinitialized at the end, freeing all associated memory.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.direct_allocator);
    defer arena.deinit();

    const allocator = &arena.allocator;

    const ptr = try allocator.create(i32);
    std.debug.warn("ptr={*}\n", ptr);
}
```

--------------------------------

TITLE: Zig Language Reference: Fix Array/Pointer/Slice Coercion
DESCRIPTION: Corrects the section in the Zig language reference that describes array, pointer, and slice type coercion, addressing an issue identified in [#9392](https://github.com/ziglang/zig/issues/9392).

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: zig
CODE:
```
Fix array/pointer/slice type coercion section ([#9392](https://github.com/ziglang/zig/issues/9392)).
```

--------------------------------

TITLE: Zig Base-e Exponential Function
DESCRIPTION: The `@exp` function in Zig computes the base-e exponential of a floating-point number, using hardware instructions if available. It handles both floats and vectors of floats, though some float types may have incomplete support for this operation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
@exp(value: anytype) @TypeOf(value)
```

--------------------------------

TITLE: Zig Function Type Reflection
DESCRIPTION: Demonstrates how to use Zig's reflection capabilities to inspect function types, specifically checking the return type and whether a function uses variable arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "fn reflection" {
    expect(@typeInfo(@TypeOf(expect)).Fn.return_type.? == void);
    expect(@typeInfo(@TypeOf(expect)).Fn.is_var_args == false);
}
```

--------------------------------

TITLE: Exponential with @exp
DESCRIPTION: Describes the @exp function for calculating the base-e exponential of floating-point numbers and vectors of floats, including notes on hardware acceleration and potential limitations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
@exp(value: anytype) @TypeOf(value)
```

--------------------------------

TITLE: Zig: Peer Type Resolution with Error Union Slice
DESCRIPTION: Demonstrates peer type resolution involving an empty array, a slice, and an error union of a slice. It shows how Zig handles these complex types during resolution.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;

test "peer type resolution: [0]u8, []const u8, and anyerror![]u8" {
    {
        var data = "hi";
        const slice = data[0..];
        assert((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);
        assert((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);
    }
    comptime {
        var data = "hi";
        const slice = data[0..];
        assert((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);

```

--------------------------------

TITLE: Macho and Type Import Changes
DESCRIPTION: This snippet includes fixes for typos in Mach-O constants definitions and a change in how built-in modules are imported, from `@import("builtin")` to `std.builtin`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
macho: fix typos in consts defs
change `@import("builtin")` to `std.builtin`
```

--------------------------------

TITLE: Zig: Improved C Pointers with Optional Syntax
DESCRIPTION: Shows an improved C function prototype in Zig with correct pointer types, demonstrating that the optional syntax for C pointers remains functional. This highlights Zig's flexibility in handling C interop, even with refined type definitions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
pub extern fn getenv(name: [*]const u8) ?[*]]u8;
// note: this is just a demo of C pointers with optional syntax. // std.process has better API for getenv.
test "C pointers with optional syntax" {
    const ptr1 = getenv(c"HOME").?; // don't do this 
    const ptr2 = getenv(c"HOME") orelse return error.Homeless; // OK
    if (getenv(c"HOME")) |ptr3| {
        // also OK
    }
    const ptr4 = getenv(c"HOME");
    if (ptr4 == null) {
        // also works
    }
}
```

--------------------------------

TITLE: Zig @exp for Base-e Exponential Function
DESCRIPTION: Details the @exp built-in function for computing the base-e exponential of a floating-point number. It notes the potential use of hardware instructions and support for floats and float vectors.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html



--------------------------------

TITLE: Zig Formatted Printing with Tuples
DESCRIPTION: Demonstrates how Zig uses tuples for formatted printing parameters, replacing variadic functions. This example prints 'Hello, World!' using `std.debug.warn` with a tuple argument.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    std.debug.warn("Hello, {}\n", .{"World!"});
}
```

--------------------------------

TITLE: Zig: Pointer Arithmetic with Many-Item Pointers and Slices
DESCRIPTION: Illustrates pointer arithmetic using many-item pointers ('[*]T') and highlights the potential issues when performing arithmetic directly on slices without updating their length. It shows how to correctly increment a many-item pointer and access elements using indexing.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "pointer arithmetic with many-item pointer" {
    const array = [_]i32{ 1, 2, 3, 4 };
    var ptr: [*]const i32 = &array;

    try expect(ptr[0] == 1);
    ptr += 1;
    try expect(ptr[0] == 2);

    // slicing a many-item pointer without an end is equivalent to
    // pointer arithmetic: `ptr[start..] == ptr + start`
    try expect(ptr[1..] == ptr + 1);
}

test "pointer arithmetic with slices" {
    var array = [_]i32{ 1, 2, 3, 4 };
    var length: usize = 0; // var to make it runtime-known
    _ = &length; // suppress 'var is never mutated' error
    var slice = array[length..array.len];

    try expect(slice[0] == 1);
    try expect(slice.len == 4);

    slice.ptr += 1;
    // now the slice is in an bad state since len has not been updated

    try expect(slice[0] == 2);
    try expect(slice.len == 4);
}
```

--------------------------------

TITLE: Windows and Darwin Dynamic Library Loading
DESCRIPTION: Fixes for Windows dynamic library loading and addition of loading support for Darwin (macOS).

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const lib = std.os.dlopen("libexample.so", .{}
);
```

--------------------------------

TITLE: Zig Bitwise OR Operator
DESCRIPTION: Explains the bitwise OR operator (|) for integers in Zig, stating that it invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
a | b
a |= b

-- Relevant Types:
* Integers

-- Description:
Bitwise OR.
* Invokes Peer Type Resolution for the operands.

-- Example:
0b010 | 0b100 == 0b110
```

--------------------------------

TITLE: Zig Tuple Syntax
DESCRIPTION: Illustrates Zig's tuple syntax, which allows omitting the type from array literals. Tuples are presented as structs with auto-numbered field names, enabling array-like access using quoted numbers as field identifiers. Examples show direct population of arrays and accessing tuple elements.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "tuple syntax" {
    var array: [4]u8 = .{11, 22, 33, 44};
    expect(array[0] == 11);
    expect(array[1] == 22);
    expect(array[2] == 33);
    expect(array[3] == 44);
}
```

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous tuple" {
    dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: var) void {
    expect(args.@"0" == 1234);
    expect(args.@"1" == 12.34);
    expect(args.@"2");
    expect(args.@"3"[0] == 'h');
    expect(args.@"3"[1] == 'i');
}
```

--------------------------------

TITLE: Zig WASI Command Line Argument Example
DESCRIPTION: A Zig program demonstrating the use of the WASI target to access and print command-line arguments using the standard library.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    const args = try std.process.argsAlloc(std.heap.wasm_allocator);
    defer std.process.argsFree(std.heap.wasm_allocator, args);

    for (args) |arg, i| {
        std.debug.warn("{}: {}
", i, arg);
    }
}
```

--------------------------------

TITLE: Exponential with @exp
DESCRIPTION: Describes the @exp function for calculating the base-e exponential of floating-point numbers and vectors of floats, including notes on hardware acceleration and potential limitations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
@exp(value: anytype) @TypeOf(value)
```

--------------------------------

TITLE: Zig: Pointer Arithmetic with Many-Item Pointers and Slices
DESCRIPTION: Illustrates pointer arithmetic using many-item pointers ('[*]T') and highlights the potential issues when performing arithmetic directly on slices without updating their length. It shows how to correctly increment a many-item pointer and access elements using indexing.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "pointer arithmetic with many-item pointer" {
    const array = [_]i32{ 1, 2, 3, 4 };
    var ptr: [*]const i32 = &array;

    try expect(ptr[0] == 1);
    ptr += 1;
    try expect(ptr[0] == 2);

    // slicing a many-item pointer without an end is equivalent to
    // pointer arithmetic: `ptr[start..] == ptr + start`
    try expect(ptr[1..] == ptr + 1);
}

test "pointer arithmetic with slices" {
    var array = [_]i32{ 1, 2, 3, 4 };
    var length: usize = 0; // var to make it runtime-known
    _ = &length; // suppress 'var is never mutated' error
    var slice = array[length..array.len];

    try expect(slice[0] == 1);
    try expect(slice.len == 4);

    slice.ptr += 1;
    // now the slice is in an bad state since len has not been updated

    try expect(slice[0] == 2);
    try expect(slice.len == 4);
}
```

--------------------------------

TITLE: Zig: C Standard Library Integration
DESCRIPTION: Expands Zig's integration with the C standard library by adding new functions and fixing existing definitions. This includes functions for signal handling and process control.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
c: add sigfillset, alarm, sigwait.
c: fix waitpid() definition.
```

--------------------------------

TITLE: Zig: Build Artifact Caching Example
DESCRIPTION: This example illustrates Zig's build artifact caching mechanism. When the `--cache on` flag is used, Zig caches build artifacts. The provided manifest file snippet shows the metadata (inode, mtime, hash, path) for a `hello.zig` file, demonstrating how Zig tracks files for caching purposes.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: Shell
CODE:
```
5505089 1548876783 204467480 rcnRrxBgZSiWki_XN9XKlQ2yfWkM6KLYhUWprzniEBtjgmeUSmtlv5mAguA4l2Q1 /home/andy/dev/zig/example/hello_world/hello.zig
```

--------------------------------

TITLE: Zig: `printValue` implementation for different types
DESCRIPTION: Details the `printValue` function within the `Writer` struct, showing how it handles different data types like integers, floats, and pointers. It uses a `switch` statement on the type information to dispatch to type-specific writing functions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
const Writer = struct {
    pub fn printValue(self: *Writer, value: anytype) !void {
        switch (@typeInfo(@TypeOf(value))) {
            .Int => {
                return self.writeInt(value);
            },
            .Float => {
                return self.writeFloat(value);
            },
            .Pointer => {
                return self.write(value);
            },
            else => {
                @compileError("Unable to print type '" ++ @typeName(@TypeOf(value)) ++ "'");
            },
        }
    }

    fn write(self: *Writer, value: []const u8) !void {
        _ = self;
        _ = value;
    }
};
```

--------------------------------

TITLE: Zig Base-e Exponential Function
DESCRIPTION: The `@exp` function in Zig computes the base-e exponential of a floating-point number, using hardware instructions if available. It handles both floats and vectors of floats, though some float types may have incomplete support for this operation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
@exp(value: anytype) @TypeOf(value)
```

--------------------------------

TITLE: Zig: Linux EALREADY error handling for connect/getsockopt
DESCRIPTION: Enhances the handling of the `EALREADY` error code for `connect()` and `getsockoptError()` system calls on Linux. This improves robustness when dealing with non-blocking socket operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
os/linux: return error on EALREADY for connect() and getsockoptError()
```

--------------------------------

TITLE: Zig @exp for Base-e Exponential Calculation
DESCRIPTION: Covers the @exp built-in function, which calculates the base-e exponential of a floating-point number. It supports both scalar and vector inputs and uses hardware instructions for efficiency.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html



--------------------------------

TITLE: Zig: Expose machine field in ELF header
DESCRIPTION: Exposes the `machine` field from the ELF header structure. This allows programs to directly access and interpret the target architecture information embedded in ELF files.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
expose machine field in ELF header
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Explains the bitwise AND operator '&' and compound assignment '&=' for Integers in Zig. This operation invokes Peer Type Resolution for the operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
a & b
a &= b

// Example:
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig: Add epoll_pwait2 Linux syscall
DESCRIPTION: Adds the `epoll_pwait2` system call to the Linux operating system module. This system call provides enhanced control over epoll event waiting, including timeout precision.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Add epoll_pwait2 Linux syscall
```

--------------------------------

TITLE: Zig: `printValue` Type Handling Implementation
DESCRIPTION: Details the `printValue` function within the Zig `print` implementation, which handles different data types. It uses a `switch` statement on the type information to dispatch to specific writing functions for integers, floats, and pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
const Writer = struct {
    pub fn printValue(self: *Writer, value: anytype) !void {
        switch (@typeInfo(@TypeOf(value))) {
            .int => {
                return self.writeInt(value);
            },
            .float => {
                return self.writeFloat(value);
            },
            .pointer => {
                return self.write(value);
            },
            else => {
                @compileError("Unable to print type '" ++ @typeName(@TypeOf(value)) ++ "'");
            },
        }
    }

    fn write(self: *Writer, value: []const u8) !void {
        _ = self;
        _ = value;
    }
};
```

--------------------------------

TITLE: Zig Linker: TAPI Parser for System Libraries
DESCRIPTION: Highlights the implementation of a TAPI (Text-based stub files) parser within the Zig MachO linker. This parser is essential for correctly linking system libraries and frameworks, especially in cross-compilation scenarios.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
// The TAPI parser enables the linker to understand Apple's text-based
// definition stub files (e.g., libSystem.B.tbd).

// This is crucial for linking system libraries and frameworks, especially
// when cross-compiling from non-Apple hosts to Apple platforms.

// Example of a TAPI file structure (conceptual):
// --- !tapi
// compatible with:
//   - macos
// install name: /usr/lib/libSystem.B.dylib
// ...

```

--------------------------------

TITLE: Zig builtin @atomicRmw
DESCRIPTION: Illustrates the `@atomicRmw` built-in function in Zig for atomic read-modify-write operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
var atomic_val: atomic(i32) = undefined;
const old_val = @atomicRmw(&atomic_val, .add, .SeqCst, 1);
```

--------------------------------

TITLE: Zig @atomicLoad
DESCRIPTION: Atomically loads a value from a pointer. This function ensures that the read operation is atomic, preventing race conditions in concurrent programming. It supports boolean, float, integer, and enum types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
    @atomicLoad(comptime T: type, ptr: *const T, comptime ordering: builtin.AtomicOrder) T
```

--------------------------------

TITLE: Zig Comptime LLVM IR Output
DESCRIPTION: Presents the generated LLVM Intermediate Representation (IR) for the comptime prime number generation example. It highlights the compile-time computed constants for the prime numbers and their sum, demonstrating the efficiency of Zig's compile-time execution.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: llvm ir
CODE:
```
    @0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
    @1 = internal unnamed_addr constant i32 1060
```

--------------------------------

TITLE: Add readUntilDelimiterOrEofArrayList and readUntilDelimiterOrEofAlloc
DESCRIPTION: Adds readUntilDelimiterOrEofArrayList and readUntilDelimiterOrEofAlloc to the Zig standard library, providing functions to read from a reader until a delimiter is found or the end of the file is reached, storing the result in an ArrayList or allocating memory for it.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html



--------------------------------

TITLE: Zig: `mem.split` and `mem.tokenize` Generics
DESCRIPTION: Makes `mem.split` and `mem.tokenize` generic functions instead of assuming `u8` elements, allowing them to work with different data types and improving flexibility.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
`mem.split` and `mem.tokenize` generic instead of assuming u8 ([#9531](https://github.com/ziglang/zig/issues/9531)).
```

--------------------------------

TITLE: Zig Peer Type Resolution: Empty Array and Slice
DESCRIPTION: Illustrates peer type resolution between an empty array literal `[]const u8{}` and a slice of a string. It shows how an empty array can be implicitly cast to a slice, with tests for runtime and compile-time.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;

test "peer type resolution: [0]u8 and []const u8" {
    assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
    assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    comptime {
        assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
        assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    }
}
fn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {
    if (a) {
        return []const u8{};
    }

    return slice[0..1];
}
```

--------------------------------

TITLE: Zig: Write to File (Blocking)
DESCRIPTION: A simple Zig program demonstrating how to write content to a file using blocking I/O. It creates a file named 'hello.txt', writes 'hello\n' to it, and ensures the file is closed afterwards.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
pub fn main() anyerror!void {
    const file = try std.fs.cwd().createFile("hello.txt", .{
    });
    defer file.close();
    try file.writeAll("hello\n");
}
```

--------------------------------

TITLE: Fix std.atomic.Queue unget and add documentation
DESCRIPTION: Corrects the unget implementation for std.atomic.Queue and adds relevant documentation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.1/release-notes.html

LANGUAGE: Zig
CODE:
```
std.atomic.Queue: fix unget implementation and add doc
```

--------------------------------

TITLE: Zig: Resolve Peer Types
DESCRIPTION: Demonstrates Zig's peer type resolution for pointers and slices, including tests for various pointer and slice combinations. This snippet showcases how Zig handles type compatibility in pointer and slice operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
fn peerTypeEmptyArrayAndSliceAndError(a: bool, slice: []u8) anyerror![]u8 {
    if (a) {
        return &[_]u8{};
    }

    return slice[0..1];
}

test "peer type resolution: *const T and ?*T" {
    const a = @intToPtr(*const usize, 0x123456780);
    const b = @intToPtr(?*usize, 0x123456780);
    expect(a == b);
    expect(b == a);
}
```

--------------------------------

TITLE: Zig Linker Improvements
DESCRIPTION: This snippet details improvements to the Zig linker, including proper implementation of passthrough mode for LLD child processes and fixing the linking order of libc components.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
link: properly implement passthrough mode for LLD child proccess.
Fix libc components' linking order.
```

--------------------------------

TITLE: Zig @alignOf Example
DESCRIPTION: Explains how to use @alignOf to get the required byte alignment for a type according to the C ABI for the current target. This is useful for ensuring correct memory layout.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.0/index.html

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;

comptime {
    assert(@alignOf(u32) <= @sizeOf(u32));
    assert(&u32 == &align(@alignOf(u32)) u32);
}
```

--------------------------------

TITLE: Zig Fully Anonymous List Literal Inference
DESCRIPTION: Illustrates how fully anonymous list literals (without an explicit type) are treated as structs with numbered field names in Zig. Includes a test case to verify field access.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous list literal" {
    try dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: anytype) !void {
    try expect(args.@"0" == 1234);
    try expect(args.@"1" == 12.34);
    try expect(args.@"2");
    try expect(args.@"3"[0] == 'h');
    try expect(args.@"3"[1] == 'i');
}
```

LANGUAGE: Shell
CODE:
```
$ zig test infer_list_literal.zig
1/1 test "fully anonymous list literal"... OK
All 1 tests passed.
```

--------------------------------

TITLE: Zig String Literal to Mutable Slice Error
DESCRIPTION: Illustrates an error scenario in Zig where a string literal is passed to a function expecting a mutable slice (`[]u8`). String literals are immutable and stored in read-only memory, causing a type mismatch.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
fn foo(s: []u8) void {}

test "string literal to mutable slice" {
    foo("hello");
}
```

--------------------------------

TITLE: Zig New Streams API Example
DESCRIPTION: Illustrates reading lines from standard input and calculating a sum using the new, simplified Zig streams API. This version is more ergonomic and efficient.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() anyerror!void {
    const in = std.io.bufferedInStream(std.io.getStdIn().inStream()).inStream();
    var sum: u64 = 0;
    var line_buf: [50]u8 = undefined;
    while (try in.readUntilDelimiterOrEof(&line_buf, '\n')) |line| {
        if (line.len == 0) break;
        const module_mass = try std.fmt.parseInt(u64, line, 10);
        const fuel_required = (module_mass / 3) - 2;
        sum += fuel_required;
    }
    const out = std.io.getStdOut().outStream();
    try out.print("{}\\n", .{sum});
}
```

--------------------------------

TITLE: Zig VDSO Optimization for clock_gettime
DESCRIPTION: On Linux, `clock_gettime` now utilizes the VDSO (Virtual Dynamic Shared Object) for optimization, even in static builds. This can lead to faster time retrieval by avoiding system calls.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: C
CODE:
```
#include <time.h>
struct timespec ts;
clock_gettime(CLOCK_REALTIME, &ts);
```

--------------------------------

TITLE: Zig Volatile Load/Store Example
DESCRIPTION: Demonstrates the use of the `volatile` keyword in Zig for memory-mapped I/O. It shows how to declare a volatile pointer and assert its type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Build System: Fix Darwin Rpaths and Improve CheckObjectStep
DESCRIPTION: Corrects the addition of rpaths on Darwin systems and enhances `CheckObjectStep` to allow matching `LazyPath` paths, improving cross-platform compatibility and analysis.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
build: fix adding rpaths on darwin, improve CheckObjectStep to allow matching LazyPath paths
```

--------------------------------

TITLE: Zig File System Directory Splitting and Iterator Handling
DESCRIPTION: Splits `Dir` into `IterableDir` and refactors `Iterator.next` for Linux/WASI to handle platform-specific errors like `ENOENT`. Fixes `WalkerEntry.dir` assignment.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Split `Dir` into `IterableDir`
Split Iterator.next on Linux and WASI to allow for handling platform-specific errors
Fixed `WalkerEntry.dir` not always being the containing dir
```

--------------------------------

TITLE: Zig Packed Structs: BitCast Example
DESCRIPTION: Demonstrates using `@bitCast` between different `packed struct` types in Zig. It verifies the size of the structs and the correct interpretation of data based on endianness.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const builtin = std.builtin;
const expect = std.testing.expect;

const Full = packed struct {
    number: u16,
};
const Divided = packed struct {
    half1: u8,
    quarter3: u4,
    quarter4: u4,
};

test "@bitCast between packed structs" {
    doTheTest();
    comptime doTheTest();
}

fn doTheTest() void {
    expect(@sizeOf(Full) == 2);
    expect(@sizeOf(Divided) == 2);
    var full = Full{ .number = 0x1234 };
    var divided = @bitCast(Divided, full);
    switch (builtin.endian) {
        .Big => {
            expect(divided.half1 == 0x12);
            expect(divided.quarter3 == 0x3);
            expect(divided.quarter4 == 0x4);
        },
        .Little => {
            expect(divided.half1 == 0x34);
            expect(divided.quarter3 == 0x2);
            expect(divided.quarter4 == 0x1);
        },
    }
}
```

--------------------------------

TITLE: Zig UEFI Virtual Addressing Helpers
DESCRIPTION: Introduces virtual addressing helper functions for UEFI environments, enhancing memory management capabilities within the boot services.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
# Added virtual addressing helpers ([#10195](https://github.com/ziglang/zig/issues/10195)).
```

--------------------------------

TITLE: Zig @atomicLoad Example
DESCRIPTION: Provides an example of using the @atomicLoad builtin function in Zig for atomic memory operations. It demonstrates how to atomically dereference a pointer to a type T and retrieve its value, specifying the memory ordering.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
@atomicLoad(comptime T: type, ptr: *const T, comptime ordering: AtomicOrder) T
```

--------------------------------

TITLE: Add inotify_rm_watch and Mark Pathname as Null-Terminated
DESCRIPTION: Adds the `inotify_rm_watch` definition to `c/linux.zig` and marks the pathname in `inotify_add_watch` as null-terminated, improving Linux inotify API bindings.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Add inotify_rm_watch definition to c/linux.zig and make inotify_add_watch's pathname marked as nul-terminated.
```

--------------------------------

TITLE: Zig Volatile Load/Store Example
DESCRIPTION: Demonstrates the use of the `volatile` keyword in Zig for memory-mapped I/O. It shows how to declare a volatile pointer and assert its type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig: Switch Capture Peer Type Resolution
DESCRIPTION: Illustrates how Zig's switch statement captures union payloads, utilizing peer type resolution to handle distinct but compatible types. It also covers pointer captures.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;
const expectEqual = std.testing.expectEqual;

const U1 = union(enum) {
    x: u8,
    y: ?u32,
};

test "switch capture resolves peer types" {
    try f(1, .{ .x = 1 });
    try f(2, .{ .y = 2 });
    try f(0, .{ .y = null });
}

fn f(expected: u32, u: U1) !void {
    switch (u) {
        .x, .y => |val| {
            comptime assert(@TypeOf(val) == ?u32);
            try expectEqual(expected, val orelse 0);
        },
    }
}

const U2 = union(enum) {
    x: c_uint,
    /// This type has the same number of bits as `c_uint`, but is distinct.
    y: @Type(.{ .Int = .{ .signedness = .unsigned, .bits = @bitSizeOf(c_uint) } }),
};

test "switch pointer capture resolves peer types" {
    var a: U2 = .{ .x = 10 };
    var b: U2 = .{ .y = 20 };

    g(&a);
    g(&b);

    try expectEqual(U2{ .x = 11 }, a);
    try expectEqual(U2{ .y = 21 }, b);
}

fn g(u: *U2) void {
    switch (u.*) {
        .x, .y => |*ptr| {
            ptr.* += 1;
        },
    }
}
```

--------------------------------

TITLE: Zig Function Parameter Type Inference
DESCRIPTION: Illustrates how to use `anytype` for function parameters in Zig, allowing types to be inferred at compile time. It shows how to use `@TypeOf` and `@typeInfo` to inspect the inferred types and includes test cases for integer and i64 inputs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

fn addFortyTwo(x: anytype) @TypeOf(x) {
    return x + 42;
}

test "fn type inference" {
    try expect(addFortyTwo(1) == 43);
    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
    var y: i64 = 2;
    try expect(addFortyTwo(y) == 44);
    try expect(@TypeOf(addFortyTwo(y)) == i64);
}
```

--------------------------------

TITLE: Zig HTTP Server Connection Lifecycle
DESCRIPTION: Demonstrates the new lifecycle for handling HTTP server connections in Zig. It outlines the sequence of operations from accepting a connection to sending a response, emphasizing the type system's guidance for API users.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: Zig
CODE:
```
1. std.net.Server.accept() gives you a std.net.Server.Connection
2. std.http.Server.init() with the connection
3. Server.receiveHead() gives you a Request
4. Request.reader() gives you a body reader
5. Request.respond() is a one-shot, or Request.respondStreaming() creates a Response
6. Response.writer() gives you a body writer
7. Response.end() finishes the response; Response.endChunked() allows passing response trailers.
```

--------------------------------

TITLE: Zig Fully Anonymous List Literal Inference
DESCRIPTION: Illustrates how fully anonymous list literals (without an explicit type) are treated as structs with numbered field names in Zig. Includes a test case to verify field access.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous list literal" {
    try dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: anytype) !void {
    try expect(args.@"0" == 1234);
    try expect(args.@"1" == 12.34);
    try expect(args.@"2");
    try expect(args.@"3"[0] == 'h');
    try expect(args.@"3"[1] == 'i');
}
```

LANGUAGE: Shell
CODE:
```
$ zig test infer_list_literal.zig
1/1 test "fully anonymous list literal"... OK
All 1 tests passed.
```

--------------------------------

TITLE: WebAssembly and WASI Support in Zig
DESCRIPTION: Outlines contributions to Zig's WebAssembly and WASI support, including getting compiler-rt working, tweaking target settings like disabling error return traces, forcing single-threaded mode, and setting the executable file extension to .wasm. It also mentions the addition of standard library support for the WASI target.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
disabling error return traces
forcing single-threaded mode
making the executable file extension ".wasm"
```

--------------------------------

TITLE: Zig noreturn type compatibility example
DESCRIPTION: Demonstrates the compatibility of the `noreturn` type with other types in conditional expressions like `if` statements, showing how `return` can be used as an alternative path.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
fn foo(condition: bool, b: u32) void {
    const a = if (condition) b else return;
    @panic("do something with a");
}
test "noreturn" {
    foo(false, 1);
}
```

--------------------------------

TITLE: Zig: Pointer to Integer Conversion Example
DESCRIPTION: Illustrates the use of @ptrToInt to obtain the integer address of a pointer. This is presented as an alternative when a variable's type changes from an integer to a pointer, requiring a different explicit cast.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
var i = @ptrToInt(x);
```

--------------------------------

TITLE: Zig Cross-Platform Metadata API and File Sync
DESCRIPTION: Implements a cross-platform metadata API and adds `File.sync` functionality. Prevents integer overflow in `Dir.makePath`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Implemented cross-platform metadata API
Added File.sync
Prevent possible integer overflow in Dir.makePath
```

--------------------------------

TITLE: Zig Runtime Struct Field Dump Function
DESCRIPTION: Demonstrates a function `dump` that iterates over the fields of a struct using compile-time reflection and prints their names and values. This example showcases handling mixed comptime and runtime values within a struct.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

fn dump(args: var) void {
    inline for (std.meta.fields(@TypeOf(args))) |field| {
        std.debug.warn("{} = {}\n", .{field.name, @field(args, field.name)});
    }
}

pub fn main() void {
    var runtime_float: f32 = 12.34;
    dump(.{
        .int = 1234,
        .float = runtime_float,
        .b = true,
        .s = "hi",
        .T = [*]f32,
    });
}
```

--------------------------------

TITLE: Zig Standard Library: Windows Specific Improvements
DESCRIPTION: This section outlines various improvements made to Zig's standard library for Windows compatibility. It includes updates to `zig test` for Windows console detection, the addition of `CANNOT_DELETE` error for `os.windows.DeleteFile`, and the use of explicit integer bit widths for Windows GUIDs. Performance improvements for comptime Windows GUID parsing and handling of broken pipes in `child_process` are also mentioned, along with reworkings of `std.Thread.getName/setName` and the addition of `GetProcessTimes` binding.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example: Using os.windows.DeleteFile with CANNOT_DELETE error
const file_path = "protected_file.txt";
var file = std.fs.cwd().openFile(file_path, .{}) catch |err| switch (err) {
    error.AccessDenied -> std.debug.print("Cannot delete file: {s}", .{\nfile_path});
    else -> |e| return e;
};

// Example: Using std.process.EnvMap for case-insensitive environment variables
var env_map = std.process.EnvMap.init(std.heap.page_allocator);
defer env_map.deinit();
const value = env_map.get("PATH");

// Example: GetProcessTimes binding (conceptual)
const kernel32 = std.windows.kernel32;
var creation_time: std.windows.FILETIME = undefined;
var exit_time: std.windows.FILETIME = undefined;
var kernel_time: std.windows.FILETIME = undefined;
var user_time: std.windows.FILETIME = undefined;
try kernel32.GetProcessTimes(std.os.getpid(), &creation_time, &exit_time, &kernel_time, &user_time);

```

--------------------------------

TITLE: Zig Tuple Initialization and Operations
DESCRIPTION: Shows the creation and manipulation of tuples in Zig, which are anonymous structs with numeric field names starting from 0. The example demonstrates concatenation, indexing, iteration, and accessing fields using quoted numeric identifiers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "tuple" {
    const values = .{ 
        @as(u32, 1234),
        @as(f64, 12.34),
        true,
        "hi",
    } ++ .{false} ** 2;
    try expect(values[0] == 1234);
    try expect(values[4] == false);
    inline for (values) |v, i| {
        if (i != 2) continue;
        try expect(v);
    }
    try expect(values.len == 6);
    try expect(values.@"3"[0] == 'h');
}
```

--------------------------------

TITLE: Zig: Base-2 Exponential with @exp2
DESCRIPTION: Details the `@exp2` function for computing the base-2 exponential of floating-point numbers and vectors. It highlights hardware acceleration and potential implementation gaps for certain float types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html



--------------------------------

TITLE: Zig Volatile Load/Store Example
DESCRIPTION: Demonstrates the use of the `volatile` keyword in Zig for memory-mapped I/O. It shows how to declare a volatile pointer and assert its type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Function Parameter Type Inference
DESCRIPTION: Illustrates how to use `anytype` for function parameters in Zig, allowing types to be inferred at compile time. It shows how to use `@TypeOf` and `@typeInfo` to inspect the inferred types and includes test cases for integer and i64 inputs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

fn addFortyTwo(x: anytype) @TypeOf(x) {
    return x + 42;
}

test "fn type inference" {
    try expect(addFortyTwo(1) == 43);
    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
    var y: i64 = 2;
    try expect(addFortyTwo(y) == 44);
    try expect(@TypeOf(addFortyTwo(y)) == i64);
}
```

--------------------------------

TITLE: Zig Function Type Reflection
DESCRIPTION: Demonstrates how to use Zig's reflection capabilities to inspect function types, specifically checking the return type and whether a function uses variable arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "fn reflection" {
    expect(@typeInfo(@TypeOf(expect)).Fn.return_type.? == void);
    expect(@typeInfo(@TypeOf(expect)).Fn.is_var_args == false);
}
```

--------------------------------

TITLE: Fix WASI IterableDir.nextWasi for large directories
DESCRIPTION: Resolves issues in the WASI implementation of IterableDir.nextWasi when handling very large directories.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.1/release-notes.html

LANGUAGE: Zig
CODE:
```
wasi: fixes IterableDir.nextWasi for large directory
```

--------------------------------

TITLE: Zig: `printValue` Type Handling Implementation
DESCRIPTION: Details the `printValue` function within the Zig `print` implementation, which handles different data types. It uses a `switch` statement on the type information to dispatch to specific writing functions for integers, floats, and pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
const Writer = struct {
    pub fn printValue(self: *Writer, value: anytype) !void {
        switch (@typeInfo(@TypeOf(value))) {
            .int => {
                return self.writeInt(value);
            },
            .float => {
                return self.writeFloat(value);
            },
            .pointer => {
                return self.write(value);
            },
            else => {
                @compileError("Unable to print type '" ++ @typeName(@TypeOf(value)) ++ "'");
            },
        }
    }

    fn write(self: *Writer, value: []const u8) !void {
        _ = self;
        _ = value;
    }
};
```

--------------------------------

TITLE: Linking: LLD Mach-O target-version-gating
DESCRIPTION: Fixes a regression in the Mach-O linker targeting newer macOS systems. It implements target-version-gating for `-syslibroot` on the linker line, ensuring compatibility with updated macOS versions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: Shell
CODE:
```
# Conceptual linker command modification
# Original (potentially problematic):
# zig build ... -target x86_64-macos -syslibroot /path/to/sdk

# Corrected behavior (conditional -syslibroot):
# zig build ... -target x86_64-macos --syslibroot <sdk_path_if_needed>
```

--------------------------------

TITLE: Zig: @ptrToInt and @intToPtr
DESCRIPTION: Demonstrates the use of @ptrToInt and @intToPtr in Zig to convert between pointers and integer representations of memory addresses. It includes assertions to verify the type and value of the converted address.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;

test "@ptrToInt and @intToPtr" {
    const ptr = @intToPtr(*i32, 0xdeadbee0);
    const addr = @ptrToInt(ptr);
    assert(@TypeOf(addr) == usize);
    assert(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Zig: Constructing Slice at Comptime (Error)
DESCRIPTION: Shows a Zig function that constructs a slice at comptime, returning a pointer to a comptime variable. This is problematic at runtime and in global declarations, requiring a fix by promoting computed data to a const.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: zig
CODE:
```
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    @memcpy(&buf, "some name");
    return &buf;
}

test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
```

--------------------------------

TITLE: Zig Builtin: @atomicLoad
DESCRIPTION: Atomically loads a value from a memory location. Ensures that the read operation is not interrupted by other threads.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
const value = @atomicLoad(volatile AtomicType, ptr);
// value is the loaded value
```

--------------------------------

TITLE: Integer Debug Info and Function Alignment
DESCRIPTION: Improvements to debug information for integers, using ABI size * 8 for better GDB compatibility. Also includes a fix for user-defined function alignment not propagating to LLVM IR.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const size_in_bits = @intCast(usize, @bitSizeOf(@typeInfo(i32).Int.signedness));
const abi_size_in_bytes = @bitSizeOf(i32) / 8;
// Use abi_size_in_bytes * 8 for debug info
```

--------------------------------

TITLE: Zig: Convert Integer Address to Pointer and Vice Versa
DESCRIPTION: Demonstrates the use of @intToPtr to convert an integer address to a pointer and @ptrToInt to convert a pointer back to an integer. It also shows how to check the type and value of the converted integer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "@ptrToInt and @intToPtr" {
    const ptr = @intToPtr(*i32, 0xdeadbee0);
    const addr = @ptrToInt(ptr);
    expect(@TypeOf(addr) == usize);
    expect(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Adding a Mirror Entry to community-mirrors.ziggy
DESCRIPTION: An example demonstrating the format for adding a new mirror configuration to the `assets/community-mirrors.ziggy` file. This includes the URL, username, and email for the mirror.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/MIRRORS.md

LANGUAGE: diff
CODE:
```
[
    {
        .url = "https://a.com",
        .username = "a",
        .email = "a@a.com",
    },
    {
        .url = "https://b.com/zig",
        .username = "b",
        .email = "b@b.com",
    },
+    {
+        .url = "https://mymirror.net",
+        .username = "my-github-username",
+        .email = "my@email.com",
+    },
]

```

--------------------------------

TITLE: Zig mingw-w64 ANSI stdio Fix
DESCRIPTION: This snippet addresses a bug fix in Zig's integration with mingw-w64, specifically concerning the `-D__USE_MINGW_ANSI_STDIO=0` flag for crt files, ensuring correct ANSI stdio behavior.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Zig now passes `-D__USE_MINGW_ANSI_STDIO=0` for crt files. This was supposed to be happening all along, and it was a bug that Zig did not do this before.
```

--------------------------------

TITLE: Zig Generics: Linked List Implementation
DESCRIPTION: Illustrates Zig's approach to generics using comptime functions to create a generic linked list. Demonstrates type comparison, instantiation, and accessing struct fields via pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: zig
CODE:
```
// You can return a struct from a function. This is how we do generics
    // in Zig:
    fn LinkedList(comptime T: type) type {
        return struct {
            pub const Node = struct {
                prev: ?*Node,
                next: ?*Node,
                data: T,
            };
    
            first: ?*Node,
            last:  ?*Node,
            len:   usize,
        };
    }
    
    test "linked list" {
        // Functions called at compile-time are memoized. This means you can
        // do this:
        try expect(LinkedList(i32) == LinkedList(i32));
    
        var list = LinkedList(i32) {
            .first = null,
            .last = null,
            .len = 0,
        };
        try expect(list.len == 0);
    
        // Since types are first class values you can instantiate the type
        // by assigning it to a variable:
        const ListOfInts = LinkedList(i32);
        try expect(ListOfInts == LinkedList(i32));
    
        var node = ListOfInts.Node {
            .prev = null,
            .next = null,
            .data = 1234,
        };
        var list2 = LinkedList(i32) {
            .first = &node,
            .last = &node,
            .len = 1,
        };
    
        // When using a pointer to a struct, fields can be accessed directly,
        // without explicitly dereferencing the pointer.
        // So you can do
        try expect(list2.first.?.data == 1234);
        // instead of try expect(list2.first.?.*.data == 1234);
    }
```

--------------------------------

TITLE: Zig: Slice Bounds Checking and Modification
DESCRIPTION: Demonstrates the use of slice syntax `array[start..end]` to create a slice from an array. It shows how slices have a `len` property and allow modification of the underlying array elements through slice indexing, with built-in bounds checking.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "pointer slicing" {
    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    const slice = array[2..4];
    try expect(slice.len == 2);

    try expect(array[3] == 4);
    slice[1] += 1;
    try expect(array[3] == 5);
}
```

--------------------------------

TITLE: Zig Atomic Read-Modify-Write Operation
DESCRIPTION: Performs an atomic read-modify-write operation on a pointer. It dereferences the pointer, atomically modifies the value, and returns the previous value. Supported types include pointers, bool, floats, integers, enums, and packed structs. Requires specifying the atomic operation type and memory ordering.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
comptime T: type, ptr: *T, comptime op: AtomicRmwOp, operand: T, comptime ordering: AtomicOrder) T
```

--------------------------------

TITLE: Zig: Swap arguments in Thread.spawn
DESCRIPTION: Swaps the arguments for the `Thread.spawn` function, referencing issue #8082. This change might be for API consistency or to improve usability.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Swap arguments in Thread.spawn ([#8082](https://github.com/ziglang/zig/issues/8082)).
```

--------------------------------

TITLE: Zig @intToPtr - Convert Integer to Pointer
DESCRIPTION: The @intToPtr function converts an integer address to a pointer of the specified destination type. If the destination pointer type does not permit address zero and the provided address is zero, it results in safety-checked Undefined Behavior. Use @ptrToInt for the reverse conversion.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
comptime DestType: type, address: usize) DestType
```

--------------------------------

TITLE: Fix Type Mapping for nvptx Architecture in Zig
DESCRIPTION: Corrects type mappings for integers and `c_longdouble` specifically for the nvptx (NVIDIA GPU) architecture. This ensures accurate data representation and manipulation on GPUs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Fix type mapping for integers and c_longdouble for the nvptx architecture.
```

--------------------------------

TITLE: Zig: Refactor Mach-O Constants and Fix Bugs
DESCRIPTION: Constants within `std.macho` have been refactored, and two bugs have been fixed. This improves the maintainability and correctness of the Mach-O handling code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
macho: refactor consts in `std.macho`, and fix two bugs ([#10338](https://github.com/ziglang/zig/issues/10338)).
```

--------------------------------

TITLE: Zig: Atomic Fence
DESCRIPTION: Introduces happens-before edges between operations. The 'order' parameter specifies the atomic memory ordering.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: Zig
CODE:
```
@fence(order: AtomicOrder) void
```

--------------------------------

TITLE: Zig std.os.Thread: Thread ID Support
DESCRIPTION: Adds support for retrieving the current thread ID within the `std.os.Thread` module. This is essential for debugging, logging, and managing concurrent operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const thread_id = std.os.Thread.getCurrentId();
```

--------------------------------

TITLE: Reworked Build Options API in Zig
DESCRIPTION: Illustrates the new `addBuildOption` API in Zig's build system, which offers improved integration with `FileSource`, supports arbitrary package naming, allows mapping to multiple artifacts, and uses content hashing for filenames. This replaces the previous global and hard-coded approach.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
const client = b.addSharedLibrary("client", "src/client/zig/client_main.zig", .unversioned);
client.setTarget(.{
    .cpu_arch = .wasm32,
    .os_tag = .freestanding,
});
client.addPackagePath("shared", "src/shared/index.zig");

const server_options = b.addOptions();
server_options.addOptionArtifact("client_wasm_path", client);
server_options.addOption(u32, "mem_leak_frames", mem_leak_frames);
server_options.addOption(bool, "support_mp3", support_mp3);

const server = b.addExecutable("groovebasin", "src/server/server_main.zig");
server.setTarget(target);
server.setBuildMode(mode);
server.addPackagePath("shared", "src/shared/index.zig");

server.addOptions("build_options", server_options);
server.install();
```

--------------------------------

TITLE: Zig: Fix @bytesToSlice on Packed Struct
DESCRIPTION: Addresses an issue with `@bytesToSlice` when used on packed structs, ensuring correct behavior for memory slicing operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
fix @bytesToSlice on a packed struct ([#1551](https://github.com/ziglang/zig/issues/1551))
```

--------------------------------

TITLE: Zig Anonymous Struct Literal Coercion
DESCRIPTION: Shows how anonymous struct literals can be used and coerced into existing struct types without explicit copying, simplifying initialization.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
    const expect = std.testing.expect;
    
    const Point = struct {x: i32, y: i32};
    
    test "anonymous struct literal" {
        var pt: Point = .{ 
            .x = 13,
            .y = 67,
        };
        expect(pt.x == 13);
        expect(pt.y == 67);
    }

    $ zig test struct_result.zig
    1/1 test "anonymous struct literal"... OK
    All 1 tests passed.
    
```

--------------------------------

TITLE: Zig Bitwise XOR Operator
DESCRIPTION: Performs a bitwise XOR operation. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
a ^ b
a ^=
b
```

--------------------------------

TITLE: Zig Bitwise AND
DESCRIPTION: Performs a bitwise AND operation. It invokes Peer Type Resolution for the operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: Zig
CODE:
```
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig: Array Literal Syntax Update
DESCRIPTION: Details the change in array literal syntax for size inference. The new syntax `[_]T{...}` is clearer than the old `[]T{...}` which resembled slice instantiation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
[]_]i32{1, 2, 3}
```

--------------------------------

TITLE: Zig Build System: Integrate System Library vs. Fetch Dependency
DESCRIPTION: Shows a Zig build.zig modification to conditionally link against a system library ('groove') or a fetched dependency. The `b.systemIntegrationOption` function checks if a system integration is enabled, defaulting to linking the system library if true, otherwise falling back to the standard dependency fetching and linking process.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: zig
CODE:
```
---
a/build.zig
+++
@@ -5,18 +5,8 @@
         const optimize = b.standardOptimizeOption(.{
             .preferred_optimize_mode = .ReleaseSafe,
         });
-    const libgroove_optimize_mode = b.option(
-        std.builtin.OptimizeMode,
-        "libgroove-optimize",
-        "override optimization mode of libgroove and its dependencies",
-    );
         const use_llvm = b.option(bool, "use-llvm", "LLVM backend");
 
-    const groove_dep = b.dependency("groove", .{
-        .optimize = libgroove_optimize_mode orelse .ReleaseFast,
-        .target = target,
-    });
-
         b.installDirectory(.{
             .source_dir = .{"path" = "public"},
             .install_dir = .lib,
@@ -31,7 +21,22 @@
             .use_llvm = use_llvm,
             .use_lld = use_llvm,
         });
-    server.linkLibrary(groove_dep.artifact("groove"));
+    
+    if (b.systemIntegrationOption("groove", .{})) {
+        server.linkSystemLibrary("groove");
+    } else {
+        const libgroove_optimize_mode = b.option(
+            std.builtin.OptimizeMode,
+            "libgroove-optimize",
+            "override optimization mode of libgroove and its dependencies",
+        );
+        const groove_dep = b.dependency("groove", .{
+            .optimize = libgroove_optimize_mode orelse .ReleaseFast,
+            .target = target,
+        });
+        server.linkLibrary(groove_dep.artifact("groove"));
+    }
+
         b.installArtifact(server);
 
         const run_cmd = b.addRunArtifact(server);

```

--------------------------------

TITLE: Zig: Constructing Slice at Comptime (Fixed)
DESCRIPTION: Presents the corrected Zig code for constructing a slice at comptime. By promoting the computed buffer to a `const` after population, the data has an infinite lifetime and avoids runtime issues.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: zig
CODE:
```
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    @memcpy(&buf, "some name");
    const final_name = buf;
    return &final_name;
}

test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
```

--------------------------------

TITLE: Zig `printValue` Implementation: Type Handling
DESCRIPTION: This Zig code snippet illustrates the `printValue` function, which is responsible for handling different data types passed to the `print` function. It uses a `switch` statement on the type information to delegate to specific write functions for integers, floats, and pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
const Writer = struct {
    pub fn printValue(self: *Writer, value: anytype) !void {
        switch (@typeInfo(@TypeOf(value))) {
            .Int => {
                return self.writeInt(value);
            },
            .Float => {
                return self.writeFloat(value);
            },
            .Pointer => {
                return self.write(value);
            },
            else => {
                @compileError("Unable to print type '" ++ @typeName(@TypeOf(value)) ++ "'");
            },
        }
    }

    fn write(self: *Writer, value: []const u8) !void {
        _ = self;
        _ = value;
    }
};
```

--------------------------------

TITLE: Zig: Base-2 Exponential with @exp2
DESCRIPTION: Details the `@exp2` function for computing the base-2 exponential of floating-point numbers and vectors. It highlights hardware acceleration and potential implementation gaps for certain float types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html



--------------------------------

TITLE: Zig Builtin: @atomicStore
DESCRIPTION: The `@atomicStore` builtin function performs an atomic store operation, writing a value to a memory location atomically.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
var flag: atomic(bool) = false;
@atomicStore(&flag, true, .SeqCst);
// flag is now atomically set to true
```

--------------------------------

TITLE: Add Missing Bitcast for Var Ptr Rendering
DESCRIPTION: Includes a missing bitcast operation when rendering variable pointers, addressing an issue identified in issue #7250.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Add missing bitcast when rendering var ptr ([#7250](https://github.com/ziglang/zig/issues/7250)).
```

--------------------------------

TITLE: Zig Anonymous Struct Literal with Type
DESCRIPTION: Demonstrates creating an anonymous struct literal and coercing it to a defined struct type 'Point'. It shows how the literal instantiates the result location directly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

const Point = struct { x: i32, y: i32 };

test "anonymous struct literal" {
    const pt: Point = .{ 
        .x = 13,
        .y = 67,
    };
    try expect(pt.x == 13);
    try expect(pt.y == 67);
}
```

--------------------------------

TITLE: Naked Function Entry Point Example
DESCRIPTION: Demonstrates the updated structure for naked functions in Zig 0.11.0. It shows how to replace the explicit `unreachable` statement with a jump to the actual start of the function, aligning with the new restrictions on naked functions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
pub export fn _start() callconv(.Naked) noreturn {
    asm volatile (
        "push %rbp\n"
        "jmp %[start:P]"
        : 
        : [start] "X" (&start)
    );
    unreachable;
}

fn start() void {}

```

--------------------------------

TITLE: Zig Built-in Function: @bytesToSlice
DESCRIPTION: Demonstrates the @bytesToSlice builtin function in Zig, which converts a byte array into a slice of a specified type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() {
    var bytes: [4]u8 = [_]u8{ 1, 2, 3, 4 };
    const slice = @bytesToSlice(u32, &bytes) catch unreachable;
    std.debug.print("Slice value: {d}\n", .{slice[0]});
}
```

--------------------------------

TITLE: Store Target Info in LLVM Module
DESCRIPTION: Stores target information within the LLVM module for each function. This is necessary for LLVM and libLTO to utilize user-specified target options, as discussed in issue #8803.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Store target info in the LLVM module for every function. This is needed to let LLVM (or, better, libLTO) produce code using the target options specified by the user ([#8803](https://github.com/ziglang/zig/issues/8803)).
```

--------------------------------

TITLE: Zig Self-Hosted Linker Support
DESCRIPTION: The self-hosted linker now supports ELF and COFF formats, removing the dependency on LLD.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
https://lld.llvm.org/
```

--------------------------------

TITLE: macOS: Expose ptrace syscall with errno handling
DESCRIPTION: This update exposes the ptrace syscall on macOS, including proper errno handling. This allows for more robust debugging and process introspection capabilities within Zig applications targeting macOS.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.os.ptrace
```

--------------------------------

TITLE: Zig: `DynamicBitSet` Iterator Modification
DESCRIPTION: Changes the `DynamicBitSet.iterator` to accept `self` by const, improving immutability and potentially performance for iterator operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
`DynamicBitSet.iterator` takes self as const.
```

--------------------------------

TITLE: Type Metadata and Field Handling
DESCRIPTION: This snippet covers improvements related to type metadata and handling of comptime fields. It includes making `meta.alignment` work on more types and fixing logic for duplicate comptime fields.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
fix logic for duplicate comptime fields and avoid freeing comptime fields in parseFree and parseInternal
fix duplicate_field_behavior UseFirst in json.zig
meta.Elem: support all optional types
Make meta.alignment work on more types
```

--------------------------------

TITLE: Zig Function for Base64 Decoding with C ABI
DESCRIPTION: Provides a Zig function signature for decoding base64, designed to be exported with the C ABI. It specifies pointer types for destination and source buffers and their lengths, adhering to C conventions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const base64 = @import("std").base64;

export fn decode_base_64(
    dest_ptr: [*]u8,
    dest_len: usize,
    source_ptr: [*]const u8,
    source_len: usize,
) usize {
    const src = source_ptr[0..source_len];

```

--------------------------------

TITLE: Zig Atomic Store Operation
DESCRIPTION: Atomically stores a given value to a pointer. It dereferences the pointer and writes the value. Supported types are similar to @atomicRmw. Requires specifying the memory ordering.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
comptime T: type, ptr: *T, value: T, comptime ordering: AtomicOrder) void
```

--------------------------------

TITLE: Zig: Inline Switch for Runtime to Compile-time Values
DESCRIPTION: Illustrates the use of the 'inline' keyword with 'switch' statements in Zig. This allows a runtime-known value to be treated as a compile-time-known value, enabling features like comptime array sizing.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var arena_instance = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const arena = arena_instance.allocator();
    const args = try std.process.argsAlloc(arena);
    const arg = if (args.len >= 2) args[1] else "50";
    const some_number = try std.fmt.parseInt(i32, arg, 10);

    switch (some_number) {
        inline 1...100 => |x| {
            foo(x);
        },
        else => @panic("not in range"),
    }
}

fn foo(comptime x: i32) void {
    // Doing something that requires a comptime number, such as
    // using it as the length of an array:
    var array: [x]u8 = undefined;
    for (array) |*elem, i| {
        elem.* = @intCast(u8, i);
    }
}
```

--------------------------------

TITLE: Zig: Generic List Data Structure
DESCRIPTION: Illustrates how Zig's comptime enables generic data structures. The `List` function takes a type `T` as a comptime parameter and returns an anonymous struct representing a list of elements of type `T`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
    fn List(comptime T: type) type {
        return struct {
            items: []T,
            len: usize,
        };
    }
    
    // The generic List data structure can be instantiated by passing in a type:
    var buffer: [10]i32 = undefined;
    var list = List(i32){
        .items = &buffer,
        .len = 0,
    };
```

--------------------------------

TITLE: Zig: Convert Integer Address to Pointer and Vice Versa
DESCRIPTION: Demonstrates the use of @intToPtr to convert an integer address to a pointer and @ptrToInt to convert a pointer back to an integer. It also shows how to check the type and value of the converted integer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "@ptrToInt and @intToPtr" {
    const ptr = @intToPtr(*i32, 0xdeadbee0);
    const addr = @ptrToInt(ptr);
    expect(@TypeOf(addr) == usize);
    expect(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Zig @intToPtr Function
DESCRIPTION: Converts an integer to a pointer. The destination type must be specified. To convert the other way, use @ptrToInt.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.2.0/index.html

LANGUAGE: zig
CODE:
```
@intToPtr(comptime DestType: type, int: usize) -> DestType
```

--------------------------------

TITLE: Add os.shutdown function for sockets
DESCRIPTION: Adds os.shutdown function for sockets, allowing for controlled shutdown of socket connections in Zig's os module.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html



--------------------------------

TITLE: Zig: Fix std.fmt.formatInt for Base Int Size
DESCRIPTION: Corrects the `std.fmt.formatInt` function to properly handle upcasting to the base integer size, ensuring accurate formatting across different integer types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
fix std.fmt.formatInt to handle upcasting to base int size
```

--------------------------------

TITLE: Zig: Pointer Slicing and Bounds Checking
DESCRIPTION: Demonstrates how to create a slice from an array using start and end indices and how slices provide bounds checking. The example shows that modifying an element through a slice correctly updates the original array, and implies that out-of-bounds access would be caught.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "pointer slicing" {
    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    var start: usize = 2; // var to make it runtime-known
    _ = &start; // suppress 'var is never mutated' error
    const slice = array[start..4];
    try expect(slice.len == 2);

    try expect(array[3] == 4);
    slice[1] += 1;
    try expect(array[3] == 5);
}
```

--------------------------------

TITLE: Zig: `printValue` Type Handling Implementation
DESCRIPTION: Details the `printValue` function within the Zig `print` implementation, which handles different data types. It uses a `switch` statement on the type information to dispatch to specific writing functions for integers, floats, and pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
const Writer = struct {
    pub fn printValue(self: *Writer, value: anytype) !void {
        switch (@typeInfo(@TypeOf(value))) {
            .int => {
                return self.writeInt(value);
            },
            .float => {
                return self.writeFloat(value);
            },
            .pointer => {
                return self.write(value);
            },
            else => {
                @compileError("Unable to print type '" ++ @typeName(@TypeOf(value)) ++ "'");
            },
        }
    }

    fn write(self: *Writer, value: []const u8) !void {
        _ = self;
        _ = value;
    }
};
```

--------------------------------

TITLE: Zig: Inline Else for Type-Safe Switch Alternatives
DESCRIPTION: Illustrates using `inline else` prongs in Zig as a type-safe alternative to `inline for` loops. This approach ensures all possible cases of a union are handled, allowing the compiler to verify completeness, unlike `inline for` which requires an explicit `unreachable`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

const SliceTypeA = extern struct {
    len: usize,
    ptr: [*]u32,
};
const SliceTypeB = extern struct {
    ptr: [*]SliceTypeA,
    len: usize,
};
const AnySlice = union(enum) {
    a: SliceTypeA,
    b: SliceTypeB,
    c: []const u8,
    d: []AnySlice,
};

fn withFor(any: AnySlice) usize {
    const Tag = @typeInfo(AnySlice).Union.tag_type.?;
    inline for (@typeInfo(Tag).Enum.fields) |field| {
        // With `inline for` the function gets generated as
        // a series of `if` statements relying on the optimizer
        // to convert it to a switch.
        if (field.value == @intFromEnum(any)) {
            return @field(any, field.name).len;
        }
    }
    // When using `inline for` the compiler doesn't know that every
    // possible case has been handled requiring an explicit `unreachable`.
    unreachable;
}

fn withSwitch(any: AnySlice) usize {
    return switch (any) {
        // With `inline else` the function is explicitly generated
        // as the desired switch and the compiler can check that
        // every possible case is handled.
        inline else => |slice| slice.len,
    };
}

test "inline for and inline else similarity" {
    const any = AnySlice{ .c = "hello" };
    try expect(withFor(any) == 5);
    try expect(withSwitch(any) == 5);
}
```

--------------------------------

TITLE: ArrayList and Capacity Management
DESCRIPTION: This section details enhancements to the `ArrayList` data structure, including new functions for capacity management like `clearRetainingCapacity` and `clearAndFree`, and the acceptance of unaligned slices.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
ArrayList: add clearRetainingCapacity and clearAndFree
Accept unaligned slice in several ArrayListAligned ops. Do not impose the internal alignment requirements to the user-supplied parameters ([#8647](https://github.com/ziglang/zig/issues/8647)).
deprecate ensureCapacity, add two other capacity functions
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Performs a bitwise AND operation for integers. Invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
a & b
a &= b

// Example:
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig Fully Anonymous List Literal Behavior
DESCRIPTION: Explains how fully anonymous list literals (without a type specified) are treated as structs with numbered fields in Zig. Includes an example of accessing these fields.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous list literal" {
    try dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: anytype) !void {
    try expect(args.@"0" == 1234);
    try expect(args.@"1" == 12.34);
    try expect(args.@"2");
    try expect(args.@"3"[0] == 'h');
    try expect(args.@"3"[1] == 'i');
}

```

LANGUAGE: shell
CODE:
```
$ zig test infer_list_literal.zig
1/1 test.fully anonymous list literal... OK
All 1 tests passed.

```

--------------------------------

TITLE: Zig: Struct with Methods (Dot Product)
DESCRIPTION: Defines a `Vec3` struct in Zig with `x`, `y`, and `z` fields, including an `init` constructor and a `dot` method for calculating the dot product. Includes a test case for the dot product functionality.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
// Structs can have methods
// Struct methods are not special, they are only namespaced
// functions that you can call with dot syntax.
const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    pub fn init(x: f32, y: f32, z: f32) Vec3 {
        return Vec3 {
            .x = x,
            .y = y,
            .z = z,
        };
    }

    pub fn dot(self: Vec3, other: Vec3) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

const expect = @import("std").testing.expect;
test "dot product" {

```

--------------------------------

TITLE: WASI Runtime Execution: WASMTIME Example
DESCRIPTION: Example of running a WASI-compiled WebAssembly module (`args.wasm`) using the `wasmtime` runtime, passing command line arguments. This demonstrates how the WASI environment receives and processes arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: shell
CODE:
```
wasmtime args.wasm 123 hello
```

--------------------------------

TITLE: Zig: UEFI boot_services locateDevicePath
DESCRIPTION: Implements the `locateDevicePath` function within the UEFI boot services module. This function is used to find devices based on their path information.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
UEFI: boot_services: implement locateDevicePath
```

--------------------------------

TITLE: Zig Noreturn with ExitProcess
DESCRIPTION: Shows how to use the 'noreturn' type with external functions like 'ExitProcess' from kernel32, demonstrating error handling with 'catch ExitProcess'.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const builtin = @import("builtin");
const native_arch = builtin.cpu.arch;
const expect = std.testing.expect;

const WINAPI: std.builtin.CallingConvention = if (native_arch == .i386) .Stdcall else .C;
extern "kernel32" fn ExitProcess(exit_code: c_uint) callconv(WINAPI) noreturn;

test "foo" {
    const value = bar() catch ExitProcess(1);
    try expect(value == 1234);
}

fn bar() anyerror!u32 {
    return 1234;
}
```

--------------------------------

TITLE: Zig: Peer Resolve Array and Slice Conversion
DESCRIPTION: Illustrates peer type resolution for arrays and slices, showing how they can be unified into a common type, such as a const slice. Includes examples for both runtime and compile-time.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;
const mem = std.mem;

test "peer resolve arrays of different size to const slice" {
    assert(mem.eql(u8, boolToStr(true), "true"));
    assert(mem.eql(u8, boolToStr(false), "false"));
    comptime assert(mem.eql(u8, boolToStr(true), "true"));
    comptime assert(mem.eql(u8, boolToStr(false), "false"));
}
fn boolToStr(b: bool) []const u8 {
    return if (b) "true" else "false";
}

test "peer resolve array and const slice" {
    testPeerResolveArrayConstSlice(true);
    comptime testPeerResolveArrayConstSlice(true);
}
fn testPeerResolveArrayConstSlice(b: bool) void {
    const value1 = if (b) "aoeu" else ([]const u8)("zz");
    const value2 = if (b) ([]const u8)("zz") else "aoeu";
    assert(mem.eql(u8, value1, "aoeu"));
    assert(mem.eql(u8, value2, "zz"));
}
```

--------------------------------

TITLE: Zig: Use volatile for Memory Mapped I/O
DESCRIPTION: Demonstrates the use of the `volatile` keyword in Zig to ensure memory-mapped I/O operations are performed as written and in order. This is crucial for interacting with hardware registers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr = @intToPtr(*volatile u8, 0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Fully Anonymous Struct with Type Inference
DESCRIPTION: Illustrates a fully anonymous struct literal where Zig infers the type because the result location does not include a type. The struct contains integer, float, boolean, and string fields.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous struct" {
    try check(.{
        .int = @as(u32, 1234),
        .float = @as(f64, 12.34),
        .b = true,
        .s = "hi",
    });
}

fn check(args: anytype) !void {
    try expect(args.int == 1234);
    try expect(args.float == 12.34);
    try expect(args.b);
    try expect(args.s[0] == 'h');
    try expect(args.s[1] == 'i');
}
```

--------------------------------

TITLE: Zig: Using Namespace with Standard Library
DESCRIPTION: Demonstrates the 'usingnamespace' feature in Zig by importing the entire standard library into a struct's namespace. This allows direct access to standard library components like testing functions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
test "using std namespace" {
    const S = struct {
        usingnamespace @import("std");
    };
    try S.testing.expect(true);
}
```

--------------------------------

TITLE: Zig: Pointer Slicing and Bounds Checking
DESCRIPTION: Demonstrates how to create a slice from an array using start and end indices and how slices provide bounds checking. The example shows that modifying an element through a slice correctly updates the original array, and implies that out-of-bounds access would be caught.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "pointer slicing" {
    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    var start: usize = 2; // var to make it runtime-known
    _ = &start; // suppress 'var is never mutated' error
    const slice = array[start..4];
    try expect(slice.len == 2);

    try expect(array[3] == 4);
    slice[1] += 1;
    try expect(array[3] == 5);
}
```

--------------------------------

TITLE: Zig @fence: Introduce Happens-Before Edges
DESCRIPTION: Introduces happens-before edges between operations based on the specified atomic order. AtomicOrder is available via @import("builtin").AtomicOrder.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: zig
CODE:
```
    @fence(order: AtomicOrder)

The `fence` function is used to introduce happens-before edges between operations.

`AtomicOrder` can be found with `@import("builtin").AtomicOrder`.
```

--------------------------------

TITLE: Zig: Use volatile for Memory Mapped I/O
DESCRIPTION: Demonstrates the use of the `volatile` keyword in Zig to ensure memory-mapped I/O operations are performed as written and in order. This is crucial for interacting with hardware registers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr = @intToPtr(*volatile u8, 0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Basic Slices
DESCRIPTION: This Zig code demonstrates basic slice operations. It shows how to create a slice from an array, access elements using slice indexing, and highlights the difference between a slice's pointer field and the address-of operator. It also illustrates Zig's array bounds checking, which causes a runtime error if an out-of-bounds index is accessed.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const assert = @import("std").debug.assert;

test "basic slices" {
    var array = [_]i32{ 1, 2, 3, 4 };
    const slice = array[0..array.len];
    assert(&slice[0] == &array[0]);
    assert(slice.len == array.len);
    assert(@typeOf(slice.ptr) == [*]i32);
    assert(@typeOf(&slice[0]) == *i32);
    assert(@ptrToInt(slice.ptr) == @ptrToInt(&slice[0]));
    slice[10] += 1;
}
```

--------------------------------

TITLE: Zig: Slice ([]T)
DESCRIPTION: Details the Zig syntax for slices, '[]T', which represent a pointer to a runtime-known number of items. Slices support indexing, slicing, and accessing the 'len' property.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
[]T - pointer to runtime-known number of items.
    * Supports index syntax: slice[i]
    * Supports slice syntax: slice[start..end]
    * Supports len property: slice.len

```

--------------------------------

TITLE: Zig Integers: Literals and Runtime Values
DESCRIPTION: Explains how to define integer literals in Zig and work with integer values at runtime, covering different integer types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
const signed_int = -42;
const unsigned_int = 100u;
const sized_int = i64(50);
const hex_int = 0x1A;
const binary_int = 0b1010;

```

--------------------------------

TITLE: Zig Bitwise And Operator
DESCRIPTION: Performs bitwise AND operation on integers. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig Volatile Pointers
DESCRIPTION: Explains the use of the `volatile` keyword in Zig for memory-mapped I/O (MMIO) or other scenarios where loads and stores must not be optimized away. It demonstrates creating a volatile pointer and asserts its type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.2.0/index.html

LANGUAGE: Zig
CODE:
```
test "volatile" {
        // In Zig, loads and stores are assumed to not have side effects.
        // If a given load or store should have side effects, such as
        // Memory Mapped Input/Output (MMIO), use `volatile`:
        const mmio_ptr = @intToPtr(&volatile u8, 0x12345678);
    
        // Now loads and stores with mmio_ptr are guaranteed to all happen
        // and in the same order as in source code.
        assert(@typeOf(mmio_ptr) == &volatile u8);
    }
```

--------------------------------

TITLE: Fix BigInt Add Failures with Aliasing
DESCRIPTION: Resolves issues with the bigint add operation when aliasing occurs, ensuring correct results for arbitrary-precision integer addition.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Fix bigint add failures with aliasing ([#8330](https://github.com/ziglang/zig/issues/8330)).
```

--------------------------------

TITLE: Zig @atomicStore
DESCRIPTION: Atomically stores a value to a pointer. This built-in function guarantees that the write operation is atomic, crucial for concurrent data structures and algorithms. It supports boolean, float, integer, and enum types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
    @atomicStore(comptime T: type, ptr: *T, value: T, comptime ordering: builtin.AtomicOrder) void
```

--------------------------------

TITLE: Zig Noreturn with ExitProcess
DESCRIPTION: Shows how to use the 'noreturn' type with external functions like 'ExitProcess' from kernel32, demonstrating error handling with 'catch ExitProcess'.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const builtin = @import("builtin");
const native_arch = builtin.cpu.arch;
const expect = std.testing.expect;

const WINAPI: std.builtin.CallingConvention = if (native_arch == .i386) .Stdcall else .C;
extern "kernel32" fn ExitProcess(exit_code: c_uint) callconv(WINAPI) noreturn;

test "foo" {
    const value = bar() catch ExitProcess(1);
    try expect(value == 1234);
}

fn bar() anyerror!u32 {
    return 1234;
}
```

--------------------------------

TITLE: Zig Integer Bitwise AND
DESCRIPTION: Performs a bitwise AND operation on integers. Invokes peer type resolution.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
a & b
a &= b

// Example:
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Operating System and POSIX Wrappers
DESCRIPTION: This snippet covers improvements related to operating system interactions and POSIX wrappers. It includes fixes for `munmap`, `WSAStartup` calls, `atfork` handler robustness, and handling specific error codes like `ECONNRESET`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
os: munmap takes a const pointer
os: WSAStartup is now called upon socket creation when needed
Make atfork handler more robust ([#8841](https://github.com/ziglang/zig/issues/8841)).
Call pthread_atfork only once
add android __SIZEOF_PTHREAD_MUTEX_T ([#8384](https://github.com/ziglang/zig/issues/8384))
add missing EBADF error code for openat
dragonfly: fix duplicate definition of sockaddr_storage
dragonfly: fix duplicate definition of sockaddr_storage
os: add missing sockaddr_storage defs
os: fix sockaddr_storage padding size
Handle EPERM and ELOOP in os.fstatat()
thread: simplify and remove useless return in spawn ([#8621](https://github.com/ziglang/zig/issues/8621))
Fix thread creation with field-less context type ([#8524](https://github.com/ziglang/zig/issues/8524)).
Split syscall parameters for PowerPC targets
os/posix: handle ECONNRESET for write/writev
Add process_vm_readv/writev wrappers
Add pidfd wrappers
linux: fix number of arguments for tgkill syscall
```

--------------------------------

TITLE: Resolve usingnamespace for @typeInfo
DESCRIPTION: Fixes an issue in stage1 where `usingnamespace` declarations were not correctly resolved when calling `@typeInfo`, ensuring accurate type information retrieval.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: zig
CODE:
```
usingnamespace MyNamespace;
const info = @typeInfo(MyType);
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Performs a bitwise AND operation for integers. Invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
a & b
a &= b

// Example:
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Fix Zig Switch with Null and T Peer Types
DESCRIPTION: Resolves issues with `switch` statements involving `null` and `T` peer types, including inferred result location types. This ensures correct control flow and type handling in complex switch cases.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
/* Fixed {#syntax#}switch{#endsyntax#} with {#syntax#}null{#endsyntax#} and T peer types and inferred result location type. [#2762](https://github.com/ziglang/zig/issues/2762) */
```

--------------------------------

TITLE: Zig: Print 'Hello, world!' using std.debug.print
DESCRIPTION: This Zig code snippet demonstrates how to print 'Hello, world!' to standard output using the std.debug.print function. It imports the print function from the standard library's debug module and defines a main function that executes the print statement. The second argument to print is an empty anonymous struct literal, indicating no additional arguments for formatting.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
const print = @import("std").debug.print;

pub fn main() void {
    print("Hello, world!\n", .{});
}
```

--------------------------------

TITLE: Zig Builtin: @bitOffsetOf
DESCRIPTION: Demonstrates the `@bitOffsetOf` builtin function in Zig, which returns the bit offset of a field within a struct. This is useful for manual memory layout manipulation and serialization.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

const MyStruct = struct {
    a: u8,
    b: u16,
};

pub fn main() void {
    const offset_b = @bitOffsetOf(MyStruct, "b");
    std.debug.print("Bit offset of field 'b': {d}", .{offset_b});
}

```

--------------------------------

TITLE: Zig @atomicLoad Example
DESCRIPTION: Provides an example of using the @atomicLoad builtin function in Zig for atomic memory operations. It demonstrates how to atomically dereference a pointer to a type T and retrieve its value, specifying the memory ordering.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
@atomicLoad(comptime T: type, ptr: *const T, comptime ordering: AtomicOrder) T
```

--------------------------------

TITLE: Zig Generics with Compile-Time Parameters
DESCRIPTION: Demonstrates a generic `max` function using `comptime` parameters for different types (f32, u64). This showcases compile-time duck typing in Zig.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: zig
CODE:
```
fn max(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}
fn gimmeTheBiggerFloat(a: f32, b: f32) f32 {
    return max(f32, a, b);
}
fn gimmeTheBiggerInteger(a: u64, b: u64) u64 {
    return max(u64, a, b);
}
```

--------------------------------

TITLE: POSIX Terminals Progress Indicator
DESCRIPTION: For POSIX-compliant terminals, a progress indicator has been implemented to provide visual feedback during long compilation processes. This helps users monitor the build status and estimate completion time.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: shell
CODE:
```
# During a long compilation, a progress indicator will be displayed.
# Example output:
# [=====>.............] 25% compiled
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Performs a bitwise AND operation for integers. Invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: Zig
CODE:
```
a & b
a &= b

// Example:
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Shell: Test Inline Switch for Type Information
DESCRIPTION: Executes the Zig test file that demonstrates the inline switch functionality for checking optional fields using `@typeInfo`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: shell
CODE:
```
$ zig test test_inline_switch.zig
1/1 test.using @typeInfo with runtime values... OK
All 1 tests passed.
```

--------------------------------

TITLE: Zig: Peer Type Resolution for Empty Array and Slice
DESCRIPTION: Explains peer type resolution involving an empty array ('[0]u8') and a slice ('[]const u8'). It shows how Zig can unify these into a common slice type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;

test "peer type resolution: [0]u8 and []const u8" {
    assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
    assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    comptime {
        assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
        assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    }
}
fn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {
    if (a) {
        return []const u8{};
    }

    return slice[0..1];
}
```

--------------------------------

TITLE: Zig Hello World with Stdout
DESCRIPTION: A basic Zig program that prints 'Hello, world!' to standard output. It demonstrates importing the standard library and handling potential I/O errors.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    // If this program is run without stdout attached, exit with an error.
    const stdout_file = try std.io.getStdOut();
    // If this program encounters pipe failure when printing to stdout, exit
    // with an error.
    try stdout_file.write("Hello, world!\n");
}
```

--------------------------------

TITLE: Zig Generics with Compile-Time Parameters
DESCRIPTION: Demonstrates a generic `max` function using `comptime` parameters for type-agnostic comparison. It shows how to use this generic function with different types like `f32` and `u64`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
fn max(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}
fn gimmeTheBiggerFloat(a: f32, b: f32) f32 {
    return max(f32, a, b);
}
fn gimmeTheBiggerInteger(a: u64, b: u64) u64 {
    return max(u64, a, b);
}
```

--------------------------------

TITLE: Zig: Inline Assembly for Hello World
DESCRIPTION: Illustrates the use of inline assembly in Zig to perform system calls on x86_64 Linux. This example implements a 'Hello, World!' program by directly invoking `write` and `exit` system calls.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
pub fn main() noreturn {
    const msg = "hello world\n";
    _ = syscall3(SYS_write, STDOUT_FILENO, @ptrToInt(msg), msg.len);
    _ = syscall1(SYS_exit, 0);
    unreachable;
}

pub const SYS_write = 1;
pub const SYS_exit = 60;

pub const STDOUT_FILENO = 1;

pub fn syscall1(number: usize, arg1: usize) usize {
    return asm volatile ("syscall"
        : [ret] "={rax}" (-> usize)
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1)
        : "rcx", "r11"
    );
}

pub fn syscall3(number: usize, arg1: usize, arg2: usize, arg3: usize) usize {
    return asm volatile ("syscall"
        : [ret] "={rax}" (-> usize)
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
          [arg2] "{rsi}" (arg2),
          [arg3] "{rdx}" (arg3)
        : "rcx", "r11"
    );
}
```

--------------------------------

TITLE: Zig Builtin: @bitOffsetOf
DESCRIPTION: The `@bitOffsetOf` builtin function returns the bit offset of a field within a struct.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
const MyStruct = struct {
    a: u8,
    b: u16,
};
const offset_b = @bitOffsetOf(MyStruct, "b");
// offset_b is 8 (since 'a' is 8 bits)
```

--------------------------------

TITLE: Zig: Implicit @intCast for @intToEnum
DESCRIPTION: Explains a backward-compatible change where `@intToEnum` now implicitly performs `@intCast`. This simplifies calls by allowing any integer operand to be passed, removing the need for explicit `@intCast` in many cases.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const Tag = enum(u8) {
    A,
    B,
};

const number: u32 = 1;

// Old way:
// return @intToEnum(Tag, @intCast(@typeInfo(Tag).Enum.tag_type, number));

// New way:
return @intToEnum(Tag, number);
```

--------------------------------

TITLE: Zig builtin @bytesToSlice
DESCRIPTION: Illustrates the `@bytesToSlice` built-in function in Zig, converting a byte array to a slice.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const bytes: [4]u8 = .{1, 2, 3, 4};
const slice = @bytesToSlice(u8, bytes[0..]);
```

--------------------------------

TITLE: Fix os.rusage Linking with C on Linux
DESCRIPTION: Corrects an issue with `os.rusage` when linking with the C library on Linux. This ensures that resource usage information can be correctly retrieved and linked.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Fixed `os.rusage` when linking with c library on Linux
```

--------------------------------

TITLE: Zig Explicitly Annotate Result Type with @as
DESCRIPTION: Shows how to explicitly define the result type of a cast operation using the @as builtin, which is a fallback when type inference is not sufficient or desired.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
test "explicitly annotate result type with @as" {
  const E = enum(u8) {
    a,
    b
  };
  const x: u8 = 1;
  _ = @as(E, @enumFromInt(x));
}
```

--------------------------------

TITLE: Zig: Anonymous union literal syntax
DESCRIPTION: Shows how to use anonymous struct literal syntax in Zig to initialize unions without explicitly stating the type. Includes a test case to verify initialization.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

const Number = union {
    int: i32,
    float: f64,
};

test "anonymous union literal syntax" {
    var i: Number = .{.int = 42};
    var f = makeNumber();
    try expect(i.int == 42);
    try expect(f.float == 12.34);
}

fn makeNumber() Number {
    return .{.float = 12.34};
}
```

--------------------------------

TITLE: Zig Struct Naming Inference
DESCRIPTION: Demonstrates how Zig infers type names for anonymous structs based on their context, such as variable initialization, return expressions, or default anonymous naming.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
    
    pub fn main() void {
        const Foo = struct {};
        std.debug.print("variable: {}\n", .{@typeName(Foo)});
        std.debug.print("anonymous: {}\n", .{@typeName(struct {})});
        std.debug.print("function: {}\n", .{@typeName(List(i32))});
    }
    
    fn List(comptime T: type) type {
        return struct {
            x: T,
        };
    }

    $ zig build-exe struct_name.zig
    $ ./struct_name
    variable: Foo
    anonymous: struct:6:52
    function: List(i32)
    
```

--------------------------------

TITLE: Zig Function Reflection Example
DESCRIPTION: Demonstrates function reflection in Zig by inspecting the type information of the `expect` function. It checks the argument type and whether the function accepts variable arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "fn reflection" {
    try expect(@typeInfo(@TypeOf(expect)).Fn.args[0].arg_type.? == bool);
    try expect(@typeInfo(@TypeOf(expect)).Fn.is_var_args == false);
}
```

--------------------------------

TITLE: Zig Builtin: @bitOffsetOf
DESCRIPTION: Demonstrates how to get the bit offset of a field within a struct using `@bitOffsetOf`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    const MyStruct = struct {
        a: u8,
        b: u16,
    };
    const offset_b = @bitOffsetOf(MyStruct, .b);
    std.debug.print("Bit offset of field 'b': {d}\\n", .{offset_b});
}
```

--------------------------------

TITLE: Zig: Linux IPv6 socket options
DESCRIPTION: Adds support for IPv6 socket options within the Linux operating system module. This allows for more granular control over IPv6 network communication.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
os/bits/linux: add IPv6 socket options
```

--------------------------------

TITLE: Zig: Add Compile Error for Slice.*.len
DESCRIPTION: Implements a compile-time error check for accessing the `.len` property on slices of undefined types, improving compile-time safety.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
add compile error for slice.*.len ([#1372](https://github.com/ziglang/zig/issues/1372))
```

--------------------------------

TITLE: Zig Bitwise And Operator
DESCRIPTION: Performs bitwise AND operation on integers. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: Zig
CODE:
```
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig WASI: Populate and List Preopens
DESCRIPTION: Shows how to populate and iterate through preopened file descriptors in Zig for WASI environments using `std.fs.wasi.PreopenList`. This allows interaction with the host filesystem.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const PreopenList = std.fs.wasi.PreopenList;

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();

    var preopens = PreopenList.init(gpa);
    defer preopens.deinit();

    try preopens.populate();

    for (preopens.asSlice()) |preopen, i| {
        std.debug.print("{}: {}\n", .{ i, preopen });
    }
}
```

--------------------------------

TITLE: Test Fully Anonymous Struct with Type Inference
DESCRIPTION: Shell command to test the Zig code example for a fully anonymous struct where the type is inferred.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: shell
CODE:
```
$ zig test test_anonymous_struct.zig
1/1 test_anonymous_struct.test.fully anonymous struct... OK
All 1 tests passed.
```

--------------------------------

TITLE: Zig String Literals and Slice Manipulation
DESCRIPTION: Demonstrates how Zig treats string literals as null-terminated byte arrays and how to use slice syntax to manipulate them. It includes an example of string concatenation using fmt.bufPrint.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const fmt = std.fmt;
const mem = std.mem;
const expect = std.testing.expect;

test "using slices for strings" {
        // Zig has no concept of strings. String literals are const pointers
        // to null-terminated arrays of u8, and by convention parameters
        // that are "strings" are expected to be UTF-8 encoded slices of u8.
        // Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8
        const hello: []const u8 = "hello";
        const world: []const u8 = "";
    
        var all_together: [100]u8 = undefined;
        // You can use slice syntax on an array to convert an array into a slice.
        const all_together_slice = all_together[0..];
        // String concatenation example.
        const hello_world = try fmt.bufPrint(all_together_slice, "{s} {s}", .{ hello, world });
    
        // Generally, you can use UTF-8 and not worry about whether something is a
        // string. If you don't need to deal with individual characters, no need
        // to decode.
        try expect(mem.eql(u8, hello_world, "hello "));
    }
    
test "slice pointer" {
        var array: [10]u8 = undefined;
        const ptr = &array;
    
        // You can use slicing syntax to convert a pointer into a slice:
        const slice = ptr[0..5];
        slice[2] = 3;
        try expect(slice[2] == 3);
        // The slice is mutable because we sliced a mutable pointer.
        // Furthermore, it is actually a pointer to an array, since the start
        // and end indexes were both comptime-known.
        try expect(@TypeOf(slice) == *[5]u8);
    
        // You can also slice a slice:
        const slice2 = slice[2..3];
        try expect(slice2.len == 1);
        try expect(slice2[0] == 3);
    }
```

--------------------------------

TITLE: Empty Switch Compile Error and Channel Buffer Wrapping
DESCRIPTION: A compile error is now emitted for an empty switch on an integer. Also, correct buffer wrapping logic is implemented in std.event.Channel.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

var channel = std.event.Channel(i32).init(std.heap.page_allocator, 10);
channel.sendSync(1);
const value = channel.receiveSync();
```

--------------------------------

TITLE: Zig: Type-Safe Union Iteration with `inline else`
DESCRIPTION: Compares Zig's `inline for` with `inline else` for iterating over union fields. `inline else` provides a type-safe alternative, ensuring all cases are handled, unlike `inline for` which requires an explicit `unreachable`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

const SliceTypeA = extern struct {
    len: usize,
    ptr: [*]u32,
};
const SliceTypeB = extern struct {
    ptr: [*]SliceTypeA,
    len: usize,
};
const AnySlice = union(enum) {
    a: SliceTypeA,
    b: SliceTypeB,
    c: []const u8,
    d: []AnySlice,
};

fn withFor(any: AnySlice) usize {
    const Tag = @typeInfo(AnySlice)."union".tag_type.?;
    inline for (@typeInfo(Tag)."enum".fields) |field| {
        // With `inline for` the function gets generated as
        // a series of `if` statements relying on the optimizer
        // to convert it to a switch.
        if (field.value == @intFromEnum(any)) {
            return @field(any, field.name).len;
        }
    }
    // When using `inline for` the compiler doesn't know that every
    // possible case has been handled requiring an explicit `unreachable`.
    unreachable;
}

fn withSwitch(any: AnySlice) usize {
    return switch (any) {
        // With `inline else` the function is explicitly generated
        // as the desired switch and the compiler can check that
        // every possible case is handled.
        inline else => |slice| slice.len,
    };
}

test "inline for and inline else similarity" {
    const any = AnySlice{ .c = "hello" };
    try expect(withFor(any) == 5);
    try expect(withSwitch(any) == 5);
}
```

--------------------------------

TITLE: Zig Struct Naming Inference
DESCRIPTION: Demonstrates how Zig infers type names for anonymous structs based on their context, such as variable initialization, return expressions, or default anonymous naming.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
    
    pub fn main() void {
        const Foo = struct {};
        std.debug.print("variable: {}\n", .{@typeName(Foo)});
        std.debug.print("anonymous: {}\n", .{@typeName(struct {})});
        std.debug.print("function: {}\n", .{@typeName(List(i32))});
    }
    
    fn List(comptime T: type) type {
        return struct {
            x: T,
        };
    }

    $ zig build-exe struct_name.zig
    $ ./struct_name
    variable: Foo
    anonymous: struct:6:52
    function: List(i32)
    
```

--------------------------------

TITLE: Fix tanh for Negative Inputs and NaN
DESCRIPTION: Corrects the `tanh` function to produce accurate results for negative inputs and also addresses the NaN codepath by adding missing logic. This rectifies issues stemming from an incorrect C port.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Fix tanh for negative inputs ([#9047](https://github.com/ziglang/zig/issues/9047)).  
    It turns out the code was not ported correctly from C and produced wrong results for negative input values. As a bonus fix the NaN codepath by adding yet another missing piece of code.
```

--------------------------------

TITLE: Zig Doc Comments for Structs and Functions
DESCRIPTION: Demonstrates the use of documentation comments (`///`) in Zig for documenting structs, their fields, and their methods. It shows how multiple `///` comments are merged into a multiline doc comment.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: Zig
CODE:
```
/// A structure for storing a timestamp, with nanosecond precision (this is a
/// multiline doc comment).
const Timestamp = struct {
    /// The number of seconds since the epoch (this is also a doc comment).
    seconds: i64,  // signed so we can represent pre-1970 (not a doc comment)
    /// The number of nanoseconds past the second (doc comment again).
    nanos: u32,

    /// Returns a `Timestamp` struct representing the Unix epoch; that is, the
    /// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).
    pub fn unixEpoch() Timestamp {
        return Timestamp{
            .seconds = 0,
            .nanos = 0,
        };
    }
};
```

--------------------------------

TITLE: Zig: Generic List Data Structure using Comptime
DESCRIPTION: Illustrates how Zig uses comptime to create generic data structures without special syntax. The `List` function takes a type `T` as a comptime parameter and returns an anonymous struct representing a list of elements of type `T`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
fn List(comptime T: type) type {
    return struct {
        items: []T,
        len: usize,
    };
}

// The generic List data structure can be instantiated by passing in a type:
var buffer: [10]i32 = undefined;
var list = List(i32){
    .items = &buffer,
    .len = 0,
};
```

--------------------------------

TITLE: Zig: Atomic Fence
DESCRIPTION: Introduces happens-before edges between operations. The 'order' parameter specifies the atomic memory ordering.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: Zig
CODE:
```
@fence(order: AtomicOrder) void
```

--------------------------------

TITLE: Zig Formatted Printing Enhancements
DESCRIPTION: This section details improvements to Zig's formatted printing capabilities, including better formatting for tuple types, clearer compile errors for unsupported format strings, support for printing slice strings, and fixes for float formatting. It also introduces case sensitivity for format functions and improved error messages for missing arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
#std.fmt: Better formatting of tuple types by skipping the useless type name and the numeric field names.
#Added name of type in unsupport format string compile error.
#Added support for printing slices strings
#Fixed float formatting for 0.0 when precision is 0
#Format functions take case as an enum.
#Improved error message when there are missing arguments.
#Added `fmt.fmtDurationSigned`.
#Fixed endless loop, working around a Bootstrap Compiler bug that may sometimes lead to an endless loop being generated when unrolling the fmt impl
```

--------------------------------

TITLE: Zig Function for Base64 Decoding with C ABI
DESCRIPTION: Provides a Zig function signature for decoding base64, designed to be exported with the C ABI. It specifies pointer types for destination and source buffers and their lengths, adhering to C conventions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
const base64 = @import("std").base64;

export fn decode_base_64(
    dest_ptr: [*]u8,
    dest_len: usize,
    source_ptr: [*]const u8,
    source_len: usize,
) usize {
    const src = source_ptr[0..source_len];

```

--------------------------------

TITLE: Zig Old Streams API Example
DESCRIPTION: Demonstrates reading lines from standard input and calculating a sum using the older Zig streams API. This code is provided as a reference for comparison with the new API.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() anyerror!void {
    var stdin_unbuf = std.io.getStdIn().inStream();
    // damn that is pretty painful, isn't it?
    const in = &std.io.BufferedInStream(@TypeOf(stdin_unbuf).Error).init(&stdin_unbuf.stream).stream;

    var sum: u64 = 0;
    var line_buf: [50]u8 = undefined;
    while (try in.readUntilDelimiterOrEof(&line_buf, '\n')) |line| {
        if (line.len == 0) break;
        const module_mass = try std.fmt.parseInt(u64, line, 10);
        const fuel_required = (module_mass / 3) - 2;
        sum += fuel_required;
    }

    const out = &std.io.getStdOut().outStream().stream;
    try out.print("{}\\n", .{sum});
}
```

--------------------------------

TITLE: Convert integer to pointer with @intToPtr
DESCRIPTION: The @intToPtr function converts an integer address to a pointer of a specified destination type. If the destination pointer type disallows address zero and the provided address is zero, it results in safety-checked Undefined Behavior. Use @ptrToInt for the reverse conversion.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
@intToPtr(comptime DestType: type, address: usize) DestType
```

--------------------------------

TITLE: Zig Bitwise And Operator
DESCRIPTION: Performs bitwise AND operation on integers. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: Zig
CODE:
```
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig Fully Anonymous Struct Literal
DESCRIPTION: Illustrates a fully anonymous struct literal where the type is inferred by Zig. The literal is passed to a generic 'check' function, demonstrating type inference and value validation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous struct" {
    try check(.{
        .int = @as(u32, 1234),
        .float = @as(f64, 12.34),
        .b = true,
        .s = "hi",
    });
}

fn check(args: anytype) !void {
    try expect(args.int == 1234);
    try expect(args.float == 12.34);
    try expect(args.b);
    try expect(args.s[0] == 'h');
    try expect(args.s[1] == 'i');
}
```

--------------------------------

TITLE: Fix alignment in std.Thread.Futex.PosixImpl.Address.from
DESCRIPTION: Ensures correct alignment for the Address.from method within std.Thread.Futex.PosixImpl.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.1/release-notes.html

LANGUAGE: Zig
CODE:
```
std.Thread.Futex.PosixImpl.Address.from: fix `alignment` type
```

--------------------------------

TITLE: Zig: Print 'Hello, world!' using std.debug.print
DESCRIPTION: This Zig code snippet demonstrates how to print 'Hello, world!' to standard output using the std.debug.print function. It imports the print function from the standard library's debug module and defines a main function that executes the print statement. The second argument to print is an empty anonymous struct literal, indicating no additional arguments for formatting.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
const print = @import("std").debug.print;

pub fn main() void {
    print("Hello, world!\n", .{});
}
```

--------------------------------

TITLE: Zig Translate-C: Dereference Pointers Implicitly
DESCRIPTION: The translation process now implicitly handles pointer dereferencing, removing the need for manual unwrapping and preventing potential bugs.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: C
CODE:
```
* Don't bother with unwrapping pointers. Dereferencing a c pointer implicitly includes an unwrap, manually adding it just causes bugs.
```

--------------------------------

TITLE: Zig Compiler Command Line Options for Code Emission
DESCRIPTION: A set of command-line flags for controlling the Zig compiler's output. These options allow users to specify whether to emit binary code, assembly, LLVM IR, or C header files, or to disable these emissions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
-femit-bin
```

LANGUAGE: Zig
CODE:
```
-fno-emit-bin
```

LANGUAGE: Zig
CODE:
```
-femit-asm
```

LANGUAGE: Zig
CODE:
```
-fno-emit-asm
```

LANGUAGE: Zig
CODE:
```
-femit-llvm-ir
```

LANGUAGE: Zig
CODE:
```
-fno-emit-llvm-ir
```

LANGUAGE: Zig
CODE:
```
-femit-h
```

LANGUAGE: Zig
CODE:
```
-fno-emit-h
```

--------------------------------

TITLE: GET /zig/<filename>
DESCRIPTION: Retrieves Zig tarballs from a community mirror. The mirror's behavior depends on the filename and the Zig version it represents.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/MIRRORS.md

LANGUAGE: APIDOC
CODE:
```
## GET /zig/<filename>

### Description
Fetches a Zig tarball from the mirror. The mirror determines whether to serve the file directly, respond with a 404, or fetch it from the official Zig repository based on the filename and version.

### Method
GET

### Endpoint
`X/<filename>`

Where `X` is the base URL of the mirror.

### Parameters
#### Path Parameters
- **filename** (string) - Required - The name of the tarball file to retrieve (e.g., `zig-0.14.1.tar.xz`, `zig-x86_64-linux-0.15.0-dev.671+c907866d5.tar.xz`).

#### Query Parameters
- **source** (string) - Optional - Identifies the origin of the request (e.g., `github-mlugg-setup-zig`).

### Request Example
```http
GET /zig/zig-0.14.1.tar.xz HTTP/1.1
Host: mirror.example.com
```

### Response
#### Success Response (200 OK)
- The requested tarball file.

#### Error Responses
- **404 Not Found**: If the filename does not match the expected schema or if the mirror chooses not to serve a specific version (especially older pre-releases).
- **429 Too Many Requests**: If the request is rate-limited.
- **503 Unavailable**: If the mirror is down for scheduled maintenance.
- **504 Gateway Timeout**: If the mirror fails to retrieve the file from the official Zig repository.
```

--------------------------------

TITLE: Zig Bitwise AND Operator
DESCRIPTION: Performs a bitwise AND operation for integers. Invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
a & b
a &= b

// Example:
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Add Missing Bitcast for Var Ptr Rendering
DESCRIPTION: Includes a missing `bitcast` when rendering a variable pointer in stage1. This is necessary for types like structs or unions with compiler-inserted padding fields.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: zig
CODE:
```
const ptr = &my_struct;
const void_ptr = @bitcast(*void, ptr);
```

--------------------------------

TITLE: Zig POSIX API Adjustments for Cross-Platform Compatibility
DESCRIPTION: This code snippet demonstrates how Zig's POSIX APIs are adjusted based on the native architecture. It defines a packed struct `tc_lflag_t` with different field layouts for various architectures like powerpc, mips, and others, ensuring compatibility and correct interpretation of terminal flags across different systems.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: zig
CODE:
```
pub const tc_lflag_t = switch (native_arch) {
    .powerpc, .powerpcle, .powerpc64, .powerpc64le => packed struct(u32) {
        _0: u1 = 0,
        ECHOE: bool = false,
        ECHOK: bool = false,
        ECHO: bool = false,
        ECHONL: bool = false,
        _5: u2 = 0,
        ISIG: bool = false,
        ICANON: bool = false,
        _9: u1 = 0,
        IEXTEN: bool = false,
        _11: u11 = 0,
        TOSTOP: bool = false,
        _23: u8 = 0,
        NOFLSH: bool = false,
    },
    .mips, .mipsel, .mips64, .mips64el => packed struct(u32) {
        ISIG: bool = false,
        ICANON: bool = false,
        _2: u1 = 0,
        ECHO: bool = false,
        ECHOE: bool = false,
        ECHOK: bool = false,
        ECHONL: bool = false,
        NOFLSH: bool = false,
        IEXTEN: bool = false,
        _9: u6 = 0,
        TOSTOP: bool = false,
        _: u16 = 0,
    },
    else => packed struct(u32) {
        ISIG: bool = false,
        ICANON: bool = false,
        _2: u1 = 0,
        ECHO: bool = false,
        ECHOE: bool = false,
        ECHOK: bool = false,
        ECHONL: bool = false,
        NOFLSH: bool = false,
        TOSTOP: bool = false,
        _9: u6 = 0,
        IEXTEN: bool = false,
        _: u16 = 0,
    },
};
```

--------------------------------

TITLE: Zig Function Reflection Example
DESCRIPTION: Demonstrates function reflection in Zig by inspecting the type information of the `expect` function. It checks the argument type and whether the function accepts variable arguments.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "fn reflection" {
    try expect(@typeInfo(@TypeOf(expect)).Fn.args[0].arg_type.? == bool);
    try expect(@typeInfo(@TypeOf(expect)).Fn.is_var_args == false);
}
```

--------------------------------

TITLE: Zig: @memcpy Usage with Slices and Many-Pointers
DESCRIPTION: Demonstrates the usage of Zig's built-in `@memcpy` function. This example shows copying between two slices of equal length and copying from a many-pointer to a slice, highlighting the function's flexibility.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
test "@memcpy usage" {
    const a: [4]u32 = .{ 1, 2, 3, 4 };
    var b: [4]u32 = undefined;
    @memcpy(&b, &a);
    try std.testing.expectEqualSlices(u32, &a, &b);
    // If the second operand is a many-ptr, the length is taken from the first operand
    var c: [4]u32 = undefined;
    const a_manyptr: [*]const u32 = (&a).ptr;
    @memcpy(&c, a_manyptr);
    try std.testing.expectEqualSlices(u32, &a, &c);
}
```

--------------------------------

TITLE: Zig: Pointer Casting and Type Information
DESCRIPTION: Demonstrates unsafe pointer casting using @ptrCast and alternative methods like slice narrowing and @bitCast for type conversions. It also shows how to access pointer type information, specifically the 'child' field which indicates the type the pointer points to.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "pointer casting" {
    const bytes align(@alignOf(u32)) = [_]u8{ 0x12, 0x12, 0x12, 0x12 };
    const u32_ptr = @ptrCast(*const u32, &bytes);
    expect(u32_ptr.* == 0x12121212);

    // Even this example is contrived - there are better ways to do the above than
    // pointer casting. For example, using a slice narrowing cast:
    const u32_value = std.mem.bytesAsSlice(u32, bytes[0..])[0];
    expect(u32_value == 0x12121212);

    // And even another way, the most straightforward way to do it:
    expect(@bitCast(u32, bytes) == 0x12121212);
}

test "pointer child type" {
    // pointer types have a `child` field which tells you the type they point to.
    expect(@typeInfo(*u32).Pointer.child == u32);
}
```

--------------------------------

TITLE: Zig Opaque Type Declaration and C Interop
DESCRIPTION: Illustrates the use of `opaque {}` in Zig to declare types with unknown size and alignment, primarily for safe interaction with C code. It shows how to define opaque types and use them in function signatures, highlighting potential type casting errors.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Fix Invalid LLVM IR for ?*void Const Casts
DESCRIPTION: Addresses the generation of invalid LLVM IR for constant casts involving `?*void`. This ensures that the generated intermediate representation is correct for type conversions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
/* Fix invalid LLVM IR generated for {#syntax#}?*void{#endsyntax#} const casts. [#2578](https://github.com/ziglang/zig/issues/2578) */
```

--------------------------------

TITLE: Convert integer to pointer with @intToPtr
DESCRIPTION: The @intToPtr function converts an integer address to a pointer of a specified destination type. If the destination pointer type disallows address zero and the provided address is zero, it results in safety-checked Undefined Behavior. Use @ptrToInt for the reverse conversion.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
@intToPtr(comptime DestType: type, address: usize) DestType
```

--------------------------------

TITLE: Zig Volatile Memory Access
DESCRIPTION: Illustrates the use of the `volatile` keyword in Zig for memory-mapped input/output (MMIO). Loads and stores marked as volatile are guaranteed to occur and maintain their order as specified in the source code.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig Result Type Propagation in Struct Initializer
DESCRIPTION: Demonstrates how Zig's result type propagation works within a struct initializer. The example shows how the type of a struct field influences the expected type of an expression assigned to it, utilizing @intCast for type conversion.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
const expectEqual = @import("std").testing.expectEqual;
test "result type propagates through struct initializer" {
    const S = struct { x: u32 };
    const val: u64 = 123;
    const s: S = .{ .x = @intCast(val) };
    // .{ .x = @intCast(val) }   has result type `S` due to the type annotation
    //         @intCast(val)     has result type `u32` due to the type of the field `S.x`
    //                  val      has no result type, as it is permitted to be any integer type
    try expectEqual(@as(u32, 123), s.x);
}
```

--------------------------------

TITLE: Zig Bitwise OR Operator
DESCRIPTION: Performs a bitwise OR operation for integers. Invokes Peer Type Resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
a | b
a |= b
```

--------------------------------

TITLE: Fix BigInt Shift Operation
DESCRIPTION: Addresses a bug in the bigint_shl function, ensuring correct behavior for bitwise shift operations on arbitrary-precision integers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
Fix bigint_shl ([#9305](https://github.com/ziglang/zig/issues/9305)).
```

--------------------------------

TITLE: Zig Atomics Store
DESCRIPTION: Illustrates atomic store operations in Zig, enabling thread-safe writing to memory. This guarantees that writes are completed indivisibly, maintaining data integrity in concurrent scenarios.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Atomic(u32) = .{ .value = 0 };
    std.atomic.store(u32, &atomic_var, 20, .SeqCst);
    const value = std.atomic.load(u32, &atomic_var, .SeqCst);
    std.debug.print("Atomic store value: {d}", .{value});
}

```

--------------------------------

TITLE: Zig Integer Literals and Runtime Values
DESCRIPTION: Demonstrates various ways to represent integer literals in Zig, including decimal, hexadecimal, binary, and octal formats, and how these translate to runtime values.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.1/index.html

LANGUAGE: zig
CODE:
```
const decimal_int = 100;
const hex_int = 0x64;
const binary_int = 0b01100100;
const octal_int = 0144;

const signed_int = -50;
const unsigned_int: u8 = 200;
```

--------------------------------

TITLE: Linking: Avoid passing -l arguments for .a or .o files
DESCRIPTION: Corrects the linker behavior by preventing the passing of `-l` arguments when building `.a` (static library) or `.o` (object) files. This ensures that the linker is not incorrectly instructed to link against libraries when creating these intermediate artifacts.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: Shell
CODE:
```
# Conceptual build command for a static library
# zig build-lib --name mylib src/mylib.c -lotherlib (Incorrect behavior)

# Corrected behavior: -lotherlib is not passed when building .a or .o
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to use Zig's standard library to read command-line arguments when compiling for WASI. It allocates memory for arguments, iterates through them, and prints each argument with its index. The example includes the shell commands to build and run the Zig code using `wasm32-wasi` target and `wasmtime`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Zig Generic List Data Structure
DESCRIPTION: Defines a generic List data structure in Zig that can hold elements of any type. It returns an anonymous struct with an items slice and a length.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
fn List(comptime T: type) type {
    return struct {
        items: []T,
        len: usize,
    };
}
```

--------------------------------

TITLE: Zig @atomicLoad: Atomic Pointer Dereference
DESCRIPTION: The @atomicLoad function atomically dereferences a pointer, returning its value. It supports various types and atomic ordering constraints.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: zig
CODE:
```
T @atomicLoad(comptime T: type, ptr: *const T, comptime ordering: builtin.AtomicOrder) T
```

--------------------------------

TITLE: Zig @export with Field Access
DESCRIPTION: The `@export` feature in Zig now allows field access expressions in addition to identifiers for declarations. This means you can export functions or variables accessed through struct fields, like `x.y`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
x
```

LANGUAGE: Zig
CODE:
```
x.y
```

--------------------------------

TITLE: Fix Linux stdlib RW Flags
DESCRIPTION: Corrects the definition of Read/Write (RW) flags in the Linux standard library bindings, ensuring proper file access control.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.1/release-notes.html

LANGUAGE: Zig
CODE:
```
linux stdlib: fix definition of RW flags ([#9428](https://github.com/ziglang/zig/issues/9428)).
```

--------------------------------

TITLE: Zig C String Literals
DESCRIPTION: Shows how to use C-style string literals in Zig, which are null-terminated and can span multiple lines. These are useful for interacting with C functions that expect C strings.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.1.1/index.html

LANGUAGE: c
CODE:
```
extern fn puts(&const u8);

pub fn main() -> %void {
    puts(c"this has a null terminator");
    puts(
        c\and so
        c\does this
        c\multiline C string literal
    );
}
```

--------------------------------

TITLE: Zig: Linux ECONNRESET handling for connect/recv
DESCRIPTION: Implements handling for the `ECONNRESET` error code in the Linux operating system module for both `connect()` and `recv()` system calls. This improves the robustness of network operations by correctly managing connection reset events.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: Zig
CODE:
```
os: handle ECONNRESET for connect() syscall
```

LANGUAGE: Zig
CODE:
```
os.linux: handle ECONNRESET for recv
```

--------------------------------

TITLE: Base-2 Exponential with @exp2
DESCRIPTION: Details the @exp2 function for calculating the base-2 exponential of floating-point numbers and vectors of floats, mentioning hardware acceleration and potential implementation caveats.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
@exp2(value: anytype) @TypeOf(value)
```

--------------------------------

TITLE: Zig Translate-C: Fix Args for clang::ASTUnit::LoadFromCommandLine
DESCRIPTION: Arguments passed to `clang::ASTUnit::LoadFromCommandLine` have been fixed, resolving issues with how the Clang AST is loaded.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: C
CODE:
```
* Fix args when calling `clang::ASTUnit::LoadFromCommandLine`.
```

--------------------------------

TITLE: Zig Opaque Type Declaration and C Interop
DESCRIPTION: Illustrates the use of `opaque {}` in Zig to declare types with unknown size and alignment, primarily for safe interaction with C code. It shows how to define opaque types and use them in function signatures, highlighting potential type casting errors.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```

--------------------------------

TITLE: Handle Structs with Comptime Fields Correctly (Zig)
DESCRIPTION: Improves how structs containing fields that require comptime (like `type`) are handled. Such structs are now correctly marked as requiring comptime themselves, affecting function calls that return them.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
// Example demonstrating the behavior change:
const std = @import("std");

// Struct requiring comptime due to 'type' field
const ComptimeStruct = struct {
    data: type,
};

// Function returning a struct that requires comptime
fn getComptimeStruct() ComptimeStruct {
    return ComptimeStruct{ .data = u32 };
}

// This function would implicitly be called at comptime
fn processComptimeStruct() void {
    const instance = getComptimeStruct();
    // ... process instance ...
}

```

--------------------------------

TITLE: Testing Inferred Anonymous Struct Execution
DESCRIPTION: Shell command to execute the Zig test file 'struct_anon.zig', which verifies the functionality of inferred anonymous struct literals.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: shell
CODE:
```
$ zig test struct_anon.zig
1/1 test "fully anonymous struct"... OK
All 1 tests passed.
```

--------------------------------

TITLE: Zig: Data Structure Enhancements
DESCRIPTION: Improves the functionality and consistency of data structures like `ArrayList` and `PriorityQueue`. This includes making `ArrayList(u0)` functional and refining the API for `PriorityQueue`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
ArrayList(u0) works now. This type still tracks length, but does not allocate additional memory.
DynamicBitSet.iterator takes self as const.
PriorityQueue: moved compareFn from init to type constructor in PriorityQueue and PriorityDequeue. This change significantly improves performance for simple compare functions and modifies the API to be more consistent with e.g. HashMap.
MultiArrayList: get function take self by value.
```

--------------------------------

TITLE: Zig: Swap Array Elements with Result Location Interference
DESCRIPTION: Demonstrates how Zig's result location system can interfere with direct array element swapping using an aggregate initializer. The test case shows that the naive swap fails because the intermediate assignment overwrites the original value before it can be used in the second assignment.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;
test "attempt to swap array elements with array initializer" {
    var arr: [2]u32 = .{ 1, 2 };
    arr = .{ arr[1], arr[0] };
    // The previous line is equivalent to the following two lines:
    //   arr[0] = arr[1];
    //   arr[1] = arr[0];
    // So this fails!
    try expect(arr[0] == 2); // succeeds
    try expect(arr[1] == 1); // fails
}
```

--------------------------------

TITLE: Zig Struct Methods (Dot Product Example)
DESCRIPTION: Demonstrates how to define and use methods within Zig structs. This example defines a Vec3 struct with an init constructor and a dot product method, showing both direct method calls and referencing methods as declarations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.2.0/index.html

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;

// Structs can have methods
// Struct methods are not special, they are only namespaced
// functions that you can call with dot syntax.
const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    pub fn init(x: f32, y: f32, z: f32) Vec3 {
        return Vec3 {
            .x = x,
            .y = y,
            .z = z,
        };
    }

    pub fn dot(self: &const Vec3, other: &const Vec3) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

test "dot product" {
    const v1 = Vec3.init(1.0, 0.0, 0.0);
    const v2 = Vec3.init(0.0, 1.0, 0.0);
    assert(v1.dot(v2) == 0.0);

    // Other than being available to call with dot syntax, struct methods are
    // not special. You can reference them as any other declaration inside
    // the struct:
    assert(Vec3.dot(v1, v2) == 0.0);
}
```

--------------------------------

TITLE: Zig Integer-to-Pointer and Pointer-to-Integer Conversion
DESCRIPTION: Explains and demonstrates the use of `@intToPtr` to convert an integer address to a pointer and `@ptrToInt` to convert a pointer back to an integer (usize).

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "@ptrToInt and @intToPtr" {
    const ptr = @intToPtr(*i32, 0xdeadbee0);
    const addr = @ptrToInt(ptr);
    try expect(@TypeOf(addr) == usize);
    try expect(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Zig Packed Structs: BitCast Between Packed Structs
DESCRIPTION: Demonstrates using @bitCast to reinterpret data between different packed struct layouts in Zig. It includes tests for both runtime and compile-time execution, verifying the correct interpretation of fields based on endianness.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const native_endian = @import("builtin").target.cpu.arch.endian();
const expect = std.testing.expect;

const Full = packed struct {
    number: u16,
};
const Divided = packed struct {
    half1: u8,
    quarter3: u4,
    quarter4: u4,
};

test "@bitCast between packed structs" {
    try doTheTest();
    try comptime doTheTest();
}

fn doTheTest() !void {
    try expect(@sizeOf(Full) == 2);
    try expect(@sizeOf(Divided) == 2);
    const full = Full{ .number = 0x1234 };
    const divided: Divided = @bitCast(full);
    try expect(divided.half1 == 0x34);
    try expect(divided.quarter3 == 0x2);
    try expect(divided.quarter4 == 0x1);

    const ordered: [2]u8 = @bitCast(full);
    switch (native_endian) {
        .big => {
            try expect(ordered[0] == 0x12);
            try expect(ordered[1] == 0x34);
        },
        .little => {
            try expect(ordered[0] == 0x34);
            try expect(ordered[1] == 0x12);
        },
    }
}
```

--------------------------------

TITLE: Zig Volatile Memory Access
DESCRIPTION: Demonstrates the use of `volatile` for memory-mapped I/O in Zig. It shows how to create a volatile pointer and check its type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr = @intToPtr(*volatile u8, 0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```

--------------------------------

TITLE: Zig: String Literals and Concatenation with Slices
DESCRIPTION: Illustrates how Zig handles string literals as null-terminated UTF-8 byte slices and demonstrates concatenation using `std.fmt.bufPrint` with slices. It shows coercing pointer types to slices and performing operations on them.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const mem = std.mem;
const fmt = std.fmt;

test "using slices for strings" {
    // Zig has no concept of strings. String literals are const pointers
    // to null-terminated arrays of u8, and by convention parameters
    // that are "strings" are expected to be UTF-8 encoded slices of u8.
    // Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8
    const hello: []const u8 = "hello";
    const world: []const u8 = "";

    var all_together: [100]u8 = undefined;
    // You can use slice syntax with at least one runtime-known index on an
    // array to convert an array into a slice.
    var start : usize = 0;
    const all_together_slice = all_together[start..];
    // String concatenation example.
    const hello_world = try fmt.bufPrint(all_together_slice, "{s} {s}", .{ hello, world });

    // Generally, you can use UTF-8 and not worry about whether something is a
    // string. If you don't need to deal with individual characters, no need
    // to decode.
    try expect(mem.eql(u8, hello_world, "hello "));
}
```

--------------------------------

TITLE: Zig: Integer-Pointer Conversion Functions
DESCRIPTION: Demonstrates the use of `@ptrFromInt` to convert an integer address to a pointer and `@intFromPtr` to convert a pointer back to a `usize` integer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "@intFromPtr and @ptrFromInt" {
    const ptr: *i32 = @ptrFromInt(0xdeadbee0);
    const addr = @intFromPtr(ptr);
    try expect(@TypeOf(addr) == usize);
    try expect(addr == 0xdeadbee0);
}
```

--------------------------------

TITLE: Zig Tuple Operations Test
DESCRIPTION: Demonstrates the usage of tuples in Zig, which are anonymous structs without field names. The example showcases tuple creation, concatenation, indexing using numeric field names (prefixed with '@'), inline iteration, and checking the tuple's length.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "tuple" {
    const values = .{ 
        @as(u32, 1234),
        @as(f64, 12.34),
        true,
        "hi",
    } ++ .{false} ** 2;
    try expect(values[0] == 1234);
    try expect(values[4] == false);
    inline for (values, 0..) |v, i| {
        if (i != 2) continue;
        try expect(v);
    }
    try expect(values.len == 6);
    try expect(values.@"3"[0] == 'h');
}
```

--------------------------------

TITLE: Zig Bitwise And Operator
DESCRIPTION: Performs bitwise AND operation on integers. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig Bitwise And Operator
DESCRIPTION: Performs bitwise AND operation on integers. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: Zig
CODE:
```
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Introduce Memory Fences with @fence
DESCRIPTION: The @fence function is used to establish happens-before relationships between operations. The 'order' parameter specifies the atomic memory ordering, which can be imported from '@import("builtin").AtomicOrder'.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: zig
CODE:
```
@fence(order: AtomicOrder)
```

--------------------------------

TITLE: NetBSD: Add termios constants to std.c.netbsd
DESCRIPTION: Essential termios constants have been added to `std.c.netbsd`. These constants are used for controlling terminal I/O characteristics, enabling more advanced terminal manipulation in Zig programs on NetBSD.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.c.netbsd.termios
```

--------------------------------

TITLE: Zig Extern Struct for C ABI Compatibility
DESCRIPTION: Explains the use of `extern struct` in Zig for ensuring memory layout compatibility with the C ABI. It's recommended only for C interoperability, with `packed struct` or normal `struct` preferred for other use cases.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: Zig
CODE:
```
An `extern struct` has in-memory layout guaranteed to match the C ABI for the target.

This kind of struct should only be used for compatibility with the C ABI. Every other use case should be solved with [packed struct](#packed-struct) or normal [struct](#struct).

See also:

*   [extern union](#extern-union)
*   [extern enum](#extern-enum)
```

--------------------------------

TITLE: Zig: Destructure Array, Vector, and Tuple
DESCRIPTION: This Zig code provides examples of destructuring aggregates like arrays, vectors, and tuples. It demonstrates how to assign elements of these aggregates to multiple lvalues or local variables on the left side of an assignment.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.12.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;
const expectEqual = std.testing.expectEqual;

test "destructure array" {
    var z: u32 = undefined;
    const x, var y, z = [3]u32{ 1, 2, 3 };
    y += 10;
    try expectEqual(1, x);
    try expectEqual(12, y);
    try expectEqual(3, z);
}

test "destructure vector" {
    // Comptime-known values are propagated as you would expect.
    const x, const y = @Vector(2, u32){ 1, 2 };
    comptime assert(x == 1);
    comptime assert(y == 2);
}

test "destructure tuple" {
    var runtime: u32 = undefined;
    runtime = 123;
    const x, const y = .{ 42, runtime };
    // The first tuple field is a `comptime` field, so `x` is comptime-known even
    // though `y` is runtime-known.
    comptime assert(x == 42);
    try expectEqual(123, y);
}
```

--------------------------------

TITLE: Zig: Pointer Casting and Type Information
DESCRIPTION: Demonstrates unsafe pointer casting using @ptrCast and alternative methods like slice narrowing and @bitCast for type conversions. It also shows how to access pointer type information, specifically the 'child' field which indicates the type the pointer points to.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "pointer casting" {
    const bytes align(@alignOf(u32)) = [_]u8{ 0x12, 0x12, 0x12, 0x12 };
    const u32_ptr = @ptrCast(*const u32, &bytes);
    expect(u32_ptr.* == 0x12121212);

    // Even this example is contrived - there are better ways to do the above than
    // pointer casting. For example, using a slice narrowing cast:
    const u32_value = std.mem.bytesAsSlice(u32, bytes[0..])[0];
    expect(u32_value == 0x12121212);

    // And even another way, the most straightforward way to do it:
    expect(@bitCast(u32, bytes) == 0x12121212);
}

test "pointer child type" {
    // pointer types have a `child` field which tells you the type they point to.
    expect(@typeInfo(*u32).Pointer.child == u32);
}
```

--------------------------------

TITLE: Zig: BitCast Between Packed Structs with Different Field Sizes
DESCRIPTION: Demonstrates using @bitCast to reinterpret memory between two packed structs with different field arrangements and sizes. It includes checks for both Big and Little endian systems to ensure correct data interpretation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const builtin = std.builtin;
const assert = std.debug.assert;

const Full = packed struct {
    number: u16,
};
const Divided = packed struct {
    half1: u8,
    quarter3: u4,
    quarter4: u4,
};

test "@bitCast between packed structs" {
    doTheTest();
    comptime doTheTest();
}

fn doTheTest() void {
    assert(@sizeOf(Full) == 2);
    assert(@sizeOf(Divided) == 2);
    var full = Full{ .number = 0x1234 };
    var divided = @bitCast(Divided, full);
    switch (builtin.endian) {
        .Big => {
            assert(divided.half1 == 0x12);
            assert(divided.quarter3 == 0x3);
            assert(divided.quarter4 == 0x4);
        },
        .Little => {
            assert(divided.half1 == 0x34);
            assert(divided.quarter3 == 0x2);
            assert(divided.quarter4 == 0x1);
        },
    }
}
```

--------------------------------

TITLE: Zig Address Of Syntax and Pointer Dereferencing
DESCRIPTION: Illustrates how to obtain pointers to variables using the address-of operator (&) in Zig. It shows dereferencing pointers to read and modify values, and explains the difference between const and mutable pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "address of syntax" {
    // Get the address of a variable:
    const x: i32 = 1234;
    const x_ptr = &x;

    // Dereference a pointer:
    expect(x_ptr.* == 1234);

    // When you get the address of a const variable, you get a const pointer to a single item.
    expect(@TypeOf(x_ptr) == *const i32);

    // If you want to mutate the value, you'd need an address of a mutable variable:
    var y: i32 = 5678;
    const y_ptr = &y;
    expect(@TypeOf(y_ptr) == *i32);
    y_ptr.* += 1;
    expect(y_ptr.* == 5679);
}
```

--------------------------------

TITLE: Zig Async Functions
DESCRIPTION: Zig supports asynchronous programming with `async` and `await` keywords, enabling non-blocking I/O and concurrent task execution. Suspend blocks allow for cooperative multitasking.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example of an async function
async fn fetchData(url: []const u8) ![]const u8 {
    // Simulate fetching data asynchronously
    std.time.sleep(1 * std.time.ns_per_second);
    return "Some fetched data";
}

// Example of using async/await
async fn processData() void {
    const data = await fetchData("http://example.com");
    std.debug.print("Received: {s}\\n", .{data});
}

// To run an async function, you typically need an event loop or a runner.
// For simplicity, this example just shows the function definition.

```

--------------------------------

TITLE: Zig: Basic Slice Operations and Bounds Checking
DESCRIPTION: Illustrates the creation and usage of slices in Zig, comparing them to arrays. It shows how slices are pointers with lengths, how to access elements, and demonstrates Zig's runtime bounds checking, which causes a panic when accessing an out-of-bounds index.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.1/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;

test "basic slices" {
    var array = [_]i32{ 1, 2, 3, 4 };
    // A slice is a pointer and a length. The difference between an array and
    // a slice is that the array's length is part of the type and known at
    // compile-time, whereas the slice's length is known at runtime.
    // Both can be accessed with the `len` field.
    var known_at_runtime_zero: usize = 0;
    const slice = array[known_at_runtime_zero..array.len];
    try expect(@TypeOf(slice) == []i32);
    try expect(&slice[0] == &array[0]);
    try expect(slice.len == array.len);

    // If you slice with comptime-known start and end positions, the result is
    // a pointer to an array, rather than a slice.
    const array_ptr = array[0..array.len];
    try expect(@TypeOf(array_ptr) == *[array.len]i32);

    // Using the address-of operator on a slice gives a single-item pointer,
    // while using the `ptr` field gives a many-item pointer.
    try expect(@TypeOf(slice.ptr) == [*]i32);
    try expect(@TypeOf(&slice[0]) == *i32);
    try expect(@ptrToInt(slice.ptr) == @ptrToInt(&slice[0]));

    // Slices have array bounds checking. If you try to access something out
    // of bounds, you'll get a safety check failure:
    slice[10] += 1;

    // Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`
    // asserts that the slice has len >= 1.
}
```

--------------------------------

TITLE: Zig Basic Slice Operations and Bounds Checking
DESCRIPTION: Explains the fundamental properties of Zig slices, including their composition of a pointer and a length. It demonstrates accessing slice elements and highlights the runtime array bounds checking mechanism with an example that causes a failure.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.2.0/index.html

LANGUAGE: zig
CODE:
```
const assert = @import("std").debug.assert;

test "basic slices" {
    var array = []i32{1, 2, 3, 4};
    const slice = array[0..array.len];
    assert(slice.ptr == &array[0]);
    assert(slice.len == array.len);

    slice[10] += 1; // Triggers bounds checking failure
}
```

--------------------------------

TITLE: Zig std.os.linux.getpid() Type Error Fix
DESCRIPTION: Resolves a type error in the `std.os.linux.getpid()` function. This ensures that the process ID is correctly retrieved and typed within the Linux operating system module.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const pid = std.os.linux.getpid();
```

--------------------------------

TITLE: Zig Comptime Slicing with Indexes
DESCRIPTION: Demonstrates how to slice arrays using comptime-known indexes in Zig. Prior to this change, an @ptrCast was required for such operations. This example shows the type inference for slices with both comptime and runtime indices.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;

test "slicing with comptime indexes" {
    var a = "abcdefgh".*;
    assert(@TypeOf(a) == [8:0]u8); // both indices are comptime, thus length is comptime
    var b = a[3..6];
    assert(@TypeOf(b) == *[3]u8); // length is runtime
    var runtime_i: usize = 3;
    var c = a[runtime_i..6];
    assert(@TypeOf(c) == []u8); // copy
    a[0..3].* = a[5..8].*;
    assert(std.mem.eql(u8, &a, "fghdefgh"));
}
```

--------------------------------

TITLE: Zig: ELF Module Updates
DESCRIPTION: Adds support for additional ELF section indexes and AMD64 relocation types, enhancing Zig's capabilities for working with executable and object files.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: zig
CODE:
```
elf: added a couple missing special section indexes.
elf: add amd64 relocation types.
```

--------------------------------

TITLE: Zig builtin @bitOffsetOf
DESCRIPTION: Shows the `@bitOffsetOf` built-in function in Zig, which returns the bit offset of a field within a struct.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const MyStruct = struct {
    a: u8,
    b: u16,
};
const offset_b = @bitOffsetOf(MyStruct, "b");
// offset_b is 8
```

--------------------------------

TITLE: Verbose C import with caching
DESCRIPTION: Shows how to use the `--verbose-cimport` flag with `zig build-exe` to see the cache locations for C imports. It also demonstrates a basic Zig program that uses `@cImport` to include stdio.h.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: Zig
CODE:
```
const c = @cImport({
    @cDefine("_NO_CRT_STDIO_INLINE", "1");
    @cInclude("stdio.h");
});
pub fn main() void {
    _ = c;
}
```

--------------------------------

TITLE: Zig Buffer Stream Replacement
DESCRIPTION: Details the removal of certain functions from `std.Buffer` in favor of `std.io.BufferOutStream`. Functions like `appendFormat`, `appendByte`, and `appendByteNTimes` are no longer available on `std.Buffer`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.Buffer.appendFormat
std.Buffer.appendByte
std.Buffer.appendByteNTimes
```

--------------------------------

TITLE: Zig noreturn type compatibility
DESCRIPTION: Demonstrates that the 'noreturn' type is compatible with all other types when resolving types in conditional expressions like if clauses or switch prongs. The example shows a function `foo` where a variable `a` is assigned a value from an `if` expression, with the `else` branch using `return`, which has the 'noreturn' type.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: Zig
CODE:
```
fn foo(condition: bool, b: u32) void {
    const a = if (condition) b else return;
    @panic("do something with a");
}
test "noreturn" {
    foo(false, 1);
}
```

--------------------------------

TITLE: Zig Type Reflection with @typeInfo
DESCRIPTION: Describes the @typeInfo built-in function in Zig, which provides type reflection capabilities. It guarantees that for structs, unions, enums, and error sets, the fields are ordered as declared. For other declarations, the order is unspecified.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html



--------------------------------

TITLE: Zig Result Type Propagation in Struct Initializer
DESCRIPTION: Demonstrates how result types propagate through a struct initializer in Zig. The example shows how the type of a struct field influences the expected type of an expression assigned to it, utilizing @intCast for type conversion.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: zig
CODE:
```
const expectEqual = @import("std").testing.expectEqual;
test "result type propagates through struct initializer" {
    const S = struct { x: u32 };
    const val: u64 = 123;
    const s: S = .{ .x = @intCast(val) };
    // .{ .x = @intCast(val) }   has result type `S` due to the type annotation
    //         @intCast(val)     has result type `u32` due to the type of the field `S.x`
    //                  val      has no result type, as it is permitted to be any integer type
    try expectEqual(@as(u32, 123), s.x);
}
```

--------------------------------

TITLE: Zig @cImport for C Header Inclusion
DESCRIPTION: Shows how to use the `@cImport` builtin function to import symbols from C header files. This example includes `stdio.h` and defines `_NO_CRT_STDIO_INLINE` to use `printf`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: zig
CODE:
```
const c = @cImport({
    // See https://github.com/ziglang/zig/issues/515
    @cDefine("_NO_CRT_STDIO_INLINE", "1");
    @cInclude("stdio.h");
});
pub fn main() void {
    _ = c.printf(c"hello\n");
}

```

--------------------------------

TITLE: Zig @memset with Undefined Values
DESCRIPTION: Describes an optimization in Zig's `@memset` function. When used to set bytes to `undefined`, Zig now employs a single Valgrind client request, improving performance in safe modes.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
@memset
```

LANGUAGE: Zig
CODE:
```
undefined
```

--------------------------------

TITLE: Zig Thread Spawning
DESCRIPTION: Introduces the `std.os.spawnThread` function, which allows for the creation of new threads across all supported targets. On Linux, its implementation leverages pthreads when linking with libc, and directly uses system calls when not linking with libc.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: zig
CODE:
```
std.os.spawnThread
```

--------------------------------

TITLE: Zig @exp for Floating-Point Exponential (e^x)
DESCRIPTION: Documents the `@exp` built-in function in Zig, which computes the base-e exponential of a floating-point number. It mentions hardware acceleration and support for float vectors, along with the general limitation regarding full implementation across all float types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html



--------------------------------

TITLE: Zig Packed Structs: Bit Casting Example
DESCRIPTION: Demonstrates using @bitCast between different packed structs, showcasing how memory is reinterpreted based on the packed layout. It includes checks for endianness to ensure correct field extraction.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const builtin = std.builtin;
const expect = std.testing.expect;

const Full = packed struct {
    number: u16,
};
const Divided = packed struct {
    half1: u8,
    quarter3: u4,
    quarter4: u4,
};

test "@bitCast between packed structs" {
    doTheTest();
    comptime doTheTest();
}

fn doTheTest() void {
    expect(@sizeOf(Full) == 2);
    expect(@sizeOf(Divided) == 2);
    var full = Full{ .number = 0x1234 };
    var divided = @bitCast(Divided, full);
    switch (builtin.endian) {
        .Big => {
            expect(divided.half1 == 0x12);
            expect(divided.quarter3 == 0x3);
            expect(divided.quarter4 == 0x4);
        },
        .Little => {
            expect(divided.half1 == 0x34);
            expect(divided.quarter3 == 0x2);
            expect(divided.quarter4 == 0x1);
        },
    }
}
```

--------------------------------

TITLE: Zig Bitwise OR Operator
DESCRIPTION: Explains the bitwise OR operator '|' for integers in Zig. It notes that the operation invokes Peer Type Resolution for the operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
a | b
a |= b
```

--------------------------------

TITLE: Base-2 Exponential with @exp2
DESCRIPTION: Details the @exp2 function for calculating the base-2 exponential of floating-point numbers and vectors of floats, mentioning hardware acceleration and potential implementation caveats.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: Zig
CODE:
```
@exp2(value: anytype) @TypeOf(value)
```

--------------------------------

TITLE: Zig Noreturn Type Compatibility Example
DESCRIPTION: Illustrates the compatibility of the 'noreturn' type in Zig. The 'noreturn' type is compatible with all other types when resolving types together, such as in 'if' clauses or 'switch' prongs. This example shows how 'return' can be used as an alternative in an 'if' statement.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: zig
CODE:
```
fn foo(condition: bool, b: u32) void {
    const a = if (condition) b else return;
    _ = a;
    @panic("do something with a");
}

test "noreturn" {
    foo(false, 1);
}
```

--------------------------------

TITLE: Zig Test: Result Location Semantics
DESCRIPTION: Demonstrates result location semantics in Zig tests. It defines structs for objects and points, and includes functions for conditional execution, object creation, and point generation. The test verifies the correct assignment and access of values within the Object struct.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

const Object = struct {
    tag: i32,
    pt: [2]Point,
};

const Point = struct {
    x: i32,
    y: i32,
};

test "result location semantics" {
    const result = if (condition()) foo(10) else bar();
    std.testing.expect(result.tag == 10);
    std.testing.expect(result.pt[0].x == 69);
    std.testing.expect(result.pt[1].y == 420);
}

fn condition() bool {
    return true;
}

fn foo(arg: i32) Object {
    return baz(arg);
}

fn bar() Object {
    return Object{
        .tag = 1,
        .pt = undefined,
    };
}

fn baz(arg: i32) Object {
    return Object{
        .tag = arg,
        .pt = [_]Point{
            nice(),
            blazet(),
        },
    };
}

fn nice() Point {
    return Point{
        .x = 69,
        .y = 69,
    };
}

fn blazet() Point {
    return Point{
        .x = 420,
        .y = 420,
    };
}
```

--------------------------------

TITLE: Zig @exp for Floating-Point Exponential (e^x)
DESCRIPTION: Documents the `@exp` built-in function in Zig, which computes the base-e exponential of a floating-point number. It mentions hardware acceleration and support for float vectors, along with the general limitation regarding full implementation across all float types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.0/index.html



--------------------------------

TITLE: Zig Result Type Propagation in Struct Initializer
DESCRIPTION: Demonstrates how Zig's result type propagation works within a struct initializer. The example shows how the type of a struct field influences the expected type of an expression assigned to it, utilizing @intCast for type conversion.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
const expectEqual = @import("std").testing.expectEqual;
test "result type propagates through struct initializer" {
    const S = struct { x: u32 };
    const val: u64 = 123;
    const s: S = .{ .x = @intCast(val) };
    // .{ .x = @intCast(val) }   has result type `S` due to the type annotation
    //         @intCast(val)     has result type `u32` due to the type of the field `S.x`
    //                  val      has no result type, as it is permitted to be any integer type
    try expectEqual(@as(u32, 123), s.x);
}
```

--------------------------------

TITLE: Zig Async Functions
DESCRIPTION: Zig supports asynchronous programming with `async` and `await` keywords, enabling non-blocking I/O and concurrent task execution. Suspend blocks allow for cooperative multitasking.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

// Example of an async function
async fn fetchData(url: []const u8) ![]const u8 {
    // Simulate fetching data asynchronously
    std.time.sleep(1 * std.time.ns_per_second);
    return "Some fetched data";
}

// Example of using async/await
async fn processData() void {
    const data = await fetchData("http://example.com");
    std.debug.print("Received: {s}\\n", .{data});
}

// To run an async function, you typically need an event loop or a runner.
// For simplicity, this example just shows the function definition.

```

--------------------------------

TITLE: Zig Builtin: @bitOffsetOf
DESCRIPTION: Demonstrates the `@bitOffsetOf` builtin function in Zig, which returns the bit offset of a field within a struct. This is useful for manual memory layout manipulation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    const MyStruct = struct {
        a: u8,
        b: u16,
    };
    const offset = @bitOffsetOf(MyStruct, "b");
    std.debug.print("Bit offset of field 'b': {d}\n", .{offset});
}
```

--------------------------------

TITLE: Zig Builtin: @bitOffsetOf
DESCRIPTION: Returns the byte offset of a field within a struct. Useful for manual memory layout manipulation and reflection.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.4.0/index.html

LANGUAGE: Zig
CODE:
```
const offset = @bitOffsetOf(StructType, .fieldName);
// offset is a usize value
```

--------------------------------

TITLE: Zig Anonymous Struct Literals
DESCRIPTION: Demonstrates Zig's anonymous struct literals, which allow omitting the struct type in a literal. The struct can be directly instantiated into a location if type coercion is possible, or the type can be inferred if not explicitly provided. Examples show usage with explicit and inferred types, and initializing unions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "anonymous struct literal" {
    checkPoint(.{ .x = 13, .y = 67 });
}

fn checkPoint(pt: struct {x: i32, y: i32}) void {
    expect(pt.x == 13);
    expect(pt.y == 67);
}
```

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous struct" {
    dump(.{ .int = 1234, .float = 12.34, .b = true, .s = "hi" });
}

fn dump(args: var) void {
    expect(args.int == 1234);
    expect(args.float == 12.34);
    expect(args.b);
    expect(args.s[0] == 'h');
    expect(args.s[1] == 'i');
}
```

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

const Number = union {
    int: i32,
    float: f64,
};

test "anonymous union literal syntax" {
    var i: Number = .{.int = 42};
    var f = makeNumber();
    expect(i.int == 42);
    expect(f.float == 12.34);
}

fn makeNumber() Number {
    return .{.float = 12.34};
}
```

--------------------------------

TITLE: Zig Linker: Incremental Codepath TLS Variable Emission
DESCRIPTION: Implements the emission of Thread-Local Storage (TLS) variables within the incremental codepath.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
implement emitting TLS variables in incremental codepath
```

--------------------------------

TITLE: Thread Local Storage in Zig
DESCRIPTION: Demonstrates the use of `threadlocal` variables in Zig, ensuring that each thread has its own independent copy of the variable.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const assert = std.debug.assert;

threadlocal var x: i32 = 1234;

test "thread local storage" {
    const thread1 = try std.Thread.spawn({}, testTls);
    const thread2 = try std.Thread.spawn({}, testTls);
    testTls({});
    thread1.wait();
    thread2.wait();
}

fn testTls(context: void) void {
    assert(x == 1234);
    x += 1;
    assert(x == 1235);
}
```

--------------------------------

TITLE: Zig Builtin: @bitOffsetOf
DESCRIPTION: Demonstrates the `@bitOffsetOf` builtin function in Zig, which returns the bit offset of a field within a struct. This is useful for manual memory layout manipulation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    const MyStruct = struct {
        a: u8,
        b: u16,
    };
    const offset = @bitOffsetOf(MyStruct, "b");
    std.debug.print("Bit offset of field 'b': {d}\n", .{offset});
}
```

--------------------------------

TITLE: Zig Standard Library: Memory Utilities
DESCRIPTION: The memory module has received several new functions and improvements. These include indexOfMin and indexOfMax, enhancements to mem.zeroes to work with comptime struct fields and extern unions, and fixes for mem.zeroInit with empty initializers. New functions like concatWithSentinel and splitBackwards have been added, along with first and reset methods for SplitIterator and SplitBackwardsIterator. The ascii.indexOfIgnoreCase function is now enhanced with the Boyer-Moore-Horspool algorithm.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

// Example: Using mem.zeroes with comptime struct fields
var data = std.mem.zeroes(struct {
    field1: u32,
    comptime field2: bool,
});

// Example: Using mem.indexOfMin
const numbers = [_]i32{ 5, 2, 8, 1, 9 };
const min_index = std.mem.indexOfMin(i32, &numbers) orelse unreachable;
std.debug.print("Index of minimum value: {d}\\n", .{min_index});

// Example: Using ascii.indexOfIgnoreCase
const haystack = "Hello World";
const needle = "world";
const index = std.ascii.indexOfIgnoreCase(u8, haystack, needle);

```

--------------------------------

TITLE: Zig: Slice Bounds Checking and Manipulation
DESCRIPTION: Demonstrates how to create slices from arrays using start and end indices and how these slices provide bounds checking. The example shows modifying an element through a slice and verifying the change in the original array.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.13.0/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

test "pointer slicing" {
    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    var start: usize = 2; // var to make it runtime-known
    _ = &start; // suppress 'var is never mutated' error
    const slice = array[start..4];
    try expect(slice.len == 2);

    try expect(array[3] == 4);
    slice[1] += 1;
    try expect(array[3] == 5);
}
```

--------------------------------

TITLE: Zig Tuple Type Declarations
DESCRIPTION: Demonstrates the new syntax for declaring tuple types using struct declaration syntax without field types. It also shows tuple concatenation and multiplication operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;
const expectEqualStrings = std.testing.expectEqualStrings;

test "tuple declarations" {
  const T = struct { u32, []const u8 };
  var t: T = .{ 1, "foo" };
  try expect(t[0] == 1);
  try expectEqualStrings(t[1], "foo");

  var mul = t ** 3;
  try expect(@TypeOf(mul) != T);
  try expect(mul.len == 6);
  try expect(mul[2] == 1);
  try expectEqualStrings(mul[3], "foo");

  var t2: T = .{ 2, "bar" };
  var cat = t ++ t2;
  try expect(@TypeOf(cat) != T);
  try expect(cat.len == 4);
  try expect(cat[2] == 2);
  try expectEqualStrings(cat[3], "bar");
}
```

--------------------------------

TITLE: Enable Thread Sanitizer in Zig
DESCRIPTION: The `-fsanitize-thread` option is now available to detect data races in Zig programs. This feature is based on Clang's ThreadSanitizer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html

LANGUAGE: zig
CODE:
```
#zig build-exe src/main.zig -fsanitize-thread
```

--------------------------------

TITLE: Zig WASI: Read Command Line Arguments
DESCRIPTION: Demonstrates how to use Zig's standard library to read command-line arguments when compiling for WASI. It allocates memory for arguments, iterates through them, and prints each argument with its index. The example includes the shell commands to build and run the Zig code using `wasm32-wasi` target and `wasmtime`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.10.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = general_purpose_allocator.allocator();
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    for (args) |arg, i| {
        std.debug.print("{}: {s}\n", .{ i, arg });
    }
}
```

--------------------------------

TITLE: Zig Pointer Address Syntax and Mutability
DESCRIPTION: Demonstrates how to get the address of variables in Zig, distinguishing between constant and mutable pointers. It shows how to assert pointer types and mutate values through mutable pointers.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.5.0/index.html

LANGUAGE: Zig
CODE:
```
const assert = @import("std").debug.assert;

test "address of syntax" {
        // When you get the address of a const variable, you get a const pointer to a single item.
        var x: i32 = 1234;
        const x_ptr = &x;
        assert(@typeOf(x_ptr) == *const i32);
    
        // If you want to mutate the value, you'd need an address of a mutable variable:
        var y: i32 = 5678;
        const y_ptr = &y;
        assert(@typeOf(y_ptr) == *i32);
        y_ptr.* += 1;
        assert(y_ptr.* == 5679);
    }
```

--------------------------------

TITLE: Zig Cast Return Type and Big Int Allocator
DESCRIPTION: Modifies `cast` to return an optional value instead of an error. Updates `big.int.toString()` to use a provided allocator and addresses potential UAF issues.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Made `cast` return optional instead of an error.
big int: update Managed.toString() to use provided allocator
big int: breaking API changes to prevent UAF
```

--------------------------------

TITLE: Zig: Inline Switch Prongs with Ranges
DESCRIPTION: Illustrates the use of Zig's `inline` keyword with ranges in switch prongs. The `isFieldOptional` function is adapted to handle a range of field indices, checking for optional fields within that range.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.0/index.html

LANGUAGE: zig
CODE:
```
fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T)."struct".fields;
    return switch (field_index) {
        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].type) == .optional,
        else => return error.IndexOutOfBounds,
    };
}
```

--------------------------------

TITLE: Fix BufferedInStream Not Reading Delayed Input in Zig
DESCRIPTION: Corrects a bug in `BufferedInStream` where it was not reading delayed input. This ensures that buffered input streams function correctly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.4.0/release-notes.html

LANGUAGE: Zig
CODE:
```
/*
* sjdh02 fixed BufferedInStream not reading delayed input.
*/
```

--------------------------------

TITLE: Zig String Literal to Constant Slice Success
DESCRIPTION: Shows the correct way to pass a string literal to a function in Zig by using a constant slice (`[]const u8`). This avoids type errors as string literals are inherently constant.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.6.0/index.html

LANGUAGE: zig
CODE:
```
fn foo(s: []const u8) void {}

test "string literal to constant slice" {
    foo("hello");
}
```

--------------------------------

TITLE: Improve Big-Endian Compatibility
DESCRIPTION: LemonBoy improved big-endian compatibility within the Zig project. This enhances the language's ability to function correctly on systems that use big-endian byte ordering.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html



--------------------------------

TITLE: Zig Result Type Propagation in Struct Initializer
DESCRIPTION: Demonstrates how result types propagate through a struct initializer in Zig. The example shows how the type of a struct field influences the expected type of an expression assigned to it, utilizing @intCast for type conversion.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.0/index.html

LANGUAGE: zig
CODE:
```
const expectEqual = @import("std").testing.expectEqual;
test "result type propagates through struct initializer" {
    const S = struct { x: u32 };
    const val: u64 = 123;
    const s: S = .{ .x = @intCast(val) };
    // .{ .x = @intCast(val) }   has result type `S` due to the type annotation
    //         @intCast(val)     has result type `u32` due to the type of the field `S.x`
    //                  val      has no result type, as it is permitted to be any integer type
    try expectEqual(@as(u32, 123), s.x);
}
```

--------------------------------

TITLE: Zig String Literal Properties
DESCRIPTION: Demonstrates the properties of Zig string literals, including their type, length, null termination, and character access. It also shows the conversion of character literals to integer types and the comparison of string literals.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: zig
CODE:
```
const expect = @import("std").testing.expect;
const mem = @import("std").mem;

test "string literals" {
    const bytes = "hello";
    expect(@TypeOf(bytes) == *const [5:0]u8);
    expect(bytes.len == 5);
    expect(bytes[1] == 'e');
    expect(bytes[5] == 0);
    expect('e' == '\x65');
    expect('\u{1f4a9}' == 128169);
    expect('' == 128175);
    expect(mem.eql(u8, "hello", "h\x65llo"));
}
```

--------------------------------

TITLE: Zig: Implement Writer Functions
DESCRIPTION: Demonstrates how to define functions `writeInt` and `writeFloat` that accept a writer and a value, with placeholders for actual implementation logic.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
fn writeInt(self: *Writer, value: anytype) !void {
    _ = self;
    _ = value;
}
fn writeFloat(self: *Writer, value: anytype) !void {
    _ = self;
    _ = value;
}
```

--------------------------------

TITLE: Zig: Add mem.alignPointerOffset
DESCRIPTION: Introduces `mem.alignPointerOffset`, a utility for calculating the offset needed to align a pointer.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.9.0/release-notes.html

LANGUAGE: Zig
CODE:
```
mem.alignPointerOffset
```

--------------------------------

TITLE: Zig: Support returning !u8 from main()
DESCRIPTION: Zig now supports returning `!u8` from the `main` function. This allows the main function to return an error code, providing more flexibility in program termination.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.5.0/release-notes.html

LANGUAGE: Zig
CODE:
```
!u8
```

--------------------------------

TITLE: Zig Function Parameter Type Inference
DESCRIPTION: Illustrates Zig's function parameter type inference using `anytype`. The example defines an `addFortyTwo` function that accepts any type for its parameter `x` and returns the same type. It demonstrates calling this function with an integer literal and an `i64`, verifying the return type using `@TypeOf`.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.14.1/index.html

LANGUAGE: Zig
CODE:
```
const expect = @import("std").testing.expect;

fn addFortyTwo(x: anytype) @TypeOf(x) {
    return x + 42;
}

test "fn type inference" {
    try expect(addFortyTwo(1) == 43);
    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
    const y: i64 = 2;
    try expect(addFortyTwo(y) == 44);
    try expect(@TypeOf(addFortyTwo(y)) == i64);
}
```

LANGUAGE: Shell
CODE:
```
$ zig test test_fn_type_inference.zig
1/1 test_fn_type_inference.test.fn type inference...OK
All 1 tests passed.
```

--------------------------------

TITLE: Zig: Coerce Pointers to Slices and Arrays
DESCRIPTION: Demonstrates coercing constant pointers to arrays into slices, including handling different destination types like error unions and optionals. It also shows how array lengths map to slice lengths and how single-item pointers can be coerced to arrays.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

// You can assign constant pointers to arrays to a slice with
// const modifier on the element type. Useful in particular for
// String literals.
test "*const [N]T to []const T" {
    var x1: []const u8 = "hello";
    var x2: []const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, x1, x2));

    var y: []const f32 = &[2]f32{ 1.2, 3.4 };
    try expect(y[0] == 1.2);
}

// Likewise, it works when the destination type is an error union.
test "*const [N]T to E![]const T" {
    var x1: anyerror![]const u8 = "hello";
    var x2: anyerror![]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, try x1, try x2));

    var y: anyerror![]const f32 = &[2]f32{ 1.2, 3.4 };
    try expect((try y)[0] == 1.2);
}

// Likewise, it works when the destination type is an optional.
test "*const [N]T to ?[]const T" {
    var x1: ?[]const u8 = "hello";
    var x2: ?[]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, x1.?, x2.?));

    var y: ?[]const f32 = &[2]f32{ 1.2, 3.4 };
    try expect(y.?[0] == 1.2);
}

// In this cast, the array length becomes the slice length.
test "*[N]T to []T" {
    var buf: [5]u8 = "hello".*;
    const x: []u8 = &buf;
    try expect(std.mem.eql(u8, x, "hello"));

    const buf2 = [2]f32{ 1.2, 3.4 };
    const x2: []const f32 = &buf2;
    try expect(std.mem.eql(f32, x2, &[2]f32{ 1.2, 3.4 }));
}

// Single-item pointers to arrays can be coerced to many-item pointers.
test "*[N]T to [*]T" {
    var buf: [5]u8 = "hello".*;
    const x: [*]u8 = &buf;
    try expect(x[4] == 'o');
    // x[5] would be an uncaught out of bounds pointer dereference!
}

// Likewise, it works when the destination type is an optional.
test "*[N]T to ?[*]T" {
    var buf: [5]u8 = "hello".*;
    const x: ?[*]u8 = &buf;
    try expect(x.?[4] == 'o');
}

// Single-item pointers can be cast to len-1 single-item arrays.
test "*T to *[1]T" {
    var x: i32 = 1234;
    const y: *[1]i32 = &x;
    const z: [*]i32 = y;
    try expect(z[0] == 1234);
}
```

--------------------------------

TITLE: Zig BitSet and EnumSet Pure Functions
DESCRIPTION: Introduction of pure functions for StaticBitSet and EnumSet in Zig's standard library. These functions enable set operations like equality checking, subset, superset, complement, union, intersection, XOR, and difference.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.11.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std: added pure functions to StaticBitSet and EnumSet

fn eql(self: Self, other: Self) bool
fn subsetOf(self: Self, other: Self) bool
fn supersetOf(self: Self, other: Self) bool
fn complement(self: Self) Self
fn unionWith(self: Self, other: Self) Self
fn intersectWith(self: Self, other: Self) Self
fn xorWith(self: Self, other: Self) Self
fn differenceWith(self: Self, other: Self) Self
```

--------------------------------

TITLE: Zig Bitwise And Operator
DESCRIPTION: Performs bitwise AND operation on integers. Invokes peer type resolution for operands.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
0b011 & 0b101 == 0b001
```

--------------------------------

TITLE: Zig Atomic Read-Modify-Write Operations
DESCRIPTION: Defines the types of read-modify-write operations supported for atomic variables in Zig, such as Xchg, Add, Sub, and bitwise operations.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.3.0/index.html

LANGUAGE: zig
CODE:
```
pub const AtomicRmwOp = enum {
        Xchg,
        Add,
        Sub,
        And,
        Nand,
        Or,
        Xor,
        Max,
        Min,
    };

```

--------------------------------

TITLE: Zig File System Error Sets and Iterator Fixes
DESCRIPTION: Defines a static error set for `fs.Dir.copyFile` and fixes issues with using `fs.Dir.Iterator` twice. Improves handling of `ENOENT` errors during iteration.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.10.0/release-notes.html

LANGUAGE: Zig
CODE:
```
Define static error set for fs.Dir.copyFile
Fixed using fs.Dir.Iterator twice
End iteration on Linux/WASI during Iterator.next when hitting `ENOENT`
```

--------------------------------

TITLE: Zig: Field Access by Compile-Time String
DESCRIPTION: Demonstrates accessing struct fields and declarations using a compile-time string with the `@field` built-in function. This function works for both instance fields and static declarations within types.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

const Point = struct {
    x: u32,
    y: u32,

    pub var z: u32 = 1;
};

test "field access by string" {
    const expect = std.testing.expect;
    var p = Point{ .x = 0, .y = 0 };

    @field(p, "x") = 4;
    @field(p, "y") = @field(p, "x") + 1;

    try expect(@field(p, "x") == 4);
    try expect(@field(p, "y") == 5);
}

test "decl access by string" {
    const expect = std.testing.expect;

    try expect(@field(Point, "z") == 1);

    @field(Point, "z") = 2;
    try expect(@field(Point, "z") == 2);
}
```

--------------------------------

TITLE: Zig Doc Comments for Structs and Functions
DESCRIPTION: Demonstrates the use of documentation comments (`///`) in Zig for documenting structs, their fields, and their methods. It shows how multiple `///` comments are merged into a multiline doc comment.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.7.0/index.html

LANGUAGE: Zig
CODE:
```
/// A structure for storing a timestamp, with nanosecond precision (this is a
/// multiline doc comment).
const Timestamp = struct {
    /// The number of seconds since the epoch (this is also a doc comment).
    seconds: i64,  // signed so we can represent pre-1970 (not a doc comment)
    /// The number of nanoseconds past the second (doc comment again).
    nanos: u32,

    /// Returns a `Timestamp` struct representing the Unix epoch; that is, the
    /// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).
    pub fn unixEpoch() Timestamp {
        return Timestamp{
            .seconds = 0,
            .nanos = 0,
        };
    }
};
```

--------------------------------

TITLE: Zig Built-in Function: @atomicLoad
DESCRIPTION: Introduces the `@atomicLoad` built-in function for atomic memory operations. This function is crucial for concurrent programming, ensuring that memory reads are performed atomically to prevent race conditions.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.3.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const value = @atomicLoad(pointer_to_atomic_variable, .Acquire);
```

--------------------------------

TITLE: Zig Builtin: @byteOffsetOf
DESCRIPTION: The `@byteOffsetOf` builtin function returns the byte offset of a field within a struct.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: Zig
CODE:
```
const MyStruct = struct {
    a: u8,
    b: u16,
};
const offset_b = @byteOffsetOf(MyStruct, "b");
// offset_b is 1 (since 'a' is 1 byte)
```

--------------------------------

TITLE: Zig Test Execution for Anonymous Struct
DESCRIPTION: Displays the shell command to test the Zig code with a fully anonymous struct literal and the successful test execution output.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Shell
CODE:
```
$ zig test test_anonymous_struct.zig
1/1 test_anonymous_struct.test.fully anonymous struct... OK
All 1 tests passed.
```

--------------------------------

TITLE: Define and Use dev_t for Linux x86_64
DESCRIPTION: This change introduces the definition and usage of `dev_t` for the Linux x86_64 architecture within the OS module. `dev_t` is a data type used to represent device IDs in Unix-like systems.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.7.1/release-notes.html

LANGUAGE: zig
CODE:
```
const dev_t = c_long;
```

--------------------------------

TITLE: Zig @TypeOf Example: No Runtime Side Effects
DESCRIPTION: Demonstrates the usage of the @TypeOf builtin function in Zig, showing that it has no runtime side effects. It verifies the type of a function's return value and checks that a variable remains unchanged.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.15.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "no runtime side effects" {
    var data: i32 = 0;
    const T = @TypeOf(foo(i32, &data));
    try comptime expect(T == i32);
    try expect(data == 0);
}

fn foo(comptime T: type, ptr: *T) T {
    ptr.* += 1;
    return ptr.*;
}
```

--------------------------------

TITLE: Zig @TypeOf Example with No Runtime Side Effects
DESCRIPTION: Demonstrates the usage of the @TypeOf built-in function in Zig, specifically highlighting that expressions passed to it are guaranteed to have no runtime side-effects. This example tests that the type of a function's return value is correctly inferred and that a variable passed by pointer is not modified.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.1/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "no runtime side effects" {
    var data: i32 = 0;
    const T = @TypeOf(foo(i32, &data));
    comptime try expect(T == i32);
    try expect(data == 0);
}

fn foo(comptime T: type, ptr: *T) T {
    ptr.* += 1;
    return ptr.*;
}
```

--------------------------------

TITLE: Optimize Timer.lap to Read System Time Once
DESCRIPTION: The `std.time.Timer.lap` function has been optimized to read the system time only once per call. This reduces overhead and improves the accuracy of timing measurements.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
std.time.Timer.lap
```

--------------------------------

TITLE: Integrate Mutex with pthreads
DESCRIPTION: Integrates Mutex with pthreads for improved thread synchronization in Zig, providing a more robust and standard-compliant mutex implementation.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.8.0/release-notes.html



--------------------------------

TITLE: Zig SIMD: Vector Element Access
DESCRIPTION: Shows how Zig's SIMD vectors support element access syntax, allowing individual elements to be read or modified. This example demonstrates setting and retrieving values from a vector.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/download/0.6.0/release-notes.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

test "vector element access" {
    var v: @Vector(4, i32) = [_]i32{ 1, 5, 3, undefined };
    v[2] = 42;
    expect(v[1] == 5);
    v[3] = -364;
    expect(v[2] == 42);
    expect(-364 == v[3]);

    storev(&v[0], 100);
    expect(v[0] == 100);
}

fn storev(ptr: var, x: i32) void {
    ptr.* = x;
}
```

--------------------------------

TITLE: Zig Atomics: Atomic Store
DESCRIPTION: Shows how to perform an atomic store operation in Zig, writing a value to memory atomically. This ensures that writes to shared memory are indivisible and visible to other threads correctly.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.12.1/index.html

LANGUAGE: Zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_var: std.atomic.Atomic(u32) = std.atomic.Atomic(u32){ .value = 0 };
    std.atomic.store(u32, &atomic_var, 20, .SeqCst);
    const value = std.atomic.load(u32, &atomic_var, .SeqCst);
    std.debug.print("Stored value: {d}\n", .{value});
}
```

--------------------------------

TITLE: Zig Function Type Inference Test
DESCRIPTION: Tests the type inference capabilities of Zig functions. It verifies that the return type of `addFortyTwo` is correctly inferred as `comptime_int` for a literal input and `i64` for a variable input.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.8.1/index.html

LANGUAGE: zig
CODE:
```
test "fn type inference" {
        try expect(addFortyTwo(1) == 43);
        try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
        var y: i64 = 2;
        try expect(addFortyTwo(y) == 44);
        try expect(@TypeOf(addFortyTwo(y)) == i64);
    }
```

--------------------------------

TITLE: Zig: Coerce Pointers to Slices and Arrays
DESCRIPTION: Demonstrates coercing constant pointers to arrays into slices, including handling different destination types like error unions and optionals. It also shows how array lengths map to slice lengths and how single-item pointers can be coerced to arrays.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.9.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");
const expect = std.testing.expect;

// You can assign constant pointers to arrays to a slice with
// const modifier on the element type. Useful in particular for
// String literals.
test "*const [N]T to []const T" {
    var x1: []const u8 = "hello";
    var x2: []const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, x1, x2));

    var y: []const f32 = &[2]f32{ 1.2, 3.4 };
    try expect(y[0] == 1.2);
}

// Likewise, it works when the destination type is an error union.
test "*const [N]T to E![]const T" {
    var x1: anyerror![]const u8 = "hello";
    var x2: anyerror![]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, try x1, try x2));

    var y: anyerror![]const f32 = &[2]f32{ 1.2, 3.4 };
    try expect((try y)[0] == 1.2);
}

// Likewise, it works when the destination type is an optional.
test "*const [N]T to ?[]const T" {
    var x1: ?[]const u8 = "hello";
    var x2: ?[]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, x1.?, x2.?));

    var y: ?[]const f32 = &[2]f32{ 1.2, 3.4 };
    try expect(y.?[0] == 1.2);
}

// In this cast, the array length becomes the slice length.
test "*[N]T to []T" {
    var buf: [5]u8 = "hello".*;
    const x: []u8 = &buf;
    try expect(std.mem.eql(u8, x, "hello"));

    const buf2 = [2]f32{ 1.2, 3.4 };
    const x2: []const f32 = &buf2;
    try expect(std.mem.eql(f32, x2, &[2]f32{ 1.2, 3.4 }));
}

// Single-item pointers to arrays can be coerced to many-item pointers.
test "*[N]T to [*]T" {
    var buf: [5]u8 = "hello".*;
    const x: [*]u8 = &buf;
    try expect(x[4] == 'o');
    // x[5] would be an uncaught out of bounds pointer dereference!
}

// Likewise, it works when the destination type is an optional.
test "*[N]T to ?[*]T" {
    var buf: [5]u8 = "hello".*;
    const x: ?[*]u8 = &buf;
    try expect(x.?[4] == 'o');
}

// Single-item pointers can be cast to len-1 single-item arrays.
test "*T to *[1]T" {
    var x: i32 = 1234;
    const y: *[1]i32 = &x;
    const z: [*]i32 = y;
    try expect(z[0] == 1234);
}
```

--------------------------------

TITLE: Zig Builtin: @atomicLoad
DESCRIPTION: Illustrates the `@atomicLoad` builtin function in Zig for performing atomic reads from memory. This ensures that values are read without interference from other threads.

SOURCE: https://github.com/ziglang/www.ziglang.org/blob/main/src/documentation/0.11.0/index.html

LANGUAGE: zig
CODE:
```
const std = @import("std");

pub fn main() void {
    var atomic_counter: std.atomic.Atomic(u64) = .{ .value = 100 };
    const current_value = @atomicLoad(u64, &atomic_counter, .SeqCst);
    std.debug.print("Current atomic value: {d}", .{current_value});
}

```